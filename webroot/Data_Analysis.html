<!DOCTYPE html>
<html lang="zh-Hant">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>數據分析與機器學習平台</title>

    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Plotly.js for interactive charts -->
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>

    <!-- SheetJS (xlsx.full.min.js) for reading Excel files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <!-- simple-statistics for basic stats -->
    <script src="https://unpkg.com/simple-statistics@7.8.3/dist/simple-statistics.min.js"></script>

    <!-- jStat for advanced statistical functions -->
    <script src="https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js"></script>

    <!-- regression-js (not used by runLogistic anymore) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/regression/2.0.1/regression.min.js"></script>

    <!-- ml.js for Decision Tree -->
    <script src="https://www.lactame.com/lib/ml/6.0.0/ml.min.js"></script>

    <!-- html2canvas for Wordcloud PNG download -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>


    <style>
        body {
            font-family: 'Inter', 'Noto Sans TC', sans-serif;
            background-color: #f8fafc;
        }

        .tab-button {
            transition: all 0.2s ease;
            border-bottom: 2px solid transparent;
            color: #64748b;
            /* slate-500 */
            margin-bottom: -1px;
            /* Overlap border */
        }

        .tab-button:hover {
            color: #1e293b;
            /* slate-800 */
            background-color: #f1f5f9;
            /* slate-100 */
        }

        .tab-button.active {
            font-weight: 600;
            background-color: #fff;
            border-top: 2px solid;
            /* Top highlight */
            border-left: 1px solid #e2e8f0;
            border-right: 1px solid #e2e8f0;
            border-bottom-color: transparent;
            /* Hide bottom border to merge with content */
            box-shadow: 0 -4px 6px -1px rgba(0, 0, 0, 0.02);
        }

        /* Specific active colors for top border and text */
        .tab-button[data-tab="eda"].active {
            color: #2563eb;
            border-top-color: #2563eb;
        }

        .tab-button[data-tab="basic"].active {
            color: #059669;
            border-top-color: #059669;
        }

        .tab-button[data-tab="forecast"].active {
            color: #d97706;
            border-top-color: #d97706;
        }

        .tab-button[data-tab="ml"].active {
            color: #7c3aed;
            border-top-color: #7c3aed;
        }

        /* When a top-level tab is active, give its child/sub-menu buttons the same color
           by toggling a class on #analysisContent (handled in switchTab). */
        #analysisContent.active-tab-eda .ml-tab-button,
        #analysisContent.active-tab-eda .basic-tab-button,
        #analysisContent.active-tab-eda .forecast-tab-button {
            color: #2563eb;
        }

        #analysisContent.active-tab-basic .basic-tab-button,
        #analysisContent.active-tab-basic .basic-tab-button:not(.active) {
            color: #059669;
        }

        #analysisContent.active-tab-forecast .forecast-tab-button,
        #analysisContent.active-tab-forecast .forecast-tab-button:not(.active) {
            color: #d97706;
        }

        #analysisContent.active-tab-ml .ml-tab-button,
        #analysisContent.active-tab-ml .ml-tab-button:not(.active) {
            color: #7c3aed;
        }

        /* Group-specific button backgrounds and active/hover states */

        /* Shared base style for sub-tabs */
        .basic-tab-button,
        .forecast-tab-button,
        .ml-tab-button {
            padding: 0.5rem 1rem;
            border-radius: 9999px;
            /* Pill shape */
            font-weight: 500;
            transition: all 0.2s ease;
            border: 1px solid transparent;
            margin-bottom: 0.5rem;
            /* For wrapping */
        }

        /* Basic analysis (green) */
        #analysisContent.active-tab-basic .basic-tab-button {
            color: #4b5563;
            /* gray-600 */
        }

        #analysisContent.active-tab-basic .basic-tab-button:hover {
            color: #059669;
            background-color: #ecfdf5;
            /* emerald-50 */
        }

        #analysisContent.active-tab-basic .basic-tab-button.active {
            color: #047857;
            /* emerald-700 */
            background-color: #d1fae5;
            /* emerald-100 */
            border-color: #a7f3d0;
            /* emerald-200 */
            box-shadow: none;
        }

        /* Forecast (orange) */
        #analysisContent.active-tab-forecast .forecast-tab-button {
            color: #4b5563;
            /* gray-600 */
        }

        #analysisContent.active-tab-forecast .forecast-tab-button:hover {
            color: #d97706;
            background-color: #fff7ed;
            /* orange-50 */
        }

        #analysisContent.active-tab-forecast .forecast-tab-button.active {
            color: #c2410c;
            /* orange-700 */
            background-color: #ffedd5;
            /* orange-100 */
            border-color: #fed7aa;
            /* orange-200 */
            box-shadow: none;
        }

        /* ML (purple) */
        #analysisContent.active-tab-ml .ml-tab-button {
            color: #4b5563;
            /* gray-600 */
        }

        #analysisContent.active-tab-ml .ml-tab-button:hover {
            color: #7c3aed;
            background-color: #f5f3ff;
            /* violet-50 */
        }

        #analysisContent.active-tab-ml .ml-tab-button.active {
            color: #6d28d9;
            /* violet-700 */
            background-color: #ede9fe;
            /* violet-100 */
            border-color: #ddd6fe;
            /* violet-200 */
            box-shadow: none;
        }

        /* ===== Override action button colors per analysis group ===== */
        /* Apply to <button> and input buttons inside each group's content area */
        /* Basic -> Green */
        #analysisContent.active-tab-basic #basicContent button:not(.basic-tab-button),
        #analysisContent.active-tab-basic #basicContent input[type="button"]:not(.basic-tab-button),
        #analysisContent.active-tab-basic #basicContent input[type="submit"]:not(.basic-tab-button) {
            background: linear-gradient(135deg, #10B981 0%, #059669 100%) !important;
            color: #ffffff !important;
            border-color: transparent !important;
            box-shadow: 0 8px 24px rgba(5, 150, 105, 0.12) !important;
        }

        #analysisContent.active-tab-basic #basicContent button:hover,
        #analysisContent.active-tab-basic #basicContent input[type="button"]:hover,
        #analysisContent.active-tab-basic #basicContent input[type="submit"]:hover {
            filter: brightness(0.95) !important;
            transform: translateY(-1px);
        }

        /* Forecast -> Orange */
        #analysisContent.active-tab-forecast #forecastContent button:not(.forecast-tab-button),
        #analysisContent.active-tab-forecast #forecastContent input[type="button"]:not(.forecast-tab-button),
        #analysisContent.active-tab-forecast #forecastContent input[type="submit"]:not(.forecast-tab-button) {
            background: linear-gradient(135deg, #fb923c 0%, #d97706 100%) !important;
            color: #ffffff !important;
            border-color: transparent !important;
            box-shadow: 0 8px 24px rgba(217, 119, 6, 0.12) !important;
        }

        #analysisContent.active-tab-forecast #forecastContent button:hover,
        #analysisContent.active-tab-forecast #forecastContent input[type="button"]:hover,
        #analysisContent.active-tab-forecast #forecastContent input[type="submit"]:hover {
            filter: brightness(0.95) !important;
            transform: translateY(-1px);
        }

        /* ML -> Purple */
        #analysisContent.active-tab-ml #mlContent button:not(.ml-tab-button),
        #analysisContent.active-tab-ml #mlContent input[type="button"]:not(.ml-tab-button),
        #analysisContent.active-tab-ml #mlContent input[type="submit"]:not(.ml-tab-button) {
            background: linear-gradient(135deg, #a78bfa 0%, #7c3aed 100%) !important;
            color: #ffffff !important;
            border-color: transparent !important;
            box-shadow: 0 8px 24px rgba(124, 58, 237, 0.12) !important;
        }

        #analysisContent.active-tab-ml #mlContent button:hover,
        #analysisContent.active-tab-ml #mlContent input[type="button"]:hover,
        #analysisContent.active-tab-ml #mlContent input[type="submit"]:hover {
            filter: brightness(0.95) !important;
            transform: translateY(-1px);
        }

        .card {
            background-color: white;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }

        /* Collapsible details styling */
        details.card > summary {
            list-style: none;
        }
        details.card > summary::-webkit-details-marker {
            display: none;
        }
        details.card > summary .details-chevron {
            transition: transform 0.2s ease-in-out;
        }
        details.card[open] > summary .details-chevron {
            transform: rotate(180deg);
        }
        details.card:not([open]) {
            padding-bottom: 1rem;
        }

        .loader {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 2rem auto;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        input[type="file"]::file-selector-button {
            background-color: #2563eb;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        input[type="file"]::file-selector-button:hover {
            background-color: #1d4ed8;
        }

        /* Custom styled '選擇檔案' button (accessible + highlighted state) */
        .file-input-wrapper {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .file-btn {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: #fff;
            padding: 0.55rem 1rem;
            border-radius: 0.625rem;
            font-weight: 700;
            font-size: 0.95rem;
            box-shadow: 0 8px 24px rgba(37, 99, 235, 0.16);
            border: none;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            transition: transform 0.18s ease, box-shadow 0.18s ease;
        }

        .file-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 30px rgba(37, 99, 235, 0.2);
        }

        .file-btn:focus {
            outline: 3px solid rgba(59, 130, 246, 0.22);
            outline-offset: 3px;
        }

        .file-btn.highlight {
            animation: pulse-highlight 2.2s infinite;
        }

        @keyframes pulse-highlight {
            0% {
                box-shadow: 0 8px 22px rgba(59, 130, 246, 0.18);
            }

            50% {
                box-shadow: 0 18px 40px rgba(59, 130, 246, 0.22);
            }

            100% {
                box-shadow: 0 8px 22px rgba(59, 130, 246, 0.18);
            }
        }

        .chosen-filename {
            font-size: 0.92rem;
            color: #374151;
            max-width: 30rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .sr-only {
            position: absolute !important;
            width: 1px !important;
            height: 1px !important;
            padding: 0 !important;
            margin: -1px !important;
            overflow: hidden !important;
            clip: rect(0, 0, 0, 0) !important;
            white-space: nowrap !important;
            border: 0 !important;
        }

        .ml-tab-button {
            padding-bottom: 0.5rem;
            border-bottom: 3px solid transparent;
        }

        .ml-tab-button.active {
            color: #db2777;
            border-bottom-color: #db2777;
        }

        .basic-tab-button {
            padding-bottom: 0.5rem;
            border-bottom: 3px solid transparent;
        }

        .basic-tab-button.active {
            color: #059669;
            border-bottom-color: #059669;
        }

        .forecast-tab-button {
            padding-bottom: 0.5rem;
            border-bottom: 3px solid transparent;
        }

        .forecast-tab-button.active {
            color: #d97706;
            border-bottom-color: #d97706;
        }

        /* Refined ML Tab Styles based on User Request (Solid vs Hollow) */
        
        /* Refined ML Tab Styles based on User Request (Solid vs Hollow) */
        
        /* 1. Supervised Learning (Solid/Filled) */
        #analysisContent.active-tab-ml .ml-tab-button.supervised {
            background-color: #8b5cf6 !important; /* violet-500 */
            color: white !important;
            border: 1px solid transparent !important;
            background-image: none !important; /* Remove gradient */
            box-shadow: none !important;
        }
        
        #analysisContent.active-tab-ml .ml-tab-button.supervised:hover {
            background-color: #7c3aed !important; /* violet-600 */
        }
        
        #analysisContent.active-tab-ml .ml-tab-button.supervised.active {
            background-color: #6d28d9 !important; /* violet-700 */
            box-shadow: 0 0 0 2px #ddd6fe !important; /* violet-200 ring */
        }

        /* 2. Unsupervised Learning (Hollow/Outline) */
        #analysisContent.active-tab-ml .ml-tab-button.unsupervised {
            background-color: transparent !important;
            color: #8b5cf6 !important; /* violet-500 */
            border: 1px solid #8b5cf6 !important;
            background-image: none !important;
            box-shadow: none !important;
        }
        
        #analysisContent.active-tab-ml .ml-tab-button.unsupervised:hover {
            background-color: #f5f3ff !important; /* violet-50 */
            color: #7c3aed !important;
        }
        
        #analysisContent.active-tab-ml .ml-tab-button.unsupervised.active {
            background-color: #ede9fe !important; /* violet-100 */
            color: #5b21b6 !important; /* violet-800 */
            border-color: #8b5cf6 !important;
            font-weight: bold !important;
        }

        /* ===== v2.5 革命性修復: Modal 彈窗樣式 ===== */
        .prediction-modal {
            display: none;
            position: fixed;
            z-index: 999999;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.6);
            animation: fadeIn 0.3s ease;
        }

        .prediction-modal.show {
            display: flex !important;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background-color: #ffffff;
            padding: 2.5rem;
            border-radius: 1rem;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 600px;
            width: 90%;
            animation: slideDown 0.4s ease;
            position: relative;
        }

        .modal-header {
            font-size: 1.75rem;
            font-weight: bold;
            color: #1f2937;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 3px solid #3b82f6;
        }

        .modal-result {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            padding: 1.5rem;
            border-radius: 0.75rem;
            margin: 1.5rem 0;
            border-left: 5px solid #3b82f6;
        }

        .modal-result-item {
            margin: 1rem 0;
            font-size: 1.125rem;
        }

        .modal-prob-value {
            font-size: 2rem;
            font-weight: bold;
            color: #059669;
        }

        .modal-close-btn {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            padding: 0.75rem 2rem;
            border: none;
            border-radius: 0.5rem;
            font-size: 1.125rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            margin-top: 1rem;
        }

        .modal-close-btn:hover {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(37, 99, 235, 0.3);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        @keyframes slideDown {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .wordcloud-word {
            display: inline-block;
            margin: 0.2rem 0.4rem;
            line-height: 1;
            white-space: nowrap;
        }

        /* 強化欄位選擇 UI */
        select {
            border-width: 2px;
            border-color: #4B5563;
            font-weight: 600;
        }

        select:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.4);
            border-color: #10B981;
        }

        label {
            font-weight: 600;
            color: #111827;
        }

        /* 文字雲圓形容器與文字樣式 */
        #wordcloudContainer {
            position: relative;
        }

        .wordcloud-word {
            position: absolute;
            transform: translate(-50%, -50%);
            white-space: nowrap;
            line-height: 1;
            pointer-events: none;
        }


        /* === Aesthetic Upgrade: Data Driven Decision Making UI v1 === */
        :root {
            --bg-page: #F8F9FA;
            --bg-card: #FFFFFF;
            --text-main: #212529;
            --text-muted: #6C757D;
            --primary: #007BFF;
            --primary-soft: #E7F1FF;
            --accent: #FFC107;
            --border-soft: #DEE2E6;
            --shadow-soft: 0 10px 30px rgba(15, 23, 42, 0.08);
        }

        body {
            background-color: var(--bg-page);
            color: var(--text-main);
            font-family: -apple-system, BlinkMacSystemFont, "Noto Sans TC", "Microsoft JhengHei",
                "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "PingFang TC", "Heiti TC";
            line-height: 1.65;
        }

        /* 頂部 Hero 區域微調 */
        .bg-slate-50 {
            background: radial-gradient(circle at top left, #E7F1FF 0, #F8F9FA 40%, #FFFFFF 100%);
        }

        h1,
        h2,
        h3,
        h4 {
            letter-spacing: 0.02em;
        }

        h1 {
            font-weight: 800;
        }

        h2 {
            font-weight: 700;
        }

        h3,
        h4 {
            font-weight: 600;
        }

        /* 主內容寬度控制：避免超寬行長 */
        .container {
            max-width: 1100px;
        }

        /* 卡片樣式強化 */
        .card {
            background-color: var(--bg-card);
            box-shadow: var(--shadow-soft);
            border-radius: 1rem;
            border: 1px solid rgba(148, 163, 184, 0.18);
        }

        .card h2 {
            position: relative;
        }

        .card h2::after {
            content: "";
            position: absolute;
            left: 0;
            bottom: -0.4rem;
            width: 3rem;
            height: 3px;
            border-radius: 999px;
            background: linear-gradient(to right, var(--primary), var(--accent));
        }

        /* Tab 樣式微調：更清楚的分層與互動感 */
        .tab-button {
            font-size: 0.98rem;
            padding-left: 0.25rem;
            padding-right: 0.25rem;
            color: #64748B;
        }

        .tab-button.active {
            color: var(--primary);
        }

        .basic-tab-button,
        .forecast-tab-button,
        .ml-tab-button {
            font-size: 0.9rem;
            color: #6B7280;
        }

        .basic-tab-button.active,
        .forecast-tab-button.active,
        .ml-tab-button.active {
            color: var(--primary);
        }

        /* 上傳區按鈕與檔案選擇美化 */
        input[type="file"] {
            font-size: 0.875rem;
        }

        input[type="file"]::file-selector-button {
            background-color: var(--primary-soft);
            color: var(--primary);
            font-weight: 600;
        }

        input[type="file"]::file-selector-button:hover {
            background-color: #d7e6ff;
        }

        button {
            letter-spacing: 0.02em;
        }

        /* 表格：統一專業風格 + 斑馬紋 */
        table {
            border-collapse: collapse;
            width: 100%;
            font-size: 0.85rem;
        }

        th,
        td {
            padding: 0.45rem 0.75rem;
            border-bottom: 1px solid var(--border-soft);
        }

        th {
            background-color: #F1F3F5;
            font-weight: 600;
            color: #495057;
        }

        tbody tr:nth-child(odd) {
            background-color: #F8F9FA;
        }

        tbody tr:hover {
            background-color: #E9F5FF;
        }

        /* 重要資訊區塊 (決策提示 / 統計結論) */
        .callout {
            border-radius: 0.75rem;
            border: 1px solid rgba(13, 110, 253, 0.18);
            padding: 0.9rem 1rem;
            background: linear-gradient(135deg, #F8FBFF 0%, #FDFEFF 100%);
        }

        .callout-title {
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 0.25rem;
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }

        .callout-title::before {
            content: "◎";
            font-size: 0.8rem;
        }

        .callout-body {
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        /* 標籤與提示文字 */
        label {
            font-size: 0.88rem;
            font-weight: 600;
            color: #111827;
        }

        .helper-text,
        p.text-xs,
        p.text-gray-600 {
            color: var(--text-muted);
        }

        /* 選擇框：統一邊框與 Focus 效果 */
        select,
        input[type="number"],
        input[type="text"] {
            border-radius: 0.55rem;
        }

        select:focus,
        input[type="number"]:focus,
        input[type="text"]:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 1px rgba(0, 123, 255, 0.18);
        }

        /* Modal 調整：與主視覺更一致 */
        .modal-content {
            border-radius: 1.25rem;
            border: 1px solid rgba(37, 99, 235, 0.16);
        }

        .modal-header {
            color: #1F2937;
        }

        .modal-result {
            background: linear-gradient(135deg, #E7F1FF 0%, #F9FBFF 100%);
            border-left-color: var(--primary);
        }

        .modal-prob-value {
            color: #16A34A;
        }

        /* 自適應：小螢幕行高 & 間距 */
        @media (max-width: 768px) {
            body {
                font-size: 0.95rem;
                line-height: 1.7;
            }

            h1 {
                font-size: 1.6rem;
            }

            .card {
                padding: 1.25rem;
            }
        }


        /* 分析模組 Group Header */
        .analysis-group-header {
            background: linear-gradient(90deg, #E7F1FF 0%, #F8F9FA 55%, #FFFFFF 100%);
            border-radius: 0.9rem;
            padding: 0.75rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.85rem;
        }

        .analysis-group-header-title {
            font-size: 0.78rem;
            font-weight: 700;
            letter-spacing: 0.16em;
            text-transform: uppercase;
            color: #64748B;
        }

        .analysis-group-header-subtitle {
            font-size: 0.8rem;
            color: #6B7280;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
</head>

<body class="text-gray-800">

    <div class="bg-gradient-to-b from-slate-50 to-white border-b border-slate-200 mb-6">
        <div class="max-w-7xl mx-auto px-4 py-6 md:py-8">
            <div class="flex flex-col md:flex-row items-center md:items-start justify-between gap-6">

                <!-- Left: Title & Description -->
                <div class="text-center md:text-left flex-1">
                    <div class="flex items-center justify-center md:justify-start gap-3 mb-2">
                        <div class="bg-blue-600 text-white p-2 rounded-lg shadow-md hidden md:block">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z">
                                </path>
                            </svg>
                        </div>
                        <h1 class="text-2xl md:text-4xl font-extrabold text-slate-800 tracking-tight">
                            數據分析<span class="text-blue-600">與</span>機器學習平台
                        </h1>
                    </div>
                    <p class="text-sm md:text-base text-slate-600 max-w-2xl mx-auto md:mx-0 leading-relaxed">
                        上傳檔案或貼上資料，探索數據、驗證並建立預測模型
                    </p>
                </div>

                <!-- Right: Profile Card (Horizontal Layout) -->
                <div
                    class="flex items-center gap-4 bg-white p-3 pr-6 rounded-full shadow-sm border border-slate-100 flex-shrink-0">
                    <img src="Cliff Baby Pic by GPT.jpg" alt="Cliff Wang"
                        class="w-14 h-14 md:w-16 md:h-16 rounded-full shadow-md object-cover ring-2 ring-white" />
                    <div class="text-left">
                        <p class="text-sm md:text-base font-bold text-slate-800 leading-tight">Cliff Wang, Ph.D.</p>
                        <p class="text-xs text-slate-500 font-medium mb-0.5">AI+王啟岳博士</p>
                        <p class="text-[11px] text-blue-600 font-mono">dr.cliffwang@a2psdm.com</p>
                    </div>
                </div>

            </div>
        </div>
    </div>


    <div class="container mx-auto p-4 md:p-8">


        <details id="uploadSection" class="card" open>
            <summary class="flex items-center justify-between cursor-pointer select-none">
                <h2 class="text-xl font-semibold flex items-center gap-2">
                    <svg class="w-6 h-6 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12">
                        </path>
                    </svg>
                    上傳資料
                    <span id="uploadStatusBadge" class="hidden text-xs bg-green-100 text-green-700 px-2 py-0.5 rounded-full">✓ 已載入</span>
                </h2>
                <svg class="w-5 h-5 text-gray-400 transition-transform details-chevron" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                </svg>
            </summary>
            <div class="mt-4 flex items-center justify-between">
                <div></div>
                <button id="loadExampleBtn" type="button"
                    class="bg-blue-50 hover:bg-blue-100 text-blue-600 px-4 py-2 rounded-lg font-medium shadow-sm transition-all flex items-center gap-2 text-sm border border-blue-200">
                    <svg class="w-4 h-4 text-yellow-500" fill="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M13 10V3L4 14h7v7l9-11h-7z"></path>
                    </svg>
                    載入範例資料
                </button>
            </div>

            <!-- Input Mode Toggle -->
            <div class="mb-6">
                <div class="inline-flex bg-gray-100 p-1 rounded-lg">
                    <button id="inputModeFileBtn" type="button"
                        class="px-4 py-2 rounded-md text-sm font-medium transition-all shadow-sm bg-white text-blue-600">
                        Excel 上傳
                    </button>
                    <button id="inputModePasteBtn" type="button"
                        class="px-4 py-2 rounded-md text-sm font-medium text-gray-500 hover:text-gray-700 transition-all">
                        貼上/輸入數據
                    </button>
                </div>
                <p class="mt-2 text-sm text-gray-500">
                    支援 .xlsx, .xls, .csv 格式，或直接從 Excel 複製貼上。
                </p>
            </div>

            <!-- Excel File Upload Area -->
            <div id="excelInputArea" class="transition-all duration-300">
                <div
                    class="border-2 border-dashed border-blue-200 rounded-xl p-8 text-center hover:border-blue-400 transition-colors bg-blue-50/30 relative">
                    <input type="file" id="fileInput" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
                        aria-label="選擇檔案" />
                    <div class="pointer-events-none">
                        <div
                            class="w-12 h-12 bg-blue-100 text-blue-600 rounded-full flex items-center justify-center mx-auto mb-3">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M12 4v16m8-8H4"></path>
                            </svg>
                        </div>
                        <p class="text-lg font-medium text-gray-700 mb-1">點擊或拖放檔案至此</p>
                        <p id="chosenFileName" class="text-sm text-gray-500">尚未選擇檔案</p>
                    </div>
                </div>

                <!-- loadDataBtn hidden: auto-load on file select -->
                <div id="loadDataBtnContainer" class="mt-4 flex justify-end hidden">
                    <button id="loadDataBtn"
                        class="bg-blue-600 text-white px-6 py-2.5 rounded-lg font-medium shadow-md hover:bg-blue-700 disabled:bg-gray-300 disabled:cursor-not-allowed transition-all flex items-center gap-2"
                        disabled>
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path>
                        </svg>
                        載入資料
                    </button>
                </div>
            </div>

            <script>
                (function () {
                    const fileInput = document.getElementById('fileInput');
                    const chosen = document.getElementById('chosenFileName');
                    const loadBtn = document.getElementById('loadDataBtn');
                    const inputModeFileBtn = document.getElementById('inputModeFileBtn');
                    const inputModePasteBtn = document.getElementById('inputModePasteBtn');

                    function updateUI() {
                        if (!fileInput || !chosen || !loadBtn) return;
                        const files = fileInput.files;
                        if (files && files.length > 0) {
                            chosen.textContent = files.length === 1 ? files[0].name : `${files.length} 個檔案`;
                            chosen.classList.add('text-blue-600', 'font-medium');
                            loadBtn.disabled = false;
                        } else {
                            chosen.textContent = '尚未選擇檔案';
                            chosen.classList.remove('text-blue-600', 'font-medium');
                            loadBtn.disabled = true;
                        }
                    }

                    // Auto-load on file select (Option A UX improvement)
                    fileInput.addEventListener('change', function() {
                        updateUI();
                        // Auto-trigger file upload if a file is selected
                        if (fileInput.files && fileInput.files.length > 0) {
                            // Use setTimeout to allow UI to update first
                            setTimeout(() => {
                                if (typeof handleFileUpload === 'function') {
                                    handleFileUpload();
                                }
                            }, 100);
                        }
                    });

                    // Toggle Button Logic (Visual only, functional logic handled by main script)
                    inputModeFileBtn.addEventListener('click', () => {
                        inputModeFileBtn.classList.add('bg-white', 'text-blue-600', 'shadow-sm');
                        inputModeFileBtn.classList.remove('text-gray-500');
                        inputModePasteBtn.classList.remove('bg-white', 'text-blue-600', 'shadow-sm');
                        inputModePasteBtn.classList.add('text-gray-500');
                    });

                    inputModePasteBtn.addEventListener('click', () => {
                        inputModePasteBtn.classList.add('bg-white', 'text-blue-600', 'shadow-sm');
                        inputModePasteBtn.classList.remove('text-gray-500');
                        inputModeFileBtn.classList.remove('bg-white', 'text-blue-600', 'shadow-sm');
                        inputModeFileBtn.classList.add('text-gray-500');
                    });
                })();
            </script>

            <!-- Copy & Paste Input Area -->
            <div id="pasteInputArea" class="mt-4 hidden">
                <div class="bg-gray-50 p-4 rounded-xl border border-gray-200">
                    <label for="pasteTextarea" class="block text-sm font-medium text-gray-700 mb-2">
                        從 Excel 貼上資料（第一列需為欄位名稱）
                    </label>
                    <textarea id="pasteTextarea" rows="8"
                        class="w-full rounded-lg border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 text-sm font-mono"
                        placeholder="範例：&#10;日期	銷售量&#10;2024-01-01	120&#10;2024-01-02	98"></textarea>

                    <div class="mt-4 flex flex-col sm:flex-row justify-between items-center gap-4">
                        <div
                            class="flex items-center gap-4 text-sm text-gray-600 bg-white px-3 py-2 rounded-lg border border-gray-200">
                            <span class="font-medium">分隔符號：</span>
                            <label class="inline-flex items-center gap-1 cursor-pointer">
                                <input type="radio" name="pasteDelimiter" value="auto"
                                    class="text-blue-600 focus:ring-blue-500" checked>
                                <span>自動</span>
                            </label>
                            <label class="inline-flex items-center gap-1 cursor-pointer">
                                <input type="radio" name="pasteDelimiter" value="tab"
                                    class="text-blue-600 focus:ring-blue-500">
                                <span>Tab</span>
                            </label>
                            <label class="inline-flex items-center gap-1 cursor-pointer">
                                <input type="radio" name="pasteDelimiter" value="comma"
                                    class="text-blue-600 focus:ring-blue-500">
                                <span>逗號</span>
                            </label>
                        </div>
                        <button id="pasteLoadBtn" type="button"
                            class="bg-emerald-600 text-white px-6 py-2.5 rounded-lg font-medium shadow-md hover:bg-emerald-700 transition-all flex items-center gap-2 w-full sm:w-auto justify-center">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01">
                                </path>
                            </svg>
                            匯入貼上資料
                        </button>
                    </div>
                </div>
            </div>

            <!-- Worksheet Selector -->
            <div id="sheetSelectorContainer" class="mt-6 hidden animate-fade-in">
                <div
                    class="bg-blue-50 border border-blue-100 rounded-xl p-4 flex flex-col md:flex-row items-center gap-4">
                    <div class="flex-1 w-full">
                        <label for="sheetSelector" class="block text-sm font-medium text-blue-800 mb-1">
                            選擇工作表 (Worksheet)
                        </label>
                        <select id="sheetSelector"
                            class="w-full border-blue-200 rounded-lg shadow-sm focus:border-blue-500 focus:ring-blue-500 bg-white py-2"></select>
                    </div>
                    <button id="confirmSheetBtn"
                        class="bg-blue-600 text-white px-6 py-2.5 rounded-lg font-medium shadow hover:bg-blue-700 transition-all whitespace-nowrap mt-auto w-full md:w-auto">
                        確認匯入
                    </button>
                </div>
            </div>

            <div id="loadingIndicator" class="hidden loader"></div>
        </details>



        <main id="mainContent" class="hidden">
            <details id="previewSection" class="card" open>
                <summary class="flex items-center justify-between cursor-pointer select-none">
                    <h2 class="text-xl font-semibold flex items-center gap-2">
                        <svg class="w-6 h-6 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M9 17v-2m3 2v-4m3 4v-6m2 10H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z">
                            </path>
                        </svg>
                        資料預覽
                        <span id="previewRowCount" class="text-sm font-normal text-gray-500"></span>
                    </h2>
                    <svg class="w-5 h-5 text-gray-400 transition-transform details-chevron" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                    </svg>
                </summary>
                <div id="dataPreview" class="overflow-x-auto max-h-64 mt-4"></div>
            </details>

            <div class="card">
                <h2 class="text-xl font-semibold mb-4 flex items-center gap-2">
                    <svg class="w-6 h-6 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4">
                        </path>
                    </svg>
                    選擇分析方法
                </h2>
                <div class="border-b border-gray-200">
                    <nav class="-mb-px flex flex-wrap gap-4" aria-label="Tabs">
                        <button class="tab-button active font-bold text-xl flex items-center gap-3 px-8 py-4 rounded-t-lg"
                            data-tab="eda">
                            <svg class="w-7 h-7" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                            </svg>
                            資料探索
                        </button>
                        <button class="tab-button font-bold text-xl flex items-center gap-3 px-8 py-4 rounded-t-lg"
                            data-tab="basic">
                            <svg class="w-7 h-7" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z">
                                </path>
                            </svg>
                            基本分析
                        </button>
                        <button class="tab-button font-bold text-xl flex items-center gap-3 px-8 py-4 rounded-t-lg"
                            data-tab="forecast">
                            <svg class="w-7 h-7" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                            時間序列
                        </button>
                        <button class="tab-button font-bold text-xl flex items-center gap-3 px-8 py-4 rounded-t-lg"
                            data-tab="ml">
                            <svg class="w-7 h-7" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M19.428 15.428a2 2 0 00-1.022-.547l-2.384-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z">
                                </path>
                            </svg>
                            機器學習
                        </button>
                    </nav>
                </div>

                <div id="analysisContent" class="mt-6">
                    <!-- EDA -->
                    <div id="edaContent" class="tab-content">
                        <div id="edaResults"></div>
                    </div>
                    <!-- Basic Analysis (Grouped) -->
                    <div id="basicContent" class="tab-content hidden">
                        <div class="border-b border-gray-200 mb-4">
                            <nav class="flex flex-wrap gap-2" aria-label="BasicTabs">
                                <button class="basic-tab-button active font-medium" data-basic-tab="outlier">異常偵測</button>
                                <button class="basic-tab-button font-medium" data-basic-tab="pareto">柏拉圖</button>
                                <button class="basic-tab-button font-medium" data-basic-tab="fishbone">魚骨圖</button>
                                <button class="basic-tab-button font-medium" data-basic-tab="correlationMatrix">散佈圖</button>
                                <button class="basic-tab-button font-medium" data-basic-tab="controlChart">管制圖</button>
                                <button class="basic-tab-button font-medium" data-basic-tab="processCapability">製程能力</button>
                                <button class="basic-tab-button font-medium" data-basic-tab="testing">假設檢定</button>
                                <button class="basic-tab-button font-medium" data-basic-tab="chiSquare">卡方檢定</button>
                                <button class="basic-tab-button font-medium" data-basic-tab="regression">迴歸分析</button>
                                <button class="basic-tab-button font-medium" data-basic-tab="linearProgramming">線性規劃</button>
                                <button class="basic-tab-button font-medium" data-basic-tab="wordcloud">文字雲</button>
                                <button class="basic-tab-button font-medium" data-basic-tab="bubbleChart">多維度圖</button>
                            </nav>
                        </div>

                        <div id="outlierContent" class="basic-tab-content mt-4">
                            <p class="text-gray-600 mb-4">異常偵測 (Outlier Detection)：用來找出資料中的離群值，常用於品質監控、異常交易偵測與資料清洗。</p>
                            <div class="space-y-4">
                                <div>
                                    <label for="outlierVariable"
                                        class="block text-sm font-medium text-gray-700">選擇要檢測的數值變數</label>
                                    <select id="outlierVariable"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                </div>
                                <div class="bg-gray-50 p-4 rounded-lg">
                                    <h4 class="font-semibold mb-3">選擇偵測方法</h4>
                                    <div class="space-y-2">
                                        <label class="flex items-center">
                                            <input type="checkbox" id="outlierIQR" checked
                                                class="rounded border-gray-300 text-red-600 mr-2">
                                            <span class="text-sm">
                                                <strong>IQR 法 (四分位數法)</strong> - 適用於任何分布，最常用
                                                <span class="text-xs text-gray-500 block ml-6">偵測範圍: Q1 - 1.5×IQR ~ Q3 +
                                                    1.5×IQR</span>
                                            </span>
                                        </label>
                                        <label class="flex items-center">
                                            <input type="checkbox" id="outlierZScore" checked
                                                class="rounded border-gray-300 text-blue-600 mr-2">
                                            <span class="text-sm">
                                                <strong>Z-Score 法 (標準分數法)</strong> - 適用於常態分布
                                                <span class="text-xs text-gray-500 block ml-6">偵測範圍: |Z-Score| > 3 (或
                                                    2.5)</span>
                                            </span>
                                        </label>
                                        <label class="flex items-center">
                                            <input type="checkbox" id="outlierModifiedZ" checked
                                                class="rounded border-gray-300 text-green-600 mr-2">
                                            <span class="text-sm">
                                                <strong>Modified Z-Score 法</strong> - 使用中位數，更穩健
                                                <span class="text-xs text-gray-500 block ml-6">偵測範圍: |Modified Z| >
                                                    3.5</span>
                                            </span>
                                        </label>
                                    </div>
                                </div>

                                <div class="grid md:grid-cols-2 gap-4">
                                    <div>
                                        <label for="outlierZThreshold"
                                            class="block text-sm font-medium text-gray-700">Z-Score 閾值</label>
                                        <input type="number" id="outlierZThreshold" value="3" step="0.5" min="1" max="5"
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                        <p class="text-xs text-gray-500 mt-1">預設 3 (嚴格), 2.5 (寬鬆)</p>
                                    </div>
                                    <div>
                                        <label for="outlierIQRMultiplier"
                                            class="block text-sm font-medium text-gray-700">IQR 倍數</label>
                                        <input type="number" id="outlierIQRMultiplier" value="1.5" step="0.5" min="1"
                                            max="3" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                        <p class="text-xs text-gray-500 mt-1">預設 1.5 (標準), 3 (極端)</p>
                                    </div>
                                </div>
                                <button id="runOutlierBtn"
                                    class="bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700">執行異常偵測</button>
                            </div>
                            <div id="outlierResults" class="mt-6"></div>
                        </div>
                        <div id="paretoContent" class="basic-tab-content hidden">
                            <p class="text-gray-600 mb-4">找出造成問題的關鍵點 (80/20法則)。</p>
                            <div class="grid md:grid-cols-3 gap-4 items-end">
                                <div><label for="paretoCategoryVar"
                                        class="block text-sm font-medium text-gray-700">選擇類別欄位 (X)</label><select
                                        id="paretoCategoryVar"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select></div>
                                <div><label for="paretoValueVar" class="block text-sm font-medium text-gray-700">選擇數值欄位
                                        (Y)</label><select id="paretoValueVar"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select></div>
                                <button id="runParetoBtn"
                                    class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700">產生柏拉圖</button>
                            </div>
                            <div id="paretoResults" class="mt-6"></div>
                        </div>

                        <!-- 魚骨圖 Fishbone/Ishikawa Diagram -->
                        <div id="fishboneContent" class="basic-tab-content hidden">
                            <p class="text-gray-600 mb-4">
                                魚骨圖 (Fishbone/Ishikawa Diagram)：用於分析問題的根本原因，將導致問題的因素分類呈現，常用於品質管理與問題解決。
                            </p>
                            <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4">
                                <p class="text-blue-800">
                                    <strong>📋 資料格式要求：</strong><br>
                                    請上傳包含 <code class="bg-blue-100 px-1 rounded">PARENT</code> 和 <code class="bg-blue-100 px-1 rounded">CHILD</code> 欄位的資料。<br>
                                    • <strong>PARENT</strong>：主要原因類別 (如：人員、機台、物料、方法、環境)<br>
                                    • <strong>CHILD</strong>：各類別下的細項原因
                                </p>
                            </div>
                            <div class="space-y-4">
                                <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                                    <div>
                                        <label for="fishboneParentVar" class="block text-sm font-medium text-gray-700">選擇主因欄位 (PARENT)</label>
                                        <select id="fishboneParentVar" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                    </div>
                                    <div>
                                        <label for="fishboneChildVar" class="block text-sm font-medium text-gray-700">選擇細因欄位 (CHILD)</label>
                                        <select id="fishboneChildVar" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                    </div>
                                    <div>
                                        <label for="fishboneProblem" class="block text-sm font-medium text-gray-700">問題描述 (魚頭)</label>
                                        <input type="text" id="fishboneProblem" value="品質問題" placeholder="例：不良率過高" 
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                    </div>
                                </div>
                                <div>
                                    <button id="runFishboneBtn" class="bg-teal-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-teal-700">
                                        🐟 產生魚骨圖
                                    </button>
                                </div>
                            </div>
                            <div id="fishboneResults" class="mt-6"></div>
                        </div>

                        <div id="testingContent" class="basic-tab-content hidden">
                            <p class="text-gray-600 mb-4">比較不同組別或樣本之間，數值資料的平均值是否存在顯著差異。</p>
                            
                            <!-- Test Type Selection -->
                            <div class="mb-4 bg-gray-50 p-3 rounded-lg">
                                <label class="block text-sm font-bold text-gray-700 mb-2">檢定類型 (Test Type)</label>
                                <div class="flex flex-wrap gap-4">
                                    <label class="inline-flex items-center cursor-pointer">
                                        <input type="radio" name="tTestType" value="independent_group" checked class="form-radio text-green-600 focus:ring-green-500">
                                        <span class="ml-2 text-sm text-gray-700">獨立樣本 (分組變數 Group)</span>
                                    </label>
                                    <label class="inline-flex items-center cursor-pointer">
                                        <input type="radio" name="tTestType" value="independent_columns" class="form-radio text-green-600 focus:ring-green-500">
                                        <span class="ml-2 text-sm text-gray-700">獨立樣本 (兩欄位 Two Columns)</span>
                                    </label>
                                    <label class="inline-flex items-center cursor-pointer">
                                        <input type="radio" name="tTestType" value="paired" class="form-radio text-green-600 focus:ring-green-500">
                                        <span class="ml-2 text-sm text-gray-700">成對樣本 (Paired T-Test)</span>
                                    </label>
                                    <label class="inline-flex items-center cursor-pointer">
                                        <input type="radio" name="tTestType" value="f_test_group" class="form-radio text-green-600 focus:ring-green-500">
                                        <span class="ml-2 text-sm text-gray-700">F 檢定 (獨立樣本 - 分組 Group)</span>
                                    </label>
                                </div>
                            </div>

                            <div class="grid md:grid-cols-3 gap-4 items-end">
                                <!-- Grouped Inputs -->
                                <div id="tTestInputGroup1">
                                    <label for="tTestCategoricalVar" class="block text-sm font-medium text-gray-700">選擇分組變數 (X)</label>
                                    <select id="tTestCategoricalVar" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm transition-colors focus:border-green-500 focus:ring-green-500"></select>
                                </div>
                                <div id="tTestInputGroup2">
                                    <label for="tTestNumericalVar" class="block text-sm font-medium text-gray-700">選擇數值變數 (Y)</label>
                                    <select id="tTestNumericalVar" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm transition-colors focus:border-green-500 focus:ring-green-500"></select>
                                </div>

                                <!-- Two Columns/Paired Inputs (Initially Hidden) -->
                                <div id="tTestInputCol1" class="hidden">
                                    <label for="tTestVar1" class="block text-sm font-medium text-gray-700">選擇變數 1 (Sample A)</label>
                                    <select id="tTestVar1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm transition-colors focus:border-green-500 focus:ring-green-500"></select>
                                </div>
                                <div id="tTestInputCol2" class="hidden">
                                    <label for="tTestVar2" class="block text-sm font-medium text-gray-700">選擇變數 2 (Sample B)</label>
                                    <select id="tTestVar2" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm transition-colors focus:border-green-500 focus:ring-green-500"></select>
                                </div>

                                <button id="runTTestBtn"
                                    class="bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 transition duration-300 shadow-md transform hover:-translate-y-0.5">
                                    執行檢定
                                </button>
                            </div>
                            <div id="tTestResults" class="mt-6"></div>
                        </div>
                        <div id="chiSquareContent" class="basic-tab-content hidden mt-4">
                            <p class="text-gray-600 mb-4">卡方檢定(Chi-Square Test)：檢定兩個類別變數之間是否存在顯著關聯性。適用於問卷調查、市場研究等情境。</p>
                            <div class="bg-green-50 p-4 rounded-lg mb-4">
                                <h4 class="font-semibold text-green-900 mb-2">📊 使用情境</h4>
                                <ul class="text-sm text-green-800 space-y-1">
                                    <li>• 性別與產品偏好是否相關？</li>
                                    <li>• 教育程度與職業類型是否獨立？</li>
                                    <li>• 地區與購買行為是否有關聯？</li>
                                </ul>
                            </div>
                            <div class="grid md:grid-cols-2 gap-x-8 gap-y-4">
                                <div>
                                    <label for="chiSquareVar1"
                                        class="block text-sm font-medium text-gray-700">選擇第一個類別變數</label>
                                    <select id="chiSquareVar1"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                </div>
                                <div>
                                    <label for="chiSquareVar2"
                                        class="block text-sm font-medium text-gray-700">選擇第二個類別變數</label>
                                    <select id="chiSquareVar2"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                </div>
                            </div>
                            <div class="mt-4">
                                <button id="runChiSquareBtn"
                                    class="bg-orange-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-orange-700">執行卡方檢定</button>
                            </div>
                            <div id="chiSquareResults" class="mt-6"></div>
                        </div>
                        <div id="regressionContent" class="basic-tab-content hidden">
                            <!-- Regression Type Tabs -->
                            <div class="flex space-x-2 mb-4 border-b border-gray-300">
                                <button id="simpleRegTab" onclick="switchRegressionType('simple')"
                                    class="px-4 py-2 font-semibold border-b-2 border-purple-500 text-purple-600">簡單迴歸
                                    Simple</button>
                                <button id="multipleRegTab" onclick="switchRegressionType('multiple')"
                                    class="px-4 py-2 font-semibold text-gray-500 hover:text-purple-600">多元迴歸
                                    Multiple</button>
                            </div>

                            <!-- Simple Regression -->
                            <div id="simpleRegressionPanel">
                                <p class="text-gray-600 mb-4">探討兩個數值變數之間的關聯性，包含完整統計推論。</p>
                                <div class="grid md:grid-cols-3 gap-4 items-end">
                                    <div><label for="regressionX" class="block text-sm font-medium text-gray-700">選擇自變數
                                            (X)</label><select id="regressionX"
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                    </div>
                                    <div><label for="regressionY" class="block text-sm font-medium text-gray-700">選擇應變數
                                            (Y)</label><select id="regressionY"
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                    </div>
                                    <button id="runRegressionBtn"
                                        class="bg-purple-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-purple-700">執行簡單迴歸</button>
                                </div>
                            </div>

                            <!-- Multiple Regression -->
                            <div id="multipleRegressionPanel" style="display:none;">
                                <p class="text-gray-600 mb-4">探討多個自變數對應變數的影響，適合實務應用。</p>
                                <div class="grid md:grid-cols-3 gap-4 items-end">
                                    <div><label for="multipleRegressionX"
                                            class="block text-sm font-medium text-gray-700">選擇自變數 (X) -
                                            可多選</label><select id="multipleRegressionX" multiple
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
                                            style="height:120px;"></select>
                                        <p class="text-xs text-gray-500 mt-1">💡 按住 Ctrl (Win) 或 Cmd (Mac) 選擇多個</p>
                                    </div>
                                    <div><label for="multipleRegressionY"
                                            class="block text-sm font-medium text-gray-700">選擇應變數 (Y)</label><select
                                            id="multipleRegressionY"
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                    </div>
                                    <button id="runMultipleRegressionBtn"
                                        class="bg-purple-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-purple-700">執行多元迴歸</button>
                                </div>

                            </div>

                            <div id="regressionResults" class="mt-6"></div>
                        </div>
                        <div id="correlationMatrixContent" class="basic-tab-content hidden mt-4">
                            <p class="text-gray-600 mb-4">視覺化所有數值變數之間的相關性，快速找出高度正相關或負相關的變數配對。</p>
                            
                            <div class="bg-gray-50 p-4 rounded-lg mb-4">
                                <h4 class="font-semibold text-gray-800 mb-2">📊 相關係數 |r| 強度參考</h4>
                                <div class="grid grid-cols-2 md:grid-cols-4 gap-2 text-sm">
                                    <div class="flex items-center gap-2">
                                        <span class="w-4 h-4 rounded" style="background: #b2182b;"></span>
                                        <span><strong>|r| ≥ 0.7</strong>：強相關</span>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <span class="w-4 h-4 rounded" style="background: #ef8a62;"></span>
                                        <span><strong>0.4 ≤ |r| < 0.7</strong>：中等相關</span>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <span class="w-4 h-4 rounded" style="background: #fddbc7;"></span>
                                        <span><strong>0.2 ≤ |r| < 0.4</strong>：弱相關</span>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <span class="w-4 h-4 rounded" style="background: #f7f7f7; border: 1px solid #ddd;"></span>
                                        <span><strong>|r| < 0.2</strong>：可忽略</span>
                                    </div>
                                </div>
                            </div>

                            <div class="mb-4">
                                <label for="correlationVarSelect" class="block text-sm font-medium text-gray-700 mb-1">選擇數值變數（可多選，留空則使用全部）</label>
                                <select id="correlationVarSelect" multiple class="mt-1 block w-full rounded-md border-gray-300 shadow-sm" style="height: 100px;"></select>
                                <p class="text-xs text-gray-500 mt-1">💡 按住 Ctrl (Win) 或 Cmd (Mac) 選擇多個變數</p>
                            </div>

                            <div class="mt-4 flex gap-3">
                                <button id="runCorrelationMatrixBtn"
                                    class="bg-teal-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-teal-700">產生相關係數熱圖</button>
                                <button id="runScatterPlotBtn"
                                    class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700">產生散佈圖</button>
                            </div>
                            <div id="correlationMatrixResults" class="mt-6"></div>
                            <div id="scatterPlotResults" class="mt-6"></div>
                        </div>

                        <div id="wordcloudContent" class="basic-tab-content hidden mt-4">
                            <p class="text-gray-600 mb-4">
                                文字雲 (Wordcloud)：用於快速觀察文字欄位中常出現的關鍵字與主題。
                            </p>
                            <div class="space-y-4">
                                <div>
                                    <label for="wordcloudTextColumn" class="block text-sm font-medium text-gray-700">
                                        選擇文字欄位
                                    </label>
                                    <select id="wordcloudTextColumn"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                    <p class="text-xs text-gray-500 mt-1">
                                        建議選擇備註、客服紀錄、意見欄位等文字型欄位。
                                    </p>
                                </div>

                                <div class="flex flex-wrap items-center gap-4">
                                    <div>
                                        <label for="wordcloudMinFreq" class="block text-sm font-medium text-gray-700">
                                            最小出現次數
                                        </label>
                                        <input type="number" id="wordcloudMinFreq"
                                            class="mt-1 w-28 rounded-md border-gray-300 shadow-sm" value="3" min="1">
                                    </div>
                                    <div>
                                        <label for="wordcloudMaxWords" class="block text-sm font-medium text-gray-700">
                                            最多顯示字詞數
                                        </label>
                                        <input type="number" id="wordcloudMaxWords"
                                            class="mt-1 w-28 rounded-md border-gray-300 shadow-sm" value="60" min="10">
                                    </div>
                                </div>

                                <div>
                                    <button id="runWordcloudBtn"
                                        class="bg-emerald-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-emerald-700">
                                        產生文字雲
                                    </button>
                                </div>

                                <div class="flex justify-between items-center mb-4">
                                    <h3 class="text-lg font-semibold">文字雲結果</h3>
                                    <button id="downloadWordcloudBtn"
                                        class="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 disabled:opacity-50"
                                        disabled>
                                        下載文字雲 (PNG)
                                    </button>
                                </div>
                                <div id="wordcloudContainer"
                                    class="border rounded-full mx-auto bg-white overflow-hidden min-h-[260px] max-w-xl aspect-square">
                                </div>
                                <div id="wordcloudList" class="mt-8 hidden"></div>
                            </div>
                        </div>

                        <!-- 管制圖 Control Chart: X-bar & R Chart -->
                        <div id="controlChartContent" class="basic-tab-content hidden mt-4">
                            <p class="text-gray-600 mb-4">
                                管制圖 (Control Chart)：X̄ & R Chart 用於監控製程變異，識別特殊原因變異，確保製程處於統計管制狀態。
                            </p>
                            <div class="space-y-4">
                                <!-- 變數選擇 -->
                                <div>
                                    <label for="ccVariable" class="block text-sm font-medium text-gray-700">選擇數值變數（量測值）</label>
                                    <select id="ccVariable"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                </div>

                                <!-- 子群組設定 -->
                                <div class="bg-gray-50 p-4 rounded-lg">
                                    <h4 class="font-semibold mb-3">子群組設定 (Subgroup Settings)</h4>
                                    <div>
                                        <label for="ccSubgroupSize" class="block text-sm font-medium text-gray-700">子群組大小 (n)</label>
                                        <input type="number" id="ccSubgroupSize" min="1" max="10" value="5"
                                            class="mt-1 block w-full md:w-1/2 rounded-md border-gray-300 shadow-sm">
                                        <p class="text-xs text-gray-500 mt-1">n=1：I-MR Chart (個別值-移動全距圖)；n≥2：X̄-R Chart (平均值-全距圖)</p>
                                    </div>
                                </div>

                                <!-- 管制限設定 -->
                                <div class="bg-gray-50 p-4 rounded-lg">
                                    <h4 class="font-semibold mb-3">管制限設定 (Control Limits)</h4>
                                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                        <div>
                                            <label for="ccSigmaLevel" class="block text-sm font-medium text-gray-700">Sigma Level (σ)</label>
                                            <select id="ccSigmaLevel"
                                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                                <option value="3">3σ (標準, 99.73%)</option>
                                                <option value="2">2σ (95.45%)</option>
                                            </select>
                                        </div>
                                        <div class="flex items-center mt-6">
                                            <input type="checkbox" id="ccShowWarningLimits" class="mr-2">
                                            <label for="ccShowWarningLimits" class="text-sm text-gray-700">顯示警告限 (±2σ)</label>
                                        </div>
                                    </div>
                                </div>

                                <!-- 執行按鈕 -->
                                <div class="flex items-center gap-3 flex-wrap">
                                    <button id="runControlChartBtn"
                                        class="bg-emerald-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-emerald-700">
                                        計算管制圖
                                    </button>
                                    <button id="toggleSpecLinesBtn" class="bg-gray-200 text-gray-700 font-medium py-2 px-4 rounded-lg hover:bg-gray-300 hidden">
                                        📏 n=1 可加入規格線
                                    </button>
                                </div>
                                
                                <!-- 規格線設定 (hidden by default, shown when n=1) -->
                                <div id="specLinesPanel" class="hidden mt-4 p-4 bg-blue-50 border border-blue-200 rounded-lg">
                                    <h4 class="font-semibold text-blue-800 mb-3">📏 規格線設定 (可選填)</h4>
                                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                                        <div>
                                            <label for="ccSpecUSL" class="block text-sm font-medium text-gray-700 mb-1">USL 規格上限</label>
                                            <input type="number" id="ccSpecUSL" name="ccSpecUSL" step="any" 
                                                class="w-full rounded-md border border-gray-300 shadow-sm px-3 py-2 focus:border-blue-500 focus:ring-1 focus:ring-blue-500" 
                                                placeholder="例：50">
                                        </div>
                                        <div>
                                            <label for="ccSpecTarget" class="block text-sm font-medium text-gray-700 mb-1">Target 目標值</label>
                                            <input type="number" id="ccSpecTarget" name="ccSpecTarget" step="any" 
                                                class="w-full rounded-md border border-gray-300 shadow-sm px-3 py-2 focus:border-blue-500 focus:ring-1 focus:ring-blue-500" 
                                                placeholder="例：40">
                                        </div>
                                        <div>
                                            <label for="ccSpecLSL" class="block text-sm font-medium text-gray-700 mb-1">LSL 規格下限</label>
                                            <input type="number" id="ccSpecLSL" name="ccSpecLSL" step="any" 
                                                class="w-full rounded-md border border-gray-300 shadow-sm px-3 py-2 focus:border-blue-500 focus:ring-1 focus:ring-blue-500" 
                                                placeholder="例：30">
                                        </div>
                                    </div>
                                    <p class="text-xs text-gray-500 mt-2">💡 留空的欄位則不繪製該規格線。規格線只會顯示在 I Chart 上。</p>
                                </div>

                                <!-- 結果區域 -->
                                <div id="controlChartResults" class="mt-6 hidden">
                                    <h3 class="text-lg font-semibold mb-4">管制圖分析結果</h3>

                                    <!-- 管制狀態摘要 -->
                                    <div id="ccStatusSummary" class="mb-6"></div>

                                    <!-- X-bar 圖 -->
                                    <div id="ccXbarChart" class="bg-white border rounded-lg p-4 mb-6" style="min-height: 350px;"></div>

                                    <!-- R 圖 -->
                                    <div id="ccRChart" class="bg-white border rounded-lg p-4 mb-6" style="min-height: 350px;"></div>

                                    <!-- 管制限表格 -->
                                    <div id="ccControlLimitsTable" class="bg-white border rounded-lg p-4 mb-6"></div>

                                    <!-- 異常點詳細資訊 -->
                                    <div id="ccOutOfControlDetails" class="bg-yellow-50 border border-yellow-200 rounded-lg p-4 hidden"></div>
                                </div>
                            </div>
                        </div>

                        <div id="processCapabilityContent" class="basic-tab-content hidden mt-4">
                            <p class="text-gray-600 mb-4">
                                製程能力分析 (Process Capability)：計算 Cp、Cpk、Pp、Ppk 等指標，評估製程控制能力與一致性。
                            </p>
                            <div class="space-y-4">
                                <!-- 變數選擇 -->
                                <div>
                                    <label for="pcVariable" class="block text-sm font-medium text-gray-700">選擇數值變數（量測值）</label>
                                    <select id="pcVariable"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                </div>

                                <!-- 規格參數 -->
                                <div class="bg-gray-50 p-4 rounded-lg">
                                    <h4 class="font-semibold mb-3">規格限制 (Specification Limits)</h4>
                                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                                        <div>
                                            <label for="pcUSL" class="block text-sm font-medium text-gray-700">USL (規格上限)</label>
                                            <input type="number" id="pcUSL" step="any"
                                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm" placeholder="例: 10.5">
                                        </div>
                                        <div>
                                            <label for="pcTarget" class="block text-sm font-medium text-gray-700">Target (目標值，選填)</label>
                                            <input type="number" id="pcTarget" step="any"
                                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm" placeholder="例: 10.0">
                                        </div>
                                        <div>
                                            <label for="pcLSL" class="block text-sm font-medium text-gray-700">LSL (規格下限)</label>
                                            <input type="number" id="pcLSL" step="any"
                                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm" placeholder="例: 9.5">
                                        </div>
                                    </div>
                                    <p class="text-xs text-gray-500 mt-2">💡 若僅提供單邊規格，另一側留空即可。</p>
                                </div>

                                <!-- 進階設定 -->
                                <div class="bg-gray-50 p-4 rounded-lg">
                                    <h4 class="font-semibold mb-3">進階設定</h4>
                                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                        <div>
                                            <label for="pcSubgroupSize" class="block text-sm font-medium text-gray-700">子群組大小 (Subgroup Size)</label>
                                            <input type="number" id="pcSubgroupSize" min="1" value="1"
                                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                            <p class="text-xs text-gray-500 mt-1">用於短期變異估計 (Cp/Cpk)；設為 1 時使用合併標準差</p>
                                        </div>
                                        <div>
                                            <label for="pcSigmaMethod" class="block text-sm font-medium text-gray-700">短期 σ 估計方法</label>
                                            <select id="pcSigmaMethod"
                                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                                <option value="pooled">合併標準差 (Pooled StdDev)</option>
                                                <option value="rbar">R-bar / d2 法</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>

                                <!-- 執行按鈕 -->
                                <div>
                                    <button id="runProcessCapabilityBtn"
                                        class="bg-emerald-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-emerald-700">
                                        計算製程能力
                                    </button>
                                </div>

                                <!-- 結果區域 -->
                                <div id="processCapabilityResults" class="mt-6 hidden">
                                    <h3 class="text-lg font-semibold mb-4">製程能力分析結果</h3>

                                    <!-- 指標摘要卡片 -->
                                    <div id="pcMetricsCards" class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6"></div>

                                    <!-- 統計摘要 -->
                                    <div id="pcStatsSummary" class="bg-white border rounded-lg p-4 mb-6"></div>

                                    <!-- 直方圖與規格線圖表 -->
                                    <div id="pcHistogramChart" class="bg-white border rounded-lg p-4 mb-6" style="min-height: 400px;"></div>

                                    <!-- 詳細解讀 -->
                                    <div id="pcInterpretation" class="bg-blue-50 border border-blue-200 rounded-lg p-4"></div>
                                </div>
                            </div>
                        </div>

                        <!-- 線性規劃 Linear Programming -->
                        <div id="linearProgrammingContent" class="basic-tab-content hidden mt-4">
                            <p class="text-gray-600 mb-4">
                                線性規劃 (Linear Programming)：在有限資源與約束條件下，找出最佳化（最大利潤或最小成本）的決策方案。
                            </p>
                            <div class="space-y-4">
                                <!-- 問題類型 -->
                                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    <div>
                                        <label class="block text-sm font-medium text-gray-700 mb-2">最佳化目標</label>
                                        <div class="flex gap-4">
                                            <label class="inline-flex items-center">
                                                <input type="radio" name="lpObjective" value="maximize" checked class="form-radio text-green-600">
                                                <span class="ml-2">📈 最大化 (Maximize)</span>
                                            </label>
                                            <label class="inline-flex items-center">
                                                <input type="radio" name="lpObjective" value="minimize" class="form-radio text-green-600">
                                                <span class="ml-2">📉 最小化 (Minimize)</span>
                                            </label>
                                        </div>
                                    </div>
                                    <div>
                                        <label for="lpNumVariables" class="block text-sm font-medium text-gray-700">決策變數數量</label>
                                        <select id="lpNumVariables" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                            <option value="2" selected>2 個變數</option>
                                            <option value="3">3 個變數</option>
                                            <option value="4">4 個變數</option>
                                            <option value="5">5 個變數</option>
                                        </select>
                                    </div>
                                </div>

                                <!-- 決策變數名稱 -->
                                <div class="bg-gray-50 p-4 rounded-lg">
                                    <h4 class="font-semibold mb-3">📦 決策變數</h4>
                                    <div id="lpVariableNames" class="grid grid-cols-2 md:grid-cols-4 gap-3">
                                        <div>
                                            <label class="block text-xs text-gray-600">變數 x₁ 名稱</label>
                                            <input type="text" id="lpVar1Name" value="產品A" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm text-sm">
                                        </div>
                                        <div>
                                            <label class="block text-xs text-gray-600">變數 x₂ 名稱</label>
                                            <input type="text" id="lpVar2Name" value="產品B" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm text-sm">
                                        </div>
                                    </div>
                                </div>

                                <!-- 目標函數 -->
                                <div class="bg-blue-50 p-4 rounded-lg">
                                    <h4 class="font-semibold mb-3">🎯 目標函數係數 (每單位貢獻值/成本)</h4>
                                    <div id="lpObjectiveCoefficients" class="grid grid-cols-2 md:grid-cols-4 gap-3">
                                        <div>
                                            <label class="block text-xs text-gray-600">x₁ 係數 (c₁)</label>
                                            <input type="number" id="lpCoef1" value="40" step="any" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm text-sm">
                                        </div>
                                        <div>
                                            <label class="block text-xs text-gray-600">x₂ 係數 (c₂)</label>
                                            <input type="number" id="lpCoef2" value="30" step="any" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm text-sm">
                                        </div>
                                    </div>
                                    <p class="text-xs text-gray-500 mt-2">目標函數：Z = c₁·x₁ + c₂·x₂ + ...</p>
                                </div>

                                <!-- 約束條件 -->
                                <div class="bg-yellow-50 p-4 rounded-lg">
                                    <div class="flex justify-between items-center mb-3">
                                        <h4 class="font-semibold">⚖️ 約束條件</h4>
                                        <button id="lpAddConstraintBtn" class="text-sm bg-yellow-500 text-white px-3 py-1 rounded hover:bg-yellow-600">+ 新增約束</button>
                                    </div>
                                    <div id="lpConstraintsContainer" class="space-y-3">
                                        <!-- Constraint 1 -->
                                        <div class="constraint-row flex flex-wrap items-center gap-2 bg-white p-3 rounded border">
                                            <span class="text-sm font-medium w-16">約束 1:</span>
                                            <input type="number" class="lp-constraint-coef w-16 rounded border-gray-300 text-sm" placeholder="a₁₁" value="2">
                                            <span class="text-xs">x₁ +</span>
                                            <input type="number" class="lp-constraint-coef w-16 rounded border-gray-300 text-sm" placeholder="a₁₂" value="1">
                                            <span class="text-xs">x₂</span>
                                            <select class="lp-constraint-op w-16 rounded border-gray-300 text-sm">
                                                <option value="<=" selected>≤</option>
                                                <option value=">=">≥</option>
                                                <option value="=">=</option>
                                            </select>
                                            <input type="number" class="lp-constraint-rhs w-20 rounded border-gray-300 text-sm" placeholder="b₁" value="100">
                                            <input type="text" class="lp-constraint-name flex-1 rounded border-gray-300 text-sm min-w-[100px]" placeholder="約束名稱" value="機器A工時">
                                            <button class="lp-remove-constraint text-red-500 hover:text-red-700 text-lg">✕</button>
                                        </div>
                                        <!-- Constraint 2 -->
                                        <div class="constraint-row flex flex-wrap items-center gap-2 bg-white p-3 rounded border">
                                            <span class="text-sm font-medium w-16">約束 2:</span>
                                            <input type="number" class="lp-constraint-coef w-16 rounded border-gray-300 text-sm" placeholder="a₂₁" value="1">
                                            <span class="text-xs">x₁ +</span>
                                            <input type="number" class="lp-constraint-coef w-16 rounded border-gray-300 text-sm" placeholder="a₂₂" value="2">
                                            <span class="text-xs">x₂</span>
                                            <select class="lp-constraint-op w-16 rounded border-gray-300 text-sm">
                                                <option value="<=" selected>≤</option>
                                                <option value=">=">≥</option>
                                                <option value="=">=</option>
                                            </select>
                                            <input type="number" class="lp-constraint-rhs w-20 rounded border-gray-300 text-sm" placeholder="b₂" value="80">
                                            <input type="text" class="lp-constraint-name flex-1 rounded border-gray-300 text-sm min-w-[100px]" placeholder="約束名稱" value="機器B工時">
                                            <button class="lp-remove-constraint text-red-500 hover:text-red-700 text-lg">✕</button>
                                        </div>
                                    </div>
                                    <div class="flex items-center gap-4 mt-2">
                                        <p class="text-xs text-gray-500">💡 非負約束 (x₁, x₂ ≥ 0) 已自動包含</p>
                                        <label class="inline-flex items-center text-xs">
                                            <input type="checkbox" id="lpIntegerConstraint" class="form-checkbox text-indigo-600 rounded">
                                            <span class="ml-1 text-gray-600">🔢 整數約束 (Integer)</span>
                                        </label>
                                    </div>
                                </div>

                                <!-- 執行按鈕 -->
                                <div>
                                    <button id="runLinearProgrammingBtn" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700">
                                        🧮 求解線性規劃
                                    </button>
                                    <button id="lpLoadExampleBtn" class="ml-2 bg-gray-200 text-gray-700 font-medium py-2 px-4 rounded-lg hover:bg-gray-300">
                                        📋 載入範例
                                    </button>
                                </div>

                                <!-- 結果區域 -->
                                <div id="lpResults" class="mt-6 hidden">
                                    <h3 class="text-lg font-semibold mb-4">📊 求解結果</h3>
                                    
                                    <!-- 最佳解 -->
                                    <div id="lpOptimalSolution" class="bg-green-50 border border-green-200 rounded-lg p-4 mb-4"></div>
                                    
                                    <!-- 可行區域圖 (2D only) -->
                                    <div id="lpFeasibleRegionPlot" class="bg-white border rounded-lg p-4 mb-4" style="min-height: 450px;"></div>
                                    
                                    <!-- 敏感度分析 -->
                                    <div id="lpSensitivityAnalysis" class="bg-gray-50 border rounded-lg p-4"></div>
                                </div>
                            </div>
                        </div>

                        <div id="bubbleChartContent" class="basic-tab-content hidden mt-4">
                            <p class="text-gray-600 mb-4">
                                多維度泡泡圖 (Bubble Chart)：同時呈現多個維度的資料關係 — X軸、Y軸、泡泡大小、泡泡顏色、標籤、時間。
                            </p>
                            <div class="space-y-4">
                                <!-- 變數選擇 -->
                                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    <div>
                                        <label for="bubbleXVar" class="block text-sm font-medium text-gray-700">X 軸變數</label>
                                        <select id="bubbleXVar"
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                    </div>
                                    <div>
                                        <label for="bubbleYVar" class="block text-sm font-medium text-gray-700">Y 軸變數</label>
                                        <select id="bubbleYVar"
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                    </div>
                                    <div>
                                        <label for="bubbleSizeVar" class="block text-sm font-medium text-gray-700">泡泡大小 (Size)</label>
                                        <select id="bubbleSizeVar"
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                            <option value="">不使用</option>
                                        </select>
                                        <p class="text-xs text-gray-500 mt-1">選擇一個數值欄位控制泡泡大小</p>
                                    </div>
                                    <div>
                                        <label for="bubbleColorVar" class="block text-sm font-medium text-gray-700">泡泡顏色 (Color)</label>
                                        <select id="bubbleColorVar"
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                            <option value="">不使用</option>
                                        </select>
                                        <p class="text-xs text-gray-500 mt-1">選擇類別或數值欄位控制顏色</p>
                                    </div>
                                </div>

                                <!-- 進階設定 -->
                                <div class="bg-gray-50 p-4 rounded-lg">
                                    <h4 class="font-semibold mb-3">進階設定</h4>
                                    <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                                        <div>
                                            <label for="bubbleLabelOverlay" class="block text-sm font-medium text-gray-700">標籤欄位 - 疊圖 (選填)</label>
                                            <select id="bubbleLabelOverlay"
                                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                                <option value="">不使用</option>
                                            </select>
                                            <p class="text-xs text-gray-500 mt-1">所有標籤值顯示在同一張圖</p>
                                        </div>
                                        <div>
                                            <label for="bubbleLabelSeparate" class="block text-sm font-medium text-gray-700">標籤欄位 - 不疊圖 (選填)</label>
                                            <select id="bubbleLabelSeparate"
                                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                                <option value="">不使用</option>
                                            </select>
                                            <p class="text-xs text-gray-500 mt-1">每個標籤值產生獨立圖表 (最多25張)</p>
                                        </div>
                                        <div>
                                            <label for="bubbleTimeVar" class="block text-sm font-medium text-gray-700">🎬 時間軸 (動畫)</label>
                                            <select id="bubbleTimeVar"
                                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                                <option value="">不使用動畫</option>
                                            </select>
                                            <p class="text-xs text-gray-500 mt-1">選擇如 Year、Month 等時間欄位</p>
                                        </div>
                                        <div>
                                            <label for="bubbleMinSize" class="block text-sm font-medium text-gray-700">最小泡泡大小</label>
                                            <input type="number" id="bubbleMinSize" value="8" min="2" max="30"
                                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                        </div>
                                        <div>
                                            <label for="bubbleMaxSize" class="block text-sm font-medium text-gray-700">最大泡泡大小</label>
                                            <input type="number" id="bubbleMaxSize" value="60" min="10" max="100"
                                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                        </div>
                                    </div>
                                </div>

                                <!-- 執行按鈕 -->
                                <div>
                                    <button id="runBubbleChartBtn"
                                        class="bg-emerald-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-emerald-700">
                                        產生泡泡圖
                                    </button>
                                </div>

                                <!-- 結果區域 -->
                                <div id="bubbleChartResults" class="mt-6 hidden">
                                    <div class="flex justify-between items-center mb-4">
                                        <h3 class="text-lg font-semibold">多維度泡泡圖</h3>
                                        <div id="bubbleAnimationControls" style="display: none;" class="flex items-center gap-3">
                                            <button id="bubblePlayBtn" class="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600 flex items-center gap-2">
                                                <span id="bubblePlayIcon">▶️</span> <span id="bubblePlayText">播放</span>
                                            </button>
                                            <div class="flex items-center gap-2">
                                                <label class="text-sm text-gray-600">速度:</label>
                                                <select id="bubbleAnimSpeed" class="rounded border-gray-300 text-sm">
                                                    <option value="2000">慢</option>
                                                    <option value="1000">中</option>
                                                    <option value="500">快</option>
                                                    <option value="200" selected>極快</option>
                                                    <option value="100">光速</option>
                                                </select>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <!-- Animation Slider -->
                                    <div id="bubbleTimeSliderContainer" style="display: none;" class="mb-4 bg-gray-50 p-3 rounded-lg">
                                        <div class="flex items-center gap-4">
                                            <span class="text-sm font-medium text-gray-700">時間點:</span>
                                            <input type="range" id="bubbleTimeSlider" min="0" max="100" value="0" 
                                                class="flex-1 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                                            <span id="bubbleCurrentTime" class="text-lg font-bold text-blue-600 min-w-[80px] text-center"></span>
                                        </div>
                                    </div>
                                    
                                    <div id="bubbleChartPlot" class="bg-white border rounded-lg p-4" style="min-height: 500px;"></div>
                                    <div id="bubbleMultiChartsContainer" class="hidden mt-4">
                                        <div id="bubbleMultiChartsHeader" class="mb-4 p-3 bg-blue-50 border border-blue-200 rounded-lg"></div>
                                        <div id="bubbleMultiChartsGrid" class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4"></div>
                                    </div>
                                    <div id="bubbleChartLegend" class="mt-4 text-sm text-gray-600"></div>
                                </div>
                            </div>
                        </div>

                    </div>



                    <div id="forecastContent" class="tab-content hidden">
                        <div class="border-b border-gray-200 mb-4">
                            <nav class="flex flex-wrap gap-2" aria-label="ForecastTabs">
                                <button class="forecast-tab-button active font-medium" data-forecast-tab="prophetForecast">
                                    趨勢+季節分解
                                </button>
                                <button class="forecast-tab-button font-medium" data-forecast-tab="movingAverage">
                                    移動平均
                                </button>
                                <button class="forecast-tab-button font-medium" data-forecast-tab="singleExponential">
                                    單指數平滑
                                </button>
                                <button class="forecast-tab-button font-medium" data-forecast-tab="doubleExponential">
                                    雙指數平滑
                                </button>
                                <button class="forecast-tab-button font-medium" data-forecast-tab="holtForecast">
                                    Holt-Winters
                                </button>
                                <button class="forecast-tab-button font-medium" data-forecast-tab="arimaForecast">
                                    ARIMA
                                </button>
                                <button class="forecast-tab-button font-medium" data-forecast-tab="lstm">
                                    LSTM
                                </button>
                                <button class="forecast-tab-button font-medium" data-forecast-tab="crostonForecast">
                                    Croston間歇需求
                                </button>
                                <button class="forecast-tab-button font-medium" data-forecast-tab="bass">
                                    新產品Bass
                                </button>
                            </nav>
                        </div>

                        <!-- Moving Average Content (Placeholder) -->
                        <!-- Moving Average Content -->
                        <div id="movingAverageContent" class="forecast-tab-content hidden">
                            <p class="text-gray-600 mb-4">
                                移動平均 (Simple Moving Average)：計算固定視窗內的平均值，平滑短期波動以識別長期趨勢。
                            </p>
                            <div class="grid grid-cols-2 md:grid-cols-4 gap-4 items-end">
                                <div>
                                    <label for="movingAverageTimeVar" class="block text-sm font-medium text-gray-700">選擇時間欄位 (X)</label>
                                    <select id="movingAverageTimeVar" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm text-sm py-2"></select>
                                </div>
                                <div>
                                    <label for="movingAverageValueVar" class="block text-sm font-medium text-gray-700">選擇數值欄位 (Y)</label>
                                    <select id="movingAverageValueVar" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm text-sm py-2"></select>
                                </div>
                                <div>
                                    <label for="movingAverageSteps" class="block text-sm font-medium text-gray-700">預測期數</label>
                                    <input type="number" id="movingAverageSteps" value="12" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm text-sm py-2">
                                </div>
                            </div>

                            <!-- Auto 參數優化 (預設啟用) -->
                            <div class="mt-4">
                                <div class="flex items-center mb-2">
                                    <input type="checkbox" id="movingAverageAutoParams" class="mr-2 h-4 w-4 text-blue-600 rounded focus:ring-blue-500" onchange="toggleMovingAverageAutoParams()" checked>
                                    <label for="movingAverageAutoParams" class="text-sm font-medium text-gray-900 select-none">
                                        使用 Auto Grid Search 自動優化參數 (最佳間隔 N)
                                    </label>
                                </div>
                                
                                <div id="movingAverageAutoResult" class="text-sm bg-green-50 text-green-700 p-2 rounded border border-green-200 mb-3 hidden"></div>

                                <div class="hidden p-4 bg-gray-50 rounded-md border border-gray-200 mt-2" id="movingAverageManualParamsContainer">
                                    <p class="text-xs text-gray-500 mb-3">取消勾選 Auto 後可手動調整參數：</p>
                                    <div class="grid grid-cols-2 gap-4">
                                        <div>
                                            <label for="movingAverageWindow" class="block text-sm font-medium text-gray-700">間隔 N)</label>
                                            <input type="number" id="movingAverageWindow" value="3" min="2" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="mt-4">
                                <button id="runMovingAverageBtn"
                                    class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700">
                                    執行移動平均預測
                                </button>
                            </div>
                            <div id="movingAverageResults" class="mt-6"></div>
                        </div>

                        <!-- Single Exponential Smoothing Content -->
                        <div id="singleExponentialContent" class="forecast-tab-content hidden">
                            <p class="text-gray-600 mb-4">
                                單指數平滑 (Simple Exponential Smoothing)：適用於無明顯趨勢或季節性的數據，給予近期數據較高權重。
                            </p>
                            <div class="grid grid-cols-2 md:grid-cols-4 gap-4 items-end">
                                <div>
                                    <label for="singleExpTimeVar" class="block text-sm font-medium text-gray-700">選擇時間欄位 (X)</label>
                                    <select id="singleExpTimeVar" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm text-sm py-2"></select>
                                </div>
                                <div>
                                    <label for="singleExpValueVar" class="block text-sm font-medium text-gray-700">選擇數值欄位 (Y)</label>
                                    <select id="singleExpValueVar" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm text-sm py-2"></select>
                                </div>
                                <div>
                                    <label for="singleExpSteps" class="block text-sm font-medium text-gray-700">預測期數</label>
                                    <input type="number" id="singleExpSteps" value="12" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm text-sm py-2">
                                </div>
                            </div>

                            <!-- Auto 參數優化 -->
                            <div class="mt-4">
                                <div class="flex items-center mb-2">
                                    <input type="checkbox" id="singleExpAutoParams" class="mr-2 h-4 w-4 text-blue-600 rounded focus:ring-blue-500" onchange="toggleSingleExpAutoParams()" checked>
                                    <label for="singleExpAutoParams" class="text-sm font-medium text-gray-900 select-none">
                                        使用 Auto Grid Search 自動優化參數 (依據驗證集 MAE)
                                    </label>
                                </div>
                                
                                <div id="singleExpAutoResult" class="text-sm bg-green-50 text-green-700 p-2 rounded border border-green-200 mb-3 hidden"></div>

                                <div class="hidden p-4 bg-gray-50 rounded-md border border-gray-200 mt-2" id="singleExpManualParamsContainer">
                                    <p class="text-xs text-gray-500 mb-3">取消勾選 Auto 後可手動調整參數：</p>
                                    <div class="grid grid-cols-2 gap-4">
                                        <div>
                                            <label for="singleExpAlpha" class="block text-sm font-medium text-gray-700">Alpha (平滑係數 α)</label>
                                            <input type="number" id="singleExpAlpha" value="0.5" step="0.1" min="0" max="1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="mt-4">
                                <button id="runSingleExponentialBtn"
                                    class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700">
                                    執行單指數平滑預測
                                </button>
                            </div>
                            <div id="singleExpResults" class="mt-6"></div>
                        </div>

                        <!-- Double Exponential Smoothing Content -->
                        <div id="doubleExponentialContent" class="forecast-tab-content hidden">
                            <p class="text-gray-600 mb-4">
                                雙指數平滑 (Double Exponential Smoothing / Holt's Linear)：適用於具有趨勢但無季節性的時間序列數據。
                            </p>
                            <div class="grid grid-cols-2 md:grid-cols-4 gap-4 items-end">
                                <div>
                                    <label for="doubleExpTimeVar" class="block text-sm font-medium text-gray-700">選擇時間欄位 (X)</label>
                                    <select id="doubleExpTimeVar" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm text-sm py-2"></select>
                                </div>
                                <div>
                                    <label for="doubleExpValueVar" class="block text-sm font-medium text-gray-700">選擇數值欄位 (Y)</label>
                                    <select id="doubleExpValueVar" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm text-sm py-2"></select>
                                </div>
                                <div>
                                    <label for="doubleExpSteps" class="block text-sm font-medium text-gray-700">預測期數</label>
                                    <input type="number" id="doubleExpSteps" value="12" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm text-sm py-2">
                                </div>
                            </div>

                            <!-- Auto 參數優化 (預設啟用) -->
                            <div class="mt-4">
                                <div class="flex items-center mb-2">
                                    <input type="checkbox" id="doubleExpAutoParams" class="mr-2 h-4 w-4 text-blue-600 rounded focus:ring-blue-500" onchange="toggleDoubleExpAutoParams()" checked>
                                    <label for="doubleExpAutoParams" class="text-sm font-medium text-gray-900 select-none">
                                        使用 Auto Grid Search 自動優化參數 (依據驗證集 MAE)
                                    </label>
                                </div>
                                
                                <!-- 結果顯示區 -->
                                <div id="doubleExpAutoResult" class="text-sm bg-green-50 text-green-700 p-2 rounded border border-green-200 mb-3 hidden"></div>

                                <!-- 手動參數區 (預設隱藏) -->
                                <div class="hidden p-4 bg-gray-50 rounded-md border border-gray-200 mt-2" id="doubleExpManualParamsContainer">
                                    <p class="text-xs text-gray-500 mb-3">取消勾選 Auto 後可手動調整參數：</p>
                                    <div class="grid grid-cols-2 gap-4">
                                        <div>
                                            <label for="doubleExpAlpha" class="block text-sm font-medium text-gray-700">Alpha (水平)</label>
                                            <input type="number" id="doubleExpAlpha" value="0.5" step="0.1" min="0.01" max="0.99" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                        </div>
                                        <div>
                                            <label for="doubleExpBeta" class="block text-sm font-medium text-gray-700">Beta (趨勢)</label>
                                            <input type="number" id="doubleExpBeta" value="0.5" step="0.1" min="0.01" max="0.99" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="mt-4">
                                <button id="runDoubleExponentialBtn"
                                    class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700">
                                    執行雙指數平滑預測
                                </button>
                            </div>
                            <div id="doubleExpResults" class="mt-6"></div>
                        </div>

                        <!-- Holt-Winters 子功能：完整保留原本 UI 與邏輯 -->
                        <div id="holtForecastContent" class="forecast-tab-content hidden">
                            <p class="text-gray-600 mb-4">
                                Holt-Winters 三次指數平滑法 (Triple Exponential Smoothing)：適用於具有趨勢性 (Trend) 與季節性 (Seasonality) 的時間序列數據。
                                模型包含三個平滑參數：α (水平)、β (趨勢)、γ (季節)。本系統採用<strong>乘法季節模式 (Multiplicative)</strong>，適合季節波動幅度隨數據水平成比例變化的情境。
                            </p>
                            <div class="grid grid-cols-2 md:grid-cols-4 gap-4 items-end">
                                <div>
                                    <label for="forecastTimeVar" class="block text-sm font-medium text-gray-700">選擇時間欄位 (X)</label>
                                    <select id="forecastTimeVar" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm text-sm py-2"></select>
                                </div>
                                <div>
                                    <label for="forecastValueVar" class="block text-sm font-medium text-gray-700">選擇數值欄位 (Y)</label>
                                    <select id="forecastValueVar" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm text-sm py-2"></select>
                                </div>
                                <div>
                                    <label for="forecastPeriod" class="block text-sm font-medium text-gray-700 flex justify-between items-center">
                                        季節長度
                                        <button type="button" id="autoDetectPeriodBtn" onclick="autoDetectPeriod()" 
                                            class="text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded hover:bg-blue-200 transition-colors" title="自動偵測季節長度">
                                            🔍 Auto Detect
                                        </button>
                                    </label>
                                    <input type="number" id="forecastPeriod" value="12" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm text-sm py-2">
                                    <p id="periodDetectHint" class="text-xs text-green-600 mt-1 hidden"></p>
                                </div>
                                <div>
                                    <label for="forecastSteps" class="block text-sm font-medium text-gray-700">預測期數</label>
                                    <input type="number" id="forecastSteps" value="12" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm text-sm py-2">
                                </div>
                            </div>

                            <!-- Auto 參數優化 (預設啟用) -->
                            <div class="mt-4">
                                <div class="flex items-center mb-2">
                                    <input type="checkbox" id="forecastAutoParams" class="mr-2 h-4 w-4 text-blue-600 rounded focus:ring-blue-500" onchange="toggleAutoParams()" checked>
                                    <label for="forecastAutoParams" class="text-sm font-medium text-gray-900 select-none">
                                        使用 Auto Grid Search 自動優化參數 (依據驗證集 MAE)
                                    </label>
                                </div>
                                
                                <!-- 結果顯示區 -->
                                <div id="autoParamsResult" class="text-sm bg-green-50 text-green-700 p-2 rounded border border-green-200 mb-3 hidden"></div>

                                <!-- 手動參數區 (預設隱藏) -->
                                <div class="hidden p-4 bg-gray-50 rounded-md border border-gray-200 mt-2" id="manualParamsContainer">
                                    <p class="text-xs text-gray-500 mb-3">取消勾選 Auto 後可手動調整參數：</p>
                                    <div class="grid grid-cols-3 gap-4">
                                        <div>
                                            <label for="forecastAlpha" class="block text-sm font-medium text-gray-700">Alpha (水平)</label>
                                            <input type="number" id="forecastAlpha" value="0.5" step="0.1" min="0.01" max="0.99" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                        </div>
                                        <div>
                                            <label for="forecastBeta" class="block text-sm font-medium text-gray-700">Beta (趨勢)</label>
                                            <input type="number" id="forecastBeta" value="0.5" step="0.1" min="0.01" max="0.99" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                        </div>
                                        <div>
                                            <label for="forecastGamma" class="block text-sm font-medium text-gray-700">Gamma (季節)</label>
                                            <input type="number" id="forecastGamma" value="0.5" step="0.1" min="0.01" max="0.99" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="mt-4">
                                <button id="runForecastBtn"
                                    class="bg-sky-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-sky-700">
                                    執行預測
                                </button>
                            </div>
                            <div id="forecastResults" class="mt-6"></div>
                        </div>

                        <!-- 趨勢 + 季節分解 子功能 -->
                        <div id="prophetForecastContent" class="forecast-tab-content">
                            <p class="text-gray-600 mb-4">
                                使用「古典分解法 (Classical Decomposition)」將時間序列拆解為趨勢 (Trend)、季節性 (Seasonality) 與殘差 (Residual)，並進行疊加預測。
                            </p>
                            <div class="grid md:grid-cols-2 lg:grid-cols-4 gap-4 items-end">
                                <div>
                                    <label for="prophetTimeVar" class="block text-sm font-medium text-gray-700">選擇時間欄位
                                        (X)</label>
                                    <select id="prophetTimeVar"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                </div>
                                <div>
                                    <label for="prophetValueVar" class="block text-sm font-medium text-gray-700">選擇數值欄位
                                        (Y)</label>
                                    <select id="prophetValueVar"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                </div>
                                <div>
                                    <label for="prophetPeriod" class="block text-sm font-medium text-gray-700">季節長度
                                        (Period)</label>
                                    <input type="number" id="prophetPeriod" value="12"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                    <p class="text-xs text-gray-500 mt-1">
                                        例如：月資料多為 12、週資料可設 52。
                                    </p>
                                </div>
                                <div>
                                    <label for="prophetSteps"
                                        class="block text-sm font-medium text-gray-700">預測期數</label>
                                    <input type="number" id="prophetSteps" value="12"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                </div>
                            </div>

                            <div class="mt-4">
                                <button id="runProphetBtn"
                                    class="bg-amber-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-amber-700">
                                    執行趨勢 + 季節分解預測
                                </button>
                            </div>

                            <div id="prophetResults" class="mt-6"></div>
                        </div>

                        <!-- ARIMA 子功能 -->
                        <div id="arimaForecastContent" class="forecast-tab-content hidden">
                            <p class="text-gray-600 mb-4">
                                使用 ARIMA 模型（差分 + 自迴歸 AR + 移動平均 MA）進行時間序列預測，適合平穩或經差分後平穩的資料。
                                本工具實作 ARIMA(p, d, q)，在純 JavaScript 環境中，採用 Hannan–Rissanen 兩階段迴歸法，以 OLS 估計 AR (φ) 與 MA
                                (θ) 係數。
                            </p>
                            <div class="grid md:grid-cols-2 lg:grid-cols-4 gap-4 items-end">
                                <div>
                                    <label for="arimaTimeVar" class="block text-sm font-medium text-gray-700">選擇時間欄位
                                        (X)</label>
                                    <select id="arimaTimeVar"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                </div>
                                <div>
                                    <label for="arimaValueVar" class="block text-sm font-medium text-gray-700">選擇數值欄位
                                        (Y)</label>
                                    <select id="arimaValueVar"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                </div>
                                <div>
                                    <label for="arimaSteps" class="block text-sm font-medium text-gray-700">預測期數</label>
                                    <input type="number" id="arimaSteps" value="12" min="1"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                </div>
                            </div>
                            <!-- Auto Grid Search for p,d,q -->

                            <!-- Auto 參數優化 (預設啟用) -->
                            <div class="mt-4">
                                <div class="flex items-center mb-2">
                                    <input type="checkbox" id="arimaAutoParams" class="mr-2 h-4 w-4 text-orange-600 rounded focus:ring-orange-500" onchange="toggleArimaAutoParams()" checked>
                                    <label for="arimaAutoParams" class="text-sm font-medium text-gray-900 select-none">
                                        使用 Auto Grid Search 自動優化參數 (依據驗證集 MAE)
                                    </label>
                                </div>
                                
                                <!-- 結果顯示區 -->
                                <div id="arimaAutoResult" class="text-sm bg-green-50 text-green-700 p-2 rounded border border-green-200 mb-3 hidden"></div>

                                <!-- 手動參數區 (預設隱藏) -->
                                <div class="hidden p-4 bg-gray-50 rounded-md border border-gray-200 mt-2" id="arimaManualParamsContainer">
                                    <p class="text-xs text-gray-500 mb-3">取消勾選 Auto 後可手動調整參數：</p>
                                    <div class="grid grid-cols-3 gap-4">
                                        <div>
                                            <label for="arimaP" class="block text-sm font-medium text-gray-700">自迴歸階數 p</label>
                                            <input type="number" id="arimaP" value="1" min="0" max="3" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                        </div>
                                        <div>
                                            <label for="arimaD" class="block text-sm font-medium text-gray-700">差分階數 d</label>
                                            <input type="number" id="arimaD" value="0" min="0" max="2" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                        </div>
                                        <div>
                                            <label for="arimaQ" class="block text-sm font-medium text-gray-700">移動平均階數 q</label>
                                            <input type="number" id="arimaQ" value="0" min="0" max="3" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="mt-4">
                                <button id="runArimaBtn"
                                    class="bg-orange-700 text-white font-bold py-2 px-4 rounded-lg hover:bg-orange-800">
                                    執行 ARIMA 預測
                                </button>
                            </div>
                            <div id="arimaResults" class="mt-6"></div>
                        </div>

                        <!-- LSTM Content -->
                        <div id="lstmContent" class="forecast-tab-content hidden">
                            <p class="text-gray-600 mb-4">
                                LSTM (Long Short-Term Memory)：深度學習遞迴神經網絡，適用於捕捉長期時序依賴性的複雜時間序列預測。
                            </p>
                            <div class="grid grid-cols-2 md:grid-cols-5 gap-4 items-end">
                                <div>
                                    <label for="lstmTimeVar" class="block text-sm font-medium text-gray-700">選擇時間欄位 (X)</label>
                                    <select id="lstmTimeVar" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm text-sm py-2"></select>
                                </div>
                                <div>
                                    <label for="lstmValueVar" class="block text-sm font-medium text-gray-700">選擇數值欄位 (Y)</label>
                                    <select id="lstmValueVar" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm text-sm py-2"></select>
                                </div>
                                <div>
                                    <label for="lstmLookback" class="block text-sm font-medium text-gray-700">Lookback (回看期數)</label>
                                    <input type="number" id="lstmLookback" value="10" min="2" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm text-sm py-2">
                                </div>
                                <div>
                                    <label for="lstmEpochs" class="block text-sm font-medium text-gray-700">訓練週期 (Epochs)</label>
                                    <input type="number" id="lstmEpochs" value="50" min="10" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm text-sm py-2">
                                </div>
                                <div>
                                    <label for="lstmSteps" class="block text-sm font-medium text-gray-700">預測期數</label>
                                    <input type="number" id="lstmSteps" value="12" min="1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm text-sm py-2">
                                </div>
                            </div>

                            <div class="mt-4 p-3 bg-yellow-50 border-l-4 border-yellow-400 rounded-r-md">
                                <p class="text-sm text-yellow-700">
                                    <strong>⚠️ 注意：</strong>LSTM 模型訓練耗時較長，請耐心等待。訓練過程使用 TensorFlow.js 在瀏覽器端執行。
                                </p>
                            </div>

                            <div class="mt-4">
                                <button id="runLstmBtn"
                                    class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700">
                                    🚀 執行 LSTM 預測
                                </button>
                            </div>
                            <div id="lstmProgress" class="mt-4 hidden">
                                <div class="flex items-center gap-2 text-indigo-600">
                                    <svg class="animate-spin h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                    </svg>
                                    <span id="lstmProgressText">正在訓練模型...</span>
                                </div>
                                <div class="w-full bg-gray-200 rounded-full h-2.5 mt-2">
                                    <div id="lstmProgressBar" class="bg-indigo-600 h-2.5 rounded-full" style="width: 0%"></div>
                                </div>
                            </div>
                            <div id="lstmResults" class="mt-6"></div>
                        </div>

                        <!-- Croston 子功能 -->
                        <!-- Croston 子功能 -->
                        <div id="crostonForecastContent" class="forecast-tab-content hidden">
                            <p class="text-gray-600 mb-4">
                                使用 Croston 方法處理間歇性需求（多為 0，偶爾出現正需求），適合備品、慢料等需求預測教學。
                                Croston 模型對未來各期提供相同的預測水準。
                            </p>
                            <div class="grid md:grid-cols-2 lg:grid-cols-3 gap-4 items-end">
                                <div>
                                    <label for="crostonTimeVar" class="block text-sm font-medium text-gray-700">選擇時間欄位 (X)</label>
                                    <select id="crostonTimeVar" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                </div>
                                <div>
                                    <label for="crostonValueVar" class="block text-sm font-medium text-gray-700">選擇需求量欄位 (Y)</label>
                                    <select id="crostonValueVar" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                </div>
                                <div>
                                    <label for="crostonSteps" class="block text-sm font-medium text-gray-700">預測期數</label>
                                    <input type="number" id="crostonSteps" value="12" min="1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                </div>
                            </div>

                            <!-- Auto Option -->
                             <div class="mt-4 flex flex-wrap items-center gap-4">
                                <label class="flex items-center gap-2 cursor-pointer bg-lime-50 px-3 py-2 rounded-lg border border-lime-200 shadow-sm hover:bg-lime-100 transition-colors">
                                    <input type="checkbox" id="crostonAutoParams" class="w-5 h-5 text-lime-600 rounded focus:ring-lime-500 border-gray-300" checked onchange="toggleCrostonAutoParams()">
                                    <span class="font-medium text-gray-700">Auto Optimize (Grid Search)</span>
                                </label>
                                <p id="crostonAutoResult" class="text-sm text-lime-700 font-medium hidden">
                                    <!-- Best α/β result -->
                                </p>
                            </div>

                            <!-- Manual Params (Hidden by default) -->
                            <div id="crostonManualParamsContainer" class="mt-4 grid md:grid-cols-2 gap-4 hidden">
                                <div>
                                    <label for="crostonAlpha" class="block text-sm font-medium text-gray-700">平滑係數 α（需求大小）</label>
                                    <input type="number" id="crostonAlpha" value="0.3" step="0.05" min="0.01" max="1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                    <p class="text-xs text-gray-500 mt-1">控制「大小」平滑速度</p>
                                </div>
                                <div>
                                    <label for="crostonBeta" class="block text-sm font-medium text-gray-700">平滑係數 β（需求間隔）</label>
                                    <input type="number" id="crostonBeta" value="0.3" step="0.05" min="0.01" max="1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                    <p class="text-xs text-gray-500 mt-1">控制「間隔」平滑速度</p>
                                </div>
                            </div>

                            <div class="mt-4">
                                <button id="runCrostonBtn"
                                    class="bg-lime-700 text-white font-bold py-2 px-4 rounded-lg hover:bg-lime-800">
                                    執行 Croston 預測
                                </button>
                            </div>
                            <div id="crostonResults" class="mt-6"></div>
                        </div>

                        <!-- Bass Diffusion Model Content -->
                        <div id="bassContent" class="forecast-tab-content hidden">
                            <p class="text-gray-600 mb-4">
                                Bass 擴散模型 (Bass Diffusion)：用於預測新產品採用曲線，分析創新者 (p) 與模仿者 (q) 效應。
                            </p>
                            <div class="grid grid-cols-2 md:grid-cols-4 gap-4 items-end">
                                <div>
                                    <label for="bassPValue" class="block text-sm font-medium text-gray-700">p (創新係數)</label>
                                    <input type="number" id="bassPValue" value="0.03" step="0.01" min="0" max="1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm text-sm py-2">
                                    <p class="text-xs text-gray-500 mt-1">外部影響力 (0.01-0.05 常見)</p>
                                </div>
                                <div>
                                    <label for="bassQValue" class="block text-sm font-medium text-gray-700">q (模仿係數)</label>
                                    <input type="number" id="bassQValue" value="0.38" step="0.01" min="0" max="1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm text-sm py-2">
                                    <p class="text-xs text-gray-500 mt-1">內部影響力 (0.3-0.5 常見)</p>
                                </div>
                                <div>
                                    <label for="bassMValue" class="block text-sm font-medium text-gray-700">m (市場潛量)</label>
                                    <input type="number" id="bassMValue" value="1000000" step="10000" min="1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm text-sm py-2">
                                    <p class="text-xs text-gray-500 mt-1">最終總採用人數</p>
                                </div>
                                <div>
                                    <label for="bassPeriods" class="block text-sm font-medium text-gray-700">預測期數 (t)</label>
                                    <input type="number" id="bassPeriods" value="20" min="5" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm text-sm py-2">
                                </div>
                            </div>

                            <div class="mt-4 p-3 bg-orange-50 border-l-4 border-orange-400 rounded-r-md">
                                <p class="text-sm text-orange-700">
                                    <strong>💡 教學提示：</strong>
                                    當 q/p > 1 時，採用曲線呈現 S 型，高峰出現在累積採用量約 50% 處。
                                    典型值：p ≈ 0.03, q ≈ 0.38。
                                </p>
                            </div>

                            <div class="mt-4">
                                <button id="runBassBtn"
                                    class="bg-teal-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-teal-700">
                                    📈 執行 Bass 模型預測
                                </button>
                            </div>
                            <div id="bassResults" class="mt-6"></div>
                        </div>
                    </div>
                    <!-- Machine Learning -->
                    <div id="mlContent" class="tab-content hidden">
                        <div class="border-b border-gray-200">
                            <nav class="flex flex-wrap gap-2" aria-label="MLTabs">
                                <button class="ml-tab-button supervised active font-medium" data-ml-tab="logistic">邏輯斯迴歸</button>
                                <button class="ml-tab-button supervised font-medium" data-ml-tab="decisionTree">決策樹</button>
                                <button class="ml-tab-button supervised font-medium" data-ml-tab="svm">支持向量</button>
                                <button class="ml-tab-button supervised font-medium" data-ml-tab="randomForest">隨機森林</button>
                                <button class="ml-tab-button supervised font-medium" data-ml-tab="neuralNetwork">神經網絡</button>
                                <button class="ml-tab-button unsupervised font-medium" data-ml-tab="pca">主成分分析</button>
                                <button class="ml-tab-button unsupervised font-medium" data-ml-tab="factorAnalysis">因素分析</button>
                                <button class="ml-tab-button unsupervised font-medium" data-ml-tab="kmeans">K-Means 集群</button>
                                <button class="ml-tab-button unsupervised font-medium" data-ml-tab="hierarchical">階層式集群</button>
                                <button class="ml-tab-button unsupervised font-medium" data-ml-tab="apriori">關聯規則</button>
                            </nav>
                        </div>
                        <!-- Logistic Regression Content -->
                        <div id="logisticContent" class="ml-tab-content mt-4">
                            <p class="text-gray-600 mb-4">建立模型以預測二元結果 (例如：是/否、成功/失敗)。</p>
                            <div class="grid md:grid-cols-2 gap-x-8 gap-y-4 items-start">
                                <div>
                                    <label for="logisticY" class="block text-sm font-medium text-gray-700">選擇應變數 (Y,
                                        二元類別)</label>
                                    <select id="logisticY"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                    <p class="mt-2 text-xs text-gray-500">此選單只會顯示資料中剛好有兩種值的類別欄位。</p>
                                </div>
                                <div>
                                    <label for="logisticX" class="block text-sm font-medium text-gray-700">選擇自變數 (X,
                                        數值)</label>
                                    <select id="logisticX" multiple
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm h-32"></select>
                                    <p class="mt-2 text-xs text-gray-500">按住 Ctrl (或 Mac 上的 Command) 可複選。</p>
                                </div>
                            </div>
                            <div class="mt-4"><button id="runLogisticBtn"
                                    class="bg-rose-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-rose-700">執行邏輯斯迴歸</button>
                            </div>
                            <div id="logisticResults" class="mt-6"></div>
                        </div>
                        <!-- Decision Tree Content -->
                        <div id="decisionTreeContent" class="ml-tab-content mt-4 hidden">
                            <p class="text-gray-600 mb-4">建立迴歸決策樹模型，預測數值結果並找出關鍵因子。</p>
                            <div class="grid md:grid-cols-2 gap-x-8 gap-y-4 items-start">
                                <div>
                                    <label for="dtY" class="block text-sm font-medium text-gray-700">選擇應變數 (Y,
                                        數值)</label>
                                    <select id="dtY"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                </div>
                                <div>
                                    <label for="dtX" class="block text-sm font-medium text-gray-700">選擇自變數 (X)</label>
                                    <select id="dtX" multiple
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm h-32"></select>
                                </div>
                                <div>
                                    <label for="dtMaxDepth" class="block text-sm font-medium text-gray-700">最大深度</label>
                                    <input type="number" id="dtMaxDepth" value="5"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                </div>
                                <div>
                                    <label for="dtMinSamplesLeaf"
                                        class="block text-sm font-medium text-gray-700">最小葉節點樣本數</label>
                                    <input type="number" id="dtMinSamplesLeaf" value="5"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                </div>
                            </div>
                            <div class="mt-4"><button id="runDtBtn"
                                    class="bg-amber-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-amber-700">建立決策樹</button>
                            </div>
                            <div id="dtResults" class="mt-6"></div>
                        </div>
                        <!-- Support Vector Machine/Regression Content -->
                        <div id="svmContent" class="ml-tab-content mt-4 hidden">
                            <p class="text-gray-600 mb-4">
                                支持向量機 (Support Vector Machine)：適用於分類與迴歸任務，擅長處理高維度資料與非線性問題。
                            </p>
                            
                            <div class="bg-purple-50 p-4 rounded-lg mb-4">
                                <h4 class="font-semibold text-purple-900 mb-2">🎯 功能特色</h4>
                                <ul class="text-sm text-purple-800 space-y-1">
                                    <li>• <strong>SVM 分類</strong>：適合二元分類與多類別分類</li>
                                    <li>• <strong>SVR 迴歸</strong>：支持向量迴歸，適合非線性關係</li>
                                    <li>• <strong>核函數</strong>：支援 Linear、RBF、Polynomial 核</li>
                                    <li>• <strong>高維適應</strong>：特徵數多於樣本數時仍有效</li>
                                </ul>
                            </div>

                            <!-- 任務類型選擇 -->
                            <div class="flex space-x-2 mb-4 border-b border-gray-300">
                                <button id="svmClassificationTab" onclick="switchSVMTask('classification')"
                                    class="px-4 py-2 font-semibold border-b-2 border-purple-500 text-purple-600">
                                    分類 Classification
                                </button>
                                <button id="svrRegressionTab" onclick="switchSVMTask('regression')"
                                    class="px-4 py-2 font-semibold text-gray-500 hover:text-purple-600">
                                    迴歸 Regression
                                </button>
                            </div>

                            <!-- ============== 分類任務面板 ============== -->
                            <div id="svmClassificationPanel">
                                <p class="text-gray-600 mb-4">
                                    使用 SVM 進行分類預測，找出最佳超平面區分不同類別。
                                </p>
                                <!-- 變數選擇 -->
                                <div class="grid md:grid-cols-2 gap-x-8 gap-y-4">
                                    <div>
                                        <label for="svmClsY" class="block text-sm font-medium text-gray-700">
                                            選擇應變數 (Y, 類別)
                                        </label>
                                        <select id="svmClsY"
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                    </div>
                                    <div>
                                        <label for="svmClsX" class="block text-sm font-medium text-gray-700">
                                            選擇自變數 (X, 可多選)
                                        </label>
                                        <select id="svmClsX" multiple
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm h-32"></select>
                                        <p class="mt-1 text-xs text-gray-500">💡 建議使用數值變數</p>
                                    </div>
                                </div>

                                <!-- 核函數與參數 -->
                                <details class="mt-4" open>
                                    <summary class="cursor-pointer font-semibold text-gray-700">⚙️ 核函數與參數設定</summary>
                                    <div class="mt-3 grid grid-cols-2 md:grid-cols-4 gap-4">
                                        <div>
                                            <label for="svmClsKernel" class="block text-sm font-medium text-gray-700">核函數</label>
                                            <select id="svmClsKernel" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm" onchange="updateSVMClsParams()">
                                                <option value="rbf" selected>RBF (高斯)</option>
                                                <option value="linear">Linear (線性)</option>
                                                <option value="polynomial">Polynomial (多項式)</option>
                                            </select>
                                        </div>
                                        <div>
                                            <label for="svmClsC" class="block text-sm font-medium text-gray-700">C (正則化)</label>
                                            <input type="number" id="svmClsC" value="1.0" min="0.01" step="0.1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                        </div>
                                        <div id="svmClsGammaDiv">
                                            <label for="svmClsGamma" class="block text-sm font-medium text-gray-700">Gamma (RBF)</label>
                                            <input type="number" id="svmClsGamma" value="0.1" min="0.001" step="0.01" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                        </div>
                                        <div id="svmClsDegreeDiv" class="hidden">
                                            <label for="svmClsDegree" class="block text-sm font-medium text-gray-700">Degree (多項式)</label>
                                            <input type="number" id="svmClsDegree" value="3" min="2" max="5" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                        </div>
                                    </div>
                                </details>

                                <!-- 執行按鈕 -->
                                <div class="mt-4">
                                    <button id="runSVMClassificationBtn"
                                        class="bg-purple-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-purple-700 transition duration-300">
                                        🚀 執行 SVM 分類
                                    </button>
                                    <span id="svmClsProgress" class="ml-4 text-sm text-gray-600"></span>
                                </div>
                            </div>

                            <!-- ============== 迴歸任務面板 ============== -->
                            <div id="svrRegressionPanel" style="display:none;">
                                <p class="text-gray-600 mb-4">
                                    使用 SVR (Support Vector Regression) 進行數值預測，適合處理非線性迴歸問題。
                                </p>
                                <!-- 變數選擇 -->
                                <div class="grid md:grid-cols-2 gap-x-8 gap-y-4">
                                    <div>
                                        <label for="svrRegY" class="block text-sm font-medium text-gray-700">
                                            選擇應變數 (Y, 數值)
                                        </label>
                                        <select id="svrRegY"
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                    </div>
                                    <div>
                                        <label for="svrRegX" class="block text-sm font-medium text-gray-700">
                                            選擇自變數 (X, 可多選)
                                        </label>
                                        <select id="svrRegX" multiple
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm h-32"></select>
                                        <p class="mt-1 text-xs text-gray-500">💡 建議使用數值變數</p>
                                    </div>
                                </div>

                                <!-- 核函數與參數 -->
                                <details class="mt-4" open>
                                    <summary class="cursor-pointer font-semibold text-gray-700">⚙️ 核函數與參數設定</summary>
                                    <div class="mt-3 grid grid-cols-2 md:grid-cols-4 gap-4">
                                        <div>
                                            <label for="svrRegKernel" class="block text-sm font-medium text-gray-700">核函數</label>
                                            <select id="svrRegKernel" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm" onchange="updateSVRRegParams()">
                                                <option value="rbf" selected>RBF (高斯)</option>
                                                <option value="linear">Linear (線性)</option>
                                                <option value="polynomial">Polynomial (多項式)</option>
                                            </select>
                                        </div>
                                        <div>
                                            <label for="svrRegC" class="block text-sm font-medium text-gray-700">C (正則化)</label>
                                            <input type="number" id="svrRegC" value="1.0" min="0.01" step="0.1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                        </div>
                                        <div>
                                            <label for="svrRegEpsilon" class="block text-sm font-medium text-gray-700">ε (容忍帶)</label>
                                            <input type="number" id="svrRegEpsilon" value="0.1" min="0.001" step="0.01" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                        </div>
                                        <div id="svrRegGammaDiv">
                                            <label for="svrRegGamma" class="block text-sm font-medium text-gray-700">Gamma (RBF)</label>
                                            <input type="number" id="svrRegGamma" value="0.1" min="0.001" step="0.01" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                        </div>
                                    </div>
                                </details>

                                <!-- 執行按鈕 -->
                                <div class="mt-4">
                                    <button id="runSVRRegressionBtn"
                                        class="bg-purple-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-purple-700 transition duration-300">
                                        🚀 執行 SVR 迴歸
                                    </button>
                                    <span id="svrRegProgress" class="ml-4 text-sm text-gray-600"></span>
                                </div>
                            </div>

                            <div id="svmResults" class="mt-6"></div>

                            <!-- SVM/SVR Prediction Panel -->
                            <div id="svmPredictionPanel" class="mt-6 hidden">
                                <div class="bg-gradient-to-r from-purple-50 to-indigo-50 p-4 rounded-lg border border-purple-200">
                                    <h4 class="font-semibold text-purple-900 mb-3">🔮 模型預測</h4>
                                    <p class="text-sm text-gray-600 mb-3">輸入特徵值，使用已訓練的模型進行預測：</p>
                                    <div id="svmPredictionInputs" class="grid md:grid-cols-3 gap-3 mb-4"></div>
                                    <div class="flex items-center gap-4">
                                        <button id="svmPredictBtn" onclick="runSVMPrediction()"
                                            class="bg-purple-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-purple-700 transition duration-300">
                                            🎯 預測
                                        </button>
                                        <div id="svmPredictionResult" class="text-lg font-semibold"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <!-- Random Forest Content -->
                        <div id="randomForestContent" class="ml-tab-content mt-4 hidden">
                            <p class="text-gray-600 mb-4">
                                隨機森林 (Random Forest)：強大的整體學習方法，透過組合多棵決策樹提升預測準確度。
                                支援<strong>分類</strong>和<strong>迴歸</strong>兩種任務，並提供變數重要性排名。
                            </p>

                            <div class="bg-purple-50 p-4 rounded-lg mb-4">
                                <h4 class="font-semibold text-purple-900 mb-2">🌲 核心優勢</h4>
                                <ul class="text-sm text-purple-800 space-y-1">
                                    <li>• <strong>高準確度</strong>：多棵樹投票，降低過擬合風險</li>
                                    <li>• <strong>變數重要性</strong>：識別關鍵影響因子（適合 DOE 分析）</li>
                                    <li>• <strong>穩健性</strong>：對雜訊和缺失值有較強容忍度</li>
                                    <li>• <strong>無需特徵縮放</strong>：直接處理不同尺度的變數</li>
                                </ul>
                            </div>

                            <!-- 任務類型選擇 -->
                            <div class="flex space-x-2 mb-4 border-b border-gray-300">
                                <button id="rfRegressionTab" onclick="switchRFTask('regression')"
                                    class="px-4 py-2 font-semibold border-b-2 border-green-500 text-green-600">
                                    迴歸 Regression
                                </button>
                                <button id="rfClassificationTab" onclick="switchRFTask('classification')"
                                    class="px-4 py-2 font-semibold text-gray-500 hover:text-green-600">
                                    分類 Classification
                                </button>
                            </div>

                            <!-- ============== 迴歸任務面板 ============== -->
                            <div id="rfRegressionPanel">
                                <p class="text-gray-600 mb-4">
                                    預測連續數值結果（如：銷售額、產品硬度、良率）。系統將建立多棵迴歸樹並平均預測值。
                                </p>

                                <div class="space-y-4">
                                    <!-- 變數選擇 -->
                                    <div class="grid md:grid-cols-2 gap-x-8 gap-y-4">
                                        <div>
                                            <label for="rfRegY" class="block text-sm font-medium text-gray-700">
                                                選擇應變數 (Y, 連續數值)
                                            </label>
                                            <select id="rfRegY"
                                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                        </div>
                                        <div>
                                            <label for="rfRegX" class="block text-sm font-medium text-gray-700">
                                                選擇自變數 (X, 可多選)
                                            </label>
                                            <select id="rfRegX" multiple
                                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm h-32"></select>
                                            <p class="mt-1 text-xs text-gray-500">💡 按住 Ctrl (Win) 或 Cmd (Mac) 多選，建議
                                                5-50 個變數</p>
                                        </div>
                                    </div>

                                    <!-- 模型參數 -->
                                    <details class="border rounded-lg p-3 bg-gray-50">
                                        <summary class="cursor-pointer font-medium text-gray-700">⚙️ 模型參數設定</summary>
                                        <div class="grid md:grid-cols-4 gap-4 mt-3">
                                            <div>
                                                <label for="rfRegNTrees"
                                                    class="block text-sm font-medium text-gray-700">樹的數量</label>
                                                <input type="number" id="rfRegNTrees" value="100" min="10" max="200"
                                                    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                                <p class="text-xs text-gray-500 mt-1">預設 100（50-200 推薦）</p>
                                            </div>
                                            <div>
                                                <label for="rfRegMaxDepth"
                                                    class="block text-sm font-medium text-gray-700">最大深度</label>
                                                <input type="number" id="rfRegMaxDepth" value="10" min="3" max="20"
                                                    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                                <p class="text-xs text-gray-500 mt-1">預設 10（避免過擬合）</p>
                                            </div>
                                            <div>
                                                <label for="rfRegMinSamples"
                                                    class="block text-sm font-medium text-gray-700">最小葉節點樣本</label>
                                                <input type="number" id="rfRegMinSamples" value="5" min="2" max="20"
                                                    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                                <p class="text-xs text-gray-500 mt-1">預設 5</p>
                                            </div>
                                            <div>
                                                <label for="rfRegFeatureMethod"
                                                    class="block text-sm font-medium text-gray-700">特徵採樣</label>
                                                <select id="rfRegFeatureMethod"
                                                    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                                    <option value="sqrt" selected>sqrt(n) - 推薦</option>
                                                    <option value="log2">log2(n)</option>
                                                    <option value="all">全部特徵</option>
                                                </select>
                                                <p class="text-xs text-gray-500 mt-1">每棵樹隨機選取的特徵數</p>
                                            </div>
                                        </div>
                                    </details>

                                    <!-- 執行按鈕 -->
                                    <div>
                                        <button id="runRFRegressionBtn"
                                            class="bg-green-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-green-700 transition duration-300">
                                            🚀 訓練隨機森林（迴歸）
                                        </button>
                                        <span id="rfRegProgress" class="ml-4 text-sm text-gray-600"></span>
                                    </div>
                                </div>

                                <!-- 結果顯示區 -->
                                <div id="rfRegressionResults" class="mt-6"></div>
                            </div>

                            <!-- ============== 分類任務面板 ============== -->
                            <div id="rfClassificationPanel" style="display:none;">
                                <p class="text-gray-600 mb-4">
                                    預測類別結果（如：良品/不良品、高/中/低風險）。系統將建立多棵分類樹並透過投票決定最終類別。
                                </p>

                                <div class="space-y-4">
                                    <!-- 變數選擇 -->
                                    <div class="grid md:grid-cols-2 gap-x-8 gap-y-4">
                                        <div>
                                            <label for="rfClsY" class="block text-sm font-medium text-gray-700">
                                                選擇應變數 (Y, 類別)
                                            </label>
                                            <select id="rfClsY"
                                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                            <p class="mt-1 text-xs text-gray-500">自動偵測類別變數（2-10 個類別）</p>
                                        </div>
                                        <div>
                                            <label for="rfClsX" class="block text-sm font-medium text-gray-700">
                                                選擇自變數 (X, 可多選)
                                            </label>
                                            <select id="rfClsX" multiple
                                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm h-32"></select>
                                            <p class="mt-1 text-xs text-gray-500">💡 支援數值和類別變數混合</p>
                                        </div>
                                    </div>

                                    <!-- 模型參數 -->
                                    <details class="border rounded-lg p-3 bg-gray-50">
                                        <summary class="cursor-pointer font-medium text-gray-700">⚙️ 模型參數設定</summary>
                                        <div class="grid md:grid-cols-4 gap-4 mt-3">
                                            <div>
                                                <label for="rfClsNTrees"
                                                    class="block text-sm font-medium text-gray-700">樹的數量</label>
                                                <input type="number" id="rfClsNTrees" value="100" min="10" max="200"
                                                    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                            </div>
                                            <div>
                                                <label for="rfClsMaxDepth"
                                                    class="block text-sm font-medium text-gray-700">最大深度</label>
                                                <input type="number" id="rfClsMaxDepth" value="10" min="3" max="20"
                                                    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                            </div>
                                            <div>
                                                <label for="rfClsMinSamples"
                                                    class="block text-sm font-medium text-gray-700">最小葉節點樣本</label>
                                                <input type="number" id="rfClsMinSamples" value="5" min="2" max="20"
                                                    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                            </div>
                                            <div>
                                                <label for="rfClsFeatureMethod"
                                                    class="block text-sm font-medium text-gray-700">特徵採樣</label>
                                                <select id="rfClsFeatureMethod"
                                                    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                                    <option value="sqrt" selected>sqrt(n) - 推薦</option>
                                                    <option value="log2">log2(n)</option>
                                                    <option value="all">全部特徵</option>
                                                </select>
                                            </div>
                                        </div>
                                    </details>

                                    <!-- 執行按鈕 -->
                                    <div>
                                        <button id="runRFClassificationBtn"
                                            class="bg-green-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-green-700 transition duration-300">
                                            🚀 訓練隨機森林（分類）
                                        </button>
                                        <span id="rfClsProgress" class="ml-4 text-sm text-gray-600"></span>
                                    </div>
                                </div>

                                <!-- 結果顯示區 -->
                                <div id="rfClassificationResults" class="mt-6"></div>
                            </div>
                        </div>
                        <!-- Neural Network Content -->
                        <div id="neuralNetworkContent" class="ml-tab-content mt-4 hidden">
                            <p class="text-gray-600 mb-4">
                                神經網絡 (Neural Network)：適合處理非線性關係的分類與迴歸問題，常用於影像辨識、文字分類、異常偵測等情境。
                            </p>

                            <div class="bg-purple-50 p-4 rounded-lg mb-4">
                                <h4 class="font-semibold text-purple-900 mb-2">🧠 使用建議</h4>
                                <ul class="text-sm text-purple-800 space-y-1">
                                    <li>• 當「線性迴歸」或「決策樹」效果不足時，可嘗試神經網絡。</li>
                                    <li>• 資料筆數越多、特徵越多，神經網絡的優勢越明顯。</li>
                                    <li>• 需注意過擬合，建議搭配驗證集、正規化與早停策略。</li>
                                </ul>
                            </div>

                            <div class="grid md:grid-cols-2 gap-x-8 gap-y-4 items-start">
                                <div>
                                    <label for="nnY" class="block text-sm font-medium text-gray-700">選擇應變數 (Y)</label>
                                    <select id="nnY"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                    <p class="mt-2 text-xs text-gray-500">
                                        Y 可為連續數值（迴歸）或類別變數（分類）；系統會自動判斷任務型型。
                                    </p>
                                </div>
                                <div>
                                    <label for="nnX" class="block text-sm font-medium text-gray-700">選擇自變數 (X,
                                        可多選)</label>
                                    <select id="nnX" multiple
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm h-32"></select>
                                    <p class="mt-2 text-xs text-gray-500">
                                        建議優先選擇數值型特徵；類別變數需先做 One-Hot Encoding 或數值化處理。
                                    </p>
                                </div>
                                <div>
                                    <label for="nnHiddenUnits" class="block text-sm font-medium text-gray-700">隱藏層神經元數
                                        (Hidden Units)</label>
                                    <input type="number" id="nnHiddenUnits" value="8" min="1"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                    <p class="mt-2 text-xs text-gray-500">可先從 8~32 嘗試，再視效能調整。</p>
                                </div>
                                <div>
                                    <label for="nnEpochs" class="block text-sm font-medium text-gray-700">訓練迭代次數
                                        (Epochs)</label>
                                    <input type="number" id="nnEpochs" value="200" min="10"
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                    <p class="mt-2 text-xs text-gray-500">示範用途建議 100~300；實務應視資料量調整。</p>
                                </div>
                            </div>

                            <div class="mt-4">
                                <button id="runNNBtn"
                                    class="bg-purple-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-purple-700">
                                    執行神經網絡 (訓練 + Permutation Importance)
                                </button>
                            </div>

                            <div id="nnResults" class="mt-6 text-sm text-gray-700 space-y-3">
                                <p>此版本將在瀏覽器端使用 <strong>TensorFlow.js</strong> 訓練簡單的 MLP 模型，並計算 <strong>Permutation
                                        Importance</strong>，搭配 Plotly 長條圖展示特徵重要度。</p>
                            </div>

                            <div id="nnImportanceSummary" class="mt-4 text-sm text-gray-700"></div>
                            <div id="nnImportancePlot" class="mt-4"></div>

                            <!-- 新增：Learning Curve 與 Confusion Matrix -->
                            <div id="nnLearningCurve" class="mt-6"></div>
                            <div id="nnConfusionMatrix" class="mt-6"></div>
                        </div>

                        <!-- PCA Content -->
                        <div id="pcaContent" class="ml-tab-content mt-4 hidden">
                            <p class="text-gray-600 mb-4">主成分分析：降維、特徵提取、變數縮減，找出解釋最多變異的主要成分。</p>
                            <div class="space-y-4">
                                <div>
                                    <label for="pcaVariables"
                                        class="block text-sm font-medium text-gray-700">選擇變數（可多選）</label>
                                    <select id="pcaVariables" multiple
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
                                        style="height:120px;"></select>
                                    <p class="text-xs text-gray-500 mt-1">💡 按住 Ctrl (Win) 或 Cmd (Mac) 選擇多個變數</p>
                                </div>
                                <div>
                                    <label for="pcaNumComponents"
                                        class="block text-sm font-medium text-gray-700">主成分數量（留空則自動）</label>
                                    <input type="number" id="pcaNumComponents" min="1"
                                        class="mt-1 block w-48 rounded-md border-gray-300 shadow-sm"
                                        placeholder="自動選擇（特徵值>1）">
                                </div>
                                <div class="flex items-center">
                                    <input type="checkbox" id="pcaStandardize" checked
                                        class="rounded border-gray-300 text-indigo-600 mr-2">
                                    <label for="pcaStandardize" class="text-sm text-gray-700">標準化變數（建議）</label>
                                </div>
                                <button id="runPcaBtn"
                                    class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700">執行
                                    PCA 分析</button>
                            </div>
                            <div id="pcaResults" class="mt-6"></div>
                        </div>
                        <!-- Factor Analysis Content -->
                        <div id="factorAnalysisContent" class="ml-tab-content mt-4 hidden">
                            <p class="text-gray-600 mb-4">因素分析：找出潛在因子，解釋變數間的共同變異，適合量表編製和結構探索。</p>
                            <div class="space-y-4">
                                <div>
                                    <label for="faVariables"
                                        class="block text-sm font-medium text-gray-700">選擇變數（可多選）</label>
                                    <select id="faVariables" multiple
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
                                        style="height:120px;"></select>
                                    <p class="text-xs text-gray-500 mt-1">💡 按住 Ctrl (Win) 或 Cmd (Mac) 選擇多個變數</p>
                                </div>
                                <div>
                                    <label for="faNumFactors"
                                        class="block text-sm font-medium text-gray-700">因子數量（留空則自動）</label>
                                    <input type="number" id="faNumFactors" min="1"
                                        class="mt-1 block w-48 rounded-md border-gray-300 shadow-sm"
                                        placeholder="自動選擇（特徵值>1）">
                                </div>
                                <div class="flex items-center">
                                    <input type="checkbox" id="faRotation" checked
                                        class="rounded border-gray-300 text-pink-600 mr-2">
                                    <label for="faRotation" class="text-sm text-gray-700">Varimax 旋轉（建議）</label>
                                </div>
                                <button id="runFaBtn"
                                    class="bg-pink-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-pink-700">執行因素分析</button>
                            </div>
                            <div id="faResults" class="mt-6"></div>
                        </div>
                        <!-- K-Means Clustering Content -->
                        <div id="kmeansContent" class="ml-tab-content mt-4 hidden">
                            <p class="text-gray-600 mb-4">K-Means 集群分析：將資料點依相似性分成 K 個群組,適用於客戶分群、市場區隔、異常偵測等應用。</p>
                            <div class="bg-purple-50 p-4 rounded-lg mb-4">
                                <h4 class="font-semibold text-purple-900 mb-2">🎯 應用場景</h4>
                                <ul class="text-sm text-purple-800 space-y-1">
                                    <li>• 客戶分群(RFM分析)</li>
                                    <li>• 產品定位與市場區隔</li>
                                    <li>• 庫存管理優化</li>
                                    <li>• 異常值偵測</li>
                                </ul>
                            </div>
                            <div class="space-y-4">
                                <div>
                                    <label for="kmeansVariables"
                                        class="block text-sm font-medium text-gray-700">選擇數值變數（可多選，建議2-5個）</label>
                                    <select id="kmeansVariables" multiple
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
                                        style="height:120px;"></select>
                                    <p class="text-xs text-gray-500 mt-1">💡 按住 Ctrl (Win) 或 Cmd (Mac) 選擇多個變數</p>
                                </div>
                                <div class="grid md:grid-cols-3 gap-4">
                                    <div>
                                        <label for="kmeansK" class="block text-sm font-medium text-gray-700">集群數量
                                            (K)</label>
                                        <input type="number" id="kmeansK" value="3" min="2" max="10"
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                        <p class="text-xs text-gray-500 mt-1">建議先用Elbow法找最佳K值</p>
                                    </div>
                                    <div>
                                        <label for="kmeansMaxIter"
                                            class="block text-sm font-medium text-gray-700">最大迭代次數</label>
                                        <input type="number" id="kmeansMaxIter" value="100" min="10"
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                    </div>
                                    <div class="flex items-end">
                                        <div class="flex items-center mb-2">
                                            <input type="checkbox" id="kmeansStandardize" checked
                                                class="rounded border-gray-300 text-green-600 mr-2">
                                            <label for="kmeansStandardize"
                                                class="text-sm text-gray-700">標準化變數（建議）</label>
                                        </div>
                                    </div>
                                </div>
                                <div class="flex space-x-3">
                                    <button id="runKmeansElbowBtn"
                                        class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700">🔍
                                        Elbow 法找最佳 K</button>
                                    <button id="runKmeansBtn"
                                        class="bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700">執行
                                        K-Means 集群</button>
                                </div>
                            </div>
                            <div id="kmeansResults" class="mt-6"></div>
                        </div>

                        <!-- Hierarchical Clustering Content -->
                        <div id="hierarchicalContent" class="ml-tab-content mt-4 hidden">
                            <p class="text-gray-600 mb-4">
                                階層式集群 (Hierarchical Clustering)：適用於 <strong>&lt; 1000 筆樣本</strong> 的分群分析，支援數值 / 類別 /
                                混合資料。
                                可用於客戶分群、問卷分群、產品組合分析等情境。
                            </p>

                            <div class="bg-purple-50 p-4 rounded-lg mb-4">
                                <h4 class="font-semibold text-purple-900 mb-2">📐 功能重點</h4>
                                <ul class="text-sm text-purple-800 space-y-1">
                                    <li>• 支援數值、類別與混合型資料 (Gower 距離)</li>
                                    <li>• 多種連結方法：Ward、Complete、Single、Average、Centroid</li>
                                    <li>• 互動式樹狀圖 + 動態切割線 (拖曳群集數)</li>
                                    <li>• 集群著色熱圖 + 輪廓係數 (Silhouette) 評估圖</li>
                                </ul>
                            </div>

                            <!-- 變數選擇與距離設定 -->
                            <div class="space-y-4">
                                <div>
                                    <label for="hierVariables" class="block text-sm font-medium text-gray-700">
                                        選擇用於分群的變數（可多選，支援數值 + 類別）
                                    </label>
                                    <select id="hierVariables" multiple
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
                                        style="height:140px;"></select>
                                    <p class="text-xs text-gray-500 mt-1">💡 建議 2–6 個變數，樣本 &lt; 1000 筆，以維持瀏覽器流暢度。</p>
                                </div>

                                <div class="grid md:grid-cols-3 gap-4">
                                    <div>
                                        <label for="hierDistanceMetric" class="block text-sm font-medium text-gray-700">
                                            距離計算方法
                                        </label>
                                        <select id="hierDistanceMetric"
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                            <option value="auto">自動依變數型態選擇</option>
                                            <option value="euclidean">Euclidean (數值)</option>
                                            <option value="manhattan">Manhattan (數值)</option>
                                            <option value="minkowski">Minkowski (數值)</option>
                                            <option value="hamming">Hamming (類別)</option>
                                            <option value="jaccard">Jaccard (類別)</option>
                                            <option value="gower">Gower (混合資料建議)</option>
                                        </select>
                                        <p class="text-xs text-gray-500 mt-1">
                                            🔎 若混合數值 + 類別，系統會自動改用 Gower 距離。
                                        </p>
                                    </div>

                                    <div>
                                        <label for="hierMinkowskiP" class="block text-sm font-medium text-gray-700">
                                            Minkowski 次方 p（僅 Minkowski 有效）
                                        </label>
                                        <input type="number" id="hierMinkowskiP" value="3" min="1" step="0.5"
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                        <p class="text-xs text-gray-500 mt-1">
                                            預設 p = 3。p=2 相當於 Euclidean，p=1 為 Manhattan。
                                        </p>
                                    </div>

                                    <div>
                                        <label for="hierLinkage" class="block text-sm font-medium text-gray-700">
                                            連結方法 (Linkage)
                                        </label>
                                        <select id="hierLinkage"
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                            <option value="ward">Ward's Method（最小變異，預設，需數值 + Euclidean）</option>
                                            <option value="complete">Complete Linkage（最遠鄰）</option>
                                            <option value="single">Single Linkage（最近鄰）</option>
                                            <option value="average">Average Linkage（平均連結）</option>
                                            <option value="centroid">Centroid Method（重心法，需數值 + Euclidean）</option>
                                        </select>
                                        <p class="text-xs text-gray-500 mt-1">
                                            ⚠️ Ward / Centroid 僅在「全部為數值變數且距離為 Euclidean」時啟用，否則自動改為 Average。
                                        </p>
                                    </div>
                                </div>

                                <div class="flex space-x-3">
                                    <button id="runHierarchicalBtn"
                                        class="bg-emerald-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-emerald-700">
                                        執行階層式集群
                                    </button>
                                    <p id="hierMessage" class="text-xs text-gray-500 self-center"></p>
                                </div>
                            </div>

                            <!-- 群集數調整（動態切割線） -->
                            <div id="hierClusterSection"
                                class="mt-6 hidden bg-gray-50 p-4 rounded-lg border border-gray-200">
                                <div class="flex items-center space-x-4">
                                    <div class="flex-1">
                                        <label for="hierClusterCount" class="block text-sm font-medium text-gray-700">
                                            群集數 (K) – 拖曳以切割樹狀圖
                                        </label>
                                        <input type="range" id="hierClusterCount" min="2" max="10" value="3"
                                            class="w-full">
                                    </div>
                                    <div class="w-20 text-center">
                                        <span class="text-sm text-gray-500">目前 K：</span>
                                        <span id="hierClusterCountLabel"
                                            class="text-lg font-semibold text-emerald-700">3</span>
                                    </div>
                                </div>
                                <p class="text-xs text-gray-500 mt-1">
                                    系統會依 K 值在樹狀圖上畫出切割線，同時更新熱圖與輪廓係數圖。
                                </p>
                            </div>

                            <!-- 結果視覺化區 -->
                            <div class="mt-6 space-y-6">
                                <div>
                                    <h4 class="font-semibold mb-2">🌳 互動式樹狀圖 (Dendrogram)</h4>
                                    <div id="hierDendrogram"></div>
                                </div>
                                <div>
                                    <h4 class="font-semibold mb-2">🔥 集群著色熱圖</h4>
                                    <div id="hierHeatmap"></div>
                                </div>
                                <div>
                                    <h4 class="font-semibold mb-2">📈 輪廓係數 (Silhouette) 評估圖</h4>
                                    <div id="hierSilhouette"></div>
                                </div>
                            </div>
                        </div>
                        <!-- Apriori Association Rules Content -->
                        <div id="aprioriContent" class="ml-tab-content mt-4 hidden">
                            <p class="text-gray-600 mb-4">關聯規則挖掘 (Apriori Algorithm)：發現交易資料中商品之間的關聯性，適用於購物籃分析、交叉銷售策略。
                            </p>
                            <div class="bg-purple-50 p-4 rounded-lg mb-4">
                                <h4 class="font-semibold text-purple-900 mb-2">🛒 經典案例</h4>
                                <ul class="text-sm text-purple-800 space-y-1">
                                    <li>• 啤酒 🍺 → 尿布 👶 (週五晚上購物關聯)</li>
                                    <li>• 筆記型電腦 💻 → 滑鼠 🖱️ + 滑鼠墊</li>
                                    <li>• 麵包 🍞 → 牛奶 🥛 + 果醬</li>
                                </ul>
                            </div>
                            <div class="space-y-4">
                                <div class="grid md:grid-cols-2 gap-4">
                                    <div>
                                        <label for="aprioriTransactionId"
                                            class="block text-sm font-medium text-gray-700">選擇交易ID欄位</label>
                                        <select id="aprioriTransactionId"
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                        <p class="text-xs text-gray-500 mt-1">用於區分不同交易</p>
                                    </div>
                                    <div>
                                        <label for="aprioriItemName"
                                            class="block text-sm font-medium text-gray-700">選擇商品名稱欄位</label>
                                        <select id="aprioriItemName"
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></select>
                                        <p class="text-xs text-gray-500 mt-1">商品或項目名稱</p>
                                    </div>
                                </div>
                                <div class="grid md:grid-cols-3 gap-4">
                                    <div>
                                        <label for="aprioriMinSupport"
                                            class="block text-sm font-medium text-gray-700">最小支持度 (Min Support)</label>
                                        <input type="number" id="aprioriMinSupport" value="0.01" step="0.01" min="0.01"
                                            max="1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                        <p class="text-xs text-gray-500 mt-1">預設 0.01 (1%)</p>
                                    </div>
                                    <div>
                                        <label for="aprioriMinConfidence"
                                            class="block text-sm font-medium text-gray-700">最小信賴度 (Min
                                            Confidence)</label>
                                        <input type="number" id="aprioriMinConfidence" value="0" step="0.05" min="0"
                                            max="1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                        <p class="text-xs text-gray-500 mt-1">預設 0 (顯示所有規則)</p>
                                    </div>
                                    <div>
                                        <label for="aprioriMinLift"
                                            class="block text-sm font-medium text-gray-700">最小提升度 (Min Lift)</label>
                                        <input type="number" id="aprioriMinLift" value="0" step="0.1" min="0"
                                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                                        <p class="text-xs text-gray-500 mt-1">預設 0 (顯示所有規則)</p>
                                    </div>
                                </div>
                                <details class="bg-gray-50 p-3 rounded">
                                    <summary class="cursor-pointer text-sm font-medium text-gray-700">❓ 參數說明</summary>
                                    <div class="mt-2 text-sm text-gray-600 space-y-2">
                                        <p><strong>Support (支持度)</strong>: 項目組合在所有交易中出現的比例</p>
                                        <p><strong>Confidence (信賴度)</strong>: 買了A之後買B的條件機率</p>
                                        <p><strong>Lift (提升度)</strong>: 關聯強度，>1表示正相關，=1表示獨立，<1表示負相關< /p>
                                    </div>
                                </details>
                                <button id="runAprioriBtn"
                                    class="bg-purple-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-purple-700">執行關聯規則挖掘</button>
                            </div>
                            <div id="aprioriResults" class="mt-6"></div>
                        </div>


                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // --- Global Variables & DOM References ---
        let jsonData = [], headers = [], numericHeaders = [], categoricalHeaders = [];
        let currentWorkbook = null;
        let logisticModel = null;
        let hierarchicalState = null;   // 新增：階層式集群狀態
        let currentInputMode = "file";  // 資料輸入方式：file 或 paste

        // --- Event Listeners Setup ---

        // ═══════════════════════════════════════════════════════════════
        // 隨機森林 (Random Forest) 核心實作
        // ═══════════════════════════════════════════════════════════════

        // ═══════════════════════════════════════════════════════════════
        // 隨機森林 (Random Forest) 核心實作
        // 支援分類 (Classification) 和迴歸 (Regression)
        // ═══════════════════════════════════════════════════════════════

        /**
         * Bootstrap 採樣 - 從原始數據中隨機抽取樣本(允許重複)
         * @param {Array} data - 原始數據陣列
         * @param {number} sampleSize - 採樣數量（預設為原始數據大小）
         * @returns {Object} { sample: 採樣數據, oobIndices: OOB樣本索引 }
         */
        function bootstrapSample(data, sampleSize = data.length) {
            const sample = [];
            const usedIndices = new Set();

            for (let i = 0; i < sampleSize; i++) {
                const randomIndex = Math.floor(Math.random() * data.length);
                sample.push(data[randomIndex]);
                usedIndices.add(randomIndex);
            }

            // Out-of-Bag (OOB) 樣本：未被抽到的樣本索引
            const oobIndices = [];
            for (let i = 0; i < data.length; i++) {
                if (!usedIndices.has(i)) {
                    oobIndices.push(i);
                }
            }

            return { sample, oobIndices };
        }

        /**
         * 特徵隨機選擇 - 從所有特徵中隨機選取子集
         * @param {number} totalFeatures - 總特徵數
         * @param {string} method - 選擇方法 ('sqrt' | 'log2' | 'all' | number)
         * @returns {Array} 選中的特徵索引陣列
         */
        function randomFeatureSelection(totalFeatures, method = 'sqrt') {
            let numFeatures;

            if (typeof method === 'number') {
                numFeatures = Math.min(method, totalFeatures);
            } else if (method === 'sqrt') {
                numFeatures = Math.floor(Math.sqrt(totalFeatures));
            } else if (method === 'log2') {
                numFeatures = Math.floor(Math.log2(totalFeatures)) + 1;
            } else {
                numFeatures = totalFeatures; // 'all'
            }

            // 隨機選擇特徵
            const allIndices = Array.from({ length: totalFeatures }, (_, i) => i);
            const shuffled = allIndices.sort(() => Math.random() - 0.5);
            return shuffled.slice(0, numFeatures);
        }

        /**
         * 訓練單棵決策樹（迴歸）
         * @param {Array} X - 特徵矩陣
         * @param {Array} y - 目標變數
         * @param {Object} options - 樹的參數
         * @returns {Object} 訓練好的樹模型
         */
        function trainSingleRegressionTree(X, y, options) {
            const tree = new ML.DecisionTreeRegression(options);
            tree.train(X, y);
            return tree;
        }

        /**
         * 訓練單棵決策樹（分類）- 使用迴歸樹近似
         * @param {Array} X - 特徵矩陣
         * @param {Array} y - 目標變數（數值編碼的類別）
         * @param {Object} options - 樹的參數
         * @returns {Object} 訓練好的樹模型
         */
        function trainSingleClassificationTree(X, y, options) {
            // ml.js 沒有內建分類樹，使用迴歸樹 + 四捨五入近似
            const tree = new ML.DecisionTreeRegression(options);
            tree.train(X, y);
            return tree;
        }

        /**
         * 隨機森林訓練（迴歸版本）
         * @param {Array} X - 完整特徵矩陣 [n_samples x n_features]
         * @param {Array} y - 完整目標變數 [n_samples]
         * @param {Object} params - 隨機森林參數
         * @returns {Object} 訓練好的隨機森林模型
         */
        function trainRandomForestRegressor(X, y, params = {}) {
            const {
                nTrees = 100,
                maxDepth = 10,
                minSamplesLeaf = 5,
                featureSubsetMethod = 'sqrt',
                progressCallback = null
            } = params;

            const n = X.length;
            const m = X[0].length;
            const trees = [];
            const oobSamples = []; // 儲存每棵樹的OOB樣本

            console.log(`🌲 開始訓練隨機森林迴歸器：${nTrees}棵樹，${m}個特徵`);

            for (let t = 0; t < nTrees; t++) {
                // 1. Bootstrap 採樣
                const indices = Array.from({ length: n }, (_, i) => i);
                const { sample: sampledIndices, oobIndices } = bootstrapSample(indices);

                const X_sample = sampledIndices.map(idx => X[idx]);
                const y_sample = sampledIndices.map(idx => y[idx]);

                // 2. 特徵隨機選擇
                const selectedFeatures = randomFeatureSelection(m, featureSubsetMethod);
                const X_subset = X_sample.map(row => selectedFeatures.map(i => row[i]));

                // 3. 訓練決策樹
                const treeOptions = { maxDepth, minNumSamples: minSamplesLeaf };
                const tree = trainSingleRegressionTree(X_subset, y_sample, treeOptions);

                trees.push({
                    model: tree,
                    selectedFeatures,
                    oobIndices
                });

                oobSamples.push(oobIndices);

                // 進度回調
                if (progressCallback && (t + 1) % 10 === 0) {
                    progressCallback(t + 1, nTrees);
                }
            }

            console.log(`✅ 隨機森林訓練完成！共 ${trees.length} 棵樹`);

            return {
                trees,
                nTrees,
                nFeatures: m,
                type: 'regression',
                oobSamples
            };
        }

        /**
         * 隨機森林訓練（分類版本）
         * @param {Array} X - 完整特徵矩陣
         * @param {Array} y - 完整目標變數（數值編碼）
         * @param {Object} params - 隨機森林參數
         * @returns {Object} 訓練好的隨機森林模型
         */
        function trainRandomForestClassifier(X, y, params = {}) {
            const {
                nTrees = 100,
                maxDepth = 10,
                minSamplesLeaf = 5,
                featureSubsetMethod = 'sqrt',
                progressCallback = null
            } = params;

            const n = X.length;
            const m = X[0].length;
            const trees = [];
            const oobSamples = [];

            console.log(`🌲 開始訓練隨機森林分類器：${nTrees}棵樹，${m}個特徵`);

            for (let t = 0; t < nTrees; t++) {
                const indices = Array.from({ length: n }, (_, i) => i);
                const { sample: sampledIndices, oobIndices } = bootstrapSample(indices);

                const X_sample = sampledIndices.map(idx => X[idx]);
                const y_sample = sampledIndices.map(idx => y[idx]);

                const selectedFeatures = randomFeatureSelection(m, featureSubsetMethod);
                const X_subset = X_sample.map(row => selectedFeatures.map(i => row[i]));

                const treeOptions = { maxDepth, minNumSamples: minSamplesLeaf };
                const tree = trainSingleClassificationTree(X_subset, y_sample, treeOptions);

                trees.push({
                    model: tree,
                    selectedFeatures,
                    oobIndices
                });

                oobSamples.push(oobIndices);

                if (progressCallback && (t + 1) % 10 === 0) {
                    progressCallback(t + 1, nTrees);
                }
            }

            console.log(`✅ 隨機森林訓練完成！共 ${trees.length} 棵樹`);

            return {
                trees,
                nTrees,
                nFeatures: m,
                type: 'classification',
                oobSamples,
                uniqueClasses: [...new Set(y)]
            };
        }

        /**
         * 隨機森林預測（迴歸）
         * @param {Object} forest - 訓練好的森林模型
         * @param {Array} X_test - 測試特徵矩陣
         * @returns {Array} 預測值
         */
        function predictRandomForestRegressor(forest, X_test) {
            const predictions = X_test.map(sample => {
                const treePredictions = forest.trees.map(treeObj => {
                    const { model, selectedFeatures } = treeObj;
                    const subset = selectedFeatures.map(i => sample[i]);
                    return model.predict([subset])[0];
                });

                // 平均所有樹的預測
                return treePredictions.reduce((a, b) => a + b, 0) / treePredictions.length;
            });

            return predictions;
        }

        /**
         * 隨機森林預測（分類）
         * @param {Object} forest - 訓練好的森林模型
         * @param {Array} X_test - 測試特徵矩陣
         * @returns {Array} 預測類別
         */
        function predictRandomForestClassifier(forest, X_test) {
            const predictions = X_test.map(sample => {
                const treePredictions = forest.trees.map(treeObj => {
                    const { model, selectedFeatures } = treeObj;
                    const subset = selectedFeatures.map(i => sample[i]);
                    const pred = model.predict([subset])[0];
                    return Math.round(pred); // 四捨五入到最近的類別
                });

                // 投票：找出出現最多次的類別
                const counts = {};
                treePredictions.forEach(p => {
                    counts[p] = (counts[p] || 0) + 1;
                });

                let maxCount = 0;
                let majorityClass = treePredictions[0];
                for (const [cls, count] of Object.entries(counts)) {
                    if (count > maxCount) {
                        maxCount = count;
                        majorityClass = parseInt(cls);
                    }
                }

                return majorityClass;
            });

            return predictions;
        }

        /**
         * 計算 OOB 誤差（迴歸）
         * @param {Object} forest - 訓練好的森林模型
         * @param {Array} X - 原始訓練特徵矩陣
         * @param {Array} y - 原始訓練目標變數
         * @returns {Object} OOB誤差統計
         */
        function calculateOOBErrorRegression(forest, X, y) {
            const n = X.length;
            const oobPredictions = new Array(n).fill(null);
            const oobCounts = new Array(n).fill(0);

            // 對每個樣本，用未抽到該樣本的樹進行預測
            forest.trees.forEach(treeObj => {
                const { model, selectedFeatures, oobIndices } = treeObj;

                oobIndices.forEach(idx => {
                    const subset = selectedFeatures.map(i => X[idx][i]);
                    const pred = model.predict([subset])[0];

                    if (oobPredictions[idx] === null) {
                        oobPredictions[idx] = pred;
                    } else {
                        oobPredictions[idx] += pred;
                    }
                    oobCounts[idx]++;
                });
            });

            // 平均OOB預測
            const finalOOBPredictions = oobPredictions.map((sum, idx) =>
                oobCounts[idx] > 0 ? sum / oobCounts[idx] : null
            );

            // 計算誤差
            let sumSquaredError = 0;
            let validCount = 0;

            for (let i = 0; i < n; i++) {
                if (finalOOBPredictions[i] !== null) {
                    const error = y[i] - finalOOBPredictions[i];
                    sumSquaredError += error * error;
                    validCount++;
                }
            }

            const oobMSE = validCount > 0 ? sumSquaredError / validCount : null;
            const oobRMSE = oobMSE !== null ? Math.sqrt(oobMSE) : null;

            return {
                oobMSE,
                oobRMSE,
                oobPredictions: finalOOBPredictions,
                oobCoverage: validCount / n
            };
        }

        /**
         * 計算特徵重要性（基於所有樹的平均）
         * @param {Object} forest - 訓練好的森林模型
         * @param {Array} featureNames - 特徵名稱
         * @returns {Array} 特徵重要性陣列
         */
        function calculateFeatureImportance(forest, featureNames) {
            const m = forest.nFeatures;
            const importanceSum = new Array(m).fill(0);
            const importanceCount = new Array(m).fill(0);

            forest.trees.forEach(treeObj => {
                const { model, selectedFeatures } = treeObj;
                const treeJSON = model.toJSON();

                // 使用現有的 calculateDtImportance 函數
                const treeImportances = calculateDtImportance(treeJSON, selectedFeatures.length);

                // 映射回原始特徵索引
                treeImportances.forEach((imp, localIdx) => {
                    const globalIdx = selectedFeatures[localIdx];
                    importanceSum[globalIdx] += imp;
                    importanceCount[globalIdx]++;
                });
            });

            // 平均並標準化
            const importances = importanceSum.map((sum, idx) =>
                importanceCount[idx] > 0 ? sum / importanceCount[idx] : 0
            );

            const total = importances.reduce((a, b) => a + b, 0);
            const normalized = total > 0 ? importances.map(x => x / total) : importances;

            return normalized.map((imp, idx) => ({
                feature: featureNames[idx],
                importance: imp,
                index: idx
            })).sort((a, b) => b.importance - a.importance);
        }

        /**
         * 計算迴歸評估指標
         * @param {Array} yTrue - 真實值
         * @param {Array} yPred - 預測值
         * @returns {Object} 評估指標
         */
        function calculateRegressionMetrics(yTrue, yPred) {
            const n = yTrue.length;
            const mean = yTrue.reduce((a, b) => a + b, 0) / n;

            let sst = 0, sse = 0, sae = 0;
            let mape_sum = 0;

            for (let i = 0; i < n; i++) {
                const error = yTrue[i] - yPred[i];
                sse += error * error;
                sae += Math.abs(error);
                sst += (yTrue[i] - mean) ** 2;
                if (yTrue[i] !== 0) {
                    mape_sum += Math.abs(error / yTrue[i]);
                }
            }

            const r2 = sst > 0 ? 1 - (sse / sst) : 0;
            const mse = sse / n;
            const rmse = Math.sqrt(mse);
            const mae = sae / n;
            const mape = (mape_sum / n) * 100;

            return { r2, mse, rmse, mae, mape };
        }

        /**
         * 計算混淆矩陣
         * @param {Array} yTrue - 真實類別
         * @param {Array} yPred - 預測類別
         * @param {Array} classes - 所有類別
         * @returns {Object} 混淆矩陣和統計
         */
        function calculateConfusionMatrix(yTrue, yPred, classes) {
            const n = classes.length;
            const matrix = Array(n).fill(0).map(() => Array(n).fill(0));

            for (let i = 0; i < yTrue.length; i++) {
                const trueIdx = classes.indexOf(yTrue[i]);
                const predIdx = classes.indexOf(yPred[i]);
                if (trueIdx >= 0 && predIdx >= 0) {
                    matrix[trueIdx][predIdx]++;
                }
            }

            // 計算準確度、精確度、召回率
            let totalCorrect = 0;
            const classMetrics = classes.map((cls, idx) => {
                const tp = matrix[idx][idx];
                const fp = matrix.map((row, i) => i !== idx ? row[idx] : 0).reduce((a, b) => a + b, 0);
                const fn = matrix[idx].reduce((a, b, i) => i !== idx ? a + b : a, 0);
                const tn = matrix.map((row, i) => i !== idx ? row.reduce((a, b, j) => j !== idx ? a + b : a, 0) : 0).reduce((a, b) => a + b, 0);

                totalCorrect += tp;

                const precision = (tp + fp) > 0 ? tp / (tp + fp) : 0;
                const recall = (tp + fn) > 0 ? tp / (tp + fn) : 0;
                const f1 = (precision + recall) > 0 ? 2 * precision * recall / (precision + recall) : 0;

                return { class: cls, precision, recall, f1 };
            });

            const accuracy = totalCorrect / yTrue.length;

            return { matrix, accuracy, classMetrics };
        }




        // ═══════════════════════════════════════════════════════════════
        // 隨機森林主函數實作
        // ═══════════════════════════════════════════════════════════════

        // ═══════════════════════════════════════════════════════════════
        // 隨機森林主函數實作 - 迴歸 & 分類
        // ═══════════════════════════════════════════════════════════════

        /**
         * 執行隨機森林迴歸分析
         */
        function runRandomForestRegression() {
            const yVar = document.getElementById('rfRegY').value;
            const rawXVars = Array.from(document.getElementById('rfRegX').selectedOptions).map(opt => opt.value);

            // Check for overlap
            if (rawXVars.includes(yVar)) {
                alert(`錯誤：目標變數 (Y) "${yVar}" 不能同時作為特徵變數 (X)。請從特徵變數中移除它。`);
                return;
            }

            // 避免 Y 與 X 重複，並移除重複的 X 欄位
            const xVars = [...new Set(rawXVars.filter(v => v !== yVar))];
            const nTrees = parseInt(document.getElementById('rfRegNTrees').value);
            const maxDepth = parseInt(document.getElementById('rfRegMaxDepth').value);
            const minSamples = parseInt(document.getElementById('rfRegMinSamples').value);
            const featureMethod = document.getElementById('rfRegFeatureMethod').value;

            const resultsDiv = document.getElementById('rfRegressionResults');
            const progressSpan = document.getElementById('rfRegProgress');

            resultsDiv.innerHTML = '';
            progressSpan.textContent = '';

            // 驗證輸入
            if (!yVar || xVars.length === 0) {
                resultsDiv.innerHTML = `<p class="text-red-600">請選擇應變數 (Y) 和至少一個自變數 (X)。</p>`;
                return;
            }

            if (xVars.length > 50) {
                resultsDiv.innerHTML = `<p class="text-red-600">自變數超過 50 個，建議精簡特徵以提升效率。</p>`;
                return;
            }

            // 準備數據（類別編碼）
            const encoders = {};
            xVars.forEach(header => {
                if (categoricalHeaders.includes(header)) {
                    const uniqueValues = [...new Set(jsonData.map(row => row[header]).filter(v => v != null))];
                    encoders[header] = {};
                    uniqueValues.forEach((val, i) => { encoders[header][val] = i; });
                }
            });

            const X = [], y = [];
            for (const row of jsonData) {
                let isValidRow = true;
                const featureRow = [];

                for (const xVar of xVars) {
                    const val = row[xVar];
                    if (val == null) { isValidRow = false; break; }
                    featureRow.push(categoricalHeaders.includes(xVar) ? encoders[xVar][val] : val);
                }

                const yVal = row[yVar];
                if (yVal == null || typeof yVal !== 'number') isValidRow = false;

                if (isValidRow) {
                    X.push(featureRow);
                    y.push(yVal);
                }
            }

            if (X.length < 40) {
                resultsDiv.innerHTML = `<p class="text-red-600">有效資料列不足 (${X.length} 筆)，隨機森林建議至少 40 筆樣本。</p>`;
                return;
            }

            // 顯示載入指示
            resultsDiv.innerHTML = `<div class="loader"></div><p class="text-center text-gray-600 mt-2">正在訓練 ${nTrees} 棵決策樹...</p>`;

            // Calculate feature means for default values in prediction
            const featureMeans = xVars.map((xVar, i) => {
                if (categoricalHeaders.includes(xVar)) {
                    return null; // categorical - use first option
                } else {
                    const sum = X.reduce((acc, row) => acc + row[i], 0);
                    return sum / X.length;
                }
            });

            // 延遲執行以更新 UI
            setTimeout(() => {
                try {
                    // 訓練隨機森林
                    const forest = trainRandomForestRegressor(X, y, {
                        nTrees,
                        maxDepth,
                        minSamplesLeaf: minSamples,
                        featureSubsetMethod: featureMethod,
                        progressCallback: (current, total) => {
                            progressSpan.textContent = `訓練進度：${current}/${total} 棵樹`;
                        }
                    });

                    progressSpan.textContent = '✅ 訓練完成！正在評估...';

                    // 預測訓練集
                    const yPred = predictRandomForestRegressor(forest, X);

                    // 計算評估指標
                    const metrics = calculateRegressionMetrics(y, yPred);

                    // 計算 OOB 誤差
                    const oobStats = calculateOOBErrorRegression(forest, X, y);

                    // 計算特徵重要性
                    const importances = calculateFeatureImportance(forest, xVars);

                    // 生成結果 HTML
                    let html = `
                <div class="bg-white p-6 rounded-lg border shadow-sm">
                    <h3 class="text-xl font-bold mb-4 text-green-700">🌲 隨機森林迴歸模型結果</h3>
                    
                    <!-- 模型摘要 -->
                    <div class="grid md:grid-cols-2 gap-4 mb-6">
                        <div class="bg-gray-50 p-4 rounded">
                            <h4 class="font-semibold mb-2">📊 模型配置</h4>
                            <ul class="text-sm space-y-1">
                                <li>• 樹的數量：${nTrees} 棵</li>
                                <li>• 最大深度：${maxDepth} 層</li>
                                <li>• 訓練樣本：${X.length} 筆</li>
                                <li>• 特徵數量：${xVars.length} 個</li>
                            </ul>
                        </div>
                        <div class="bg-green-50 p-4 rounded">
                            <h4 class="font-semibold mb-2">📈 預測效能（訓練集）</h4>
                            <ul class="text-sm space-y-1">
                                <li>• <strong>R² 決定係數</strong>：${metrics.r2.toFixed(4)} ${metrics.r2 > 0.8 ? '✅ 優秀' : metrics.r2 > 0.6 ? '⚠️ 良好' : '❌ 需改進'}</li>
                                <li>• <strong>RMSE</strong>：${metrics.rmse.toFixed(4)}</li>
                                <li>• <strong>MAE</strong>：${metrics.mae.toFixed(4)}</li>
                                <li>• <strong>MAPE</strong>：${metrics.mape.toFixed(2)}%</li>
                            </ul>
                        </div>
                    </div>
                    
                    <!-- OOB 評估 -->
                    <div class="bg-blue-50 p-4 rounded mb-6">
                        <h4 class="font-semibold mb-2">🎯 Out-of-Bag (OOB) 評估</h4>
                        <p class="text-sm text-gray-700 mb-2">OOB 評估使用未參與訓練的樣本預測，更接近真實泛化能力。</p>
                        <ul class="text-sm space-y-1">
                            <li>• <strong>OOB RMSE</strong>：${oobStats.oobRMSE ? oobStats.oobRMSE.toFixed(4) : 'N/A'}</li>
                            <li>• <strong>OOB 覆蓋率</strong>：${(oobStats.oobCoverage * 100).toFixed(1)}%</li>
                        </ul>
                    </div>
                    
                    <!-- 特徵重要性 -->
                    <div class="mb-6">
                        <h4 class="font-semibold mb-3">🔑 變數重要性排名（適合 DOE 分析）</h4>
                        <div id="rfRegImportancePlot"></div>
                        <div class="overflow-x-auto mt-4">
                            <table class="min-w-full divide-y divide-gray-200 border">
                                <thead class="bg-gray-50">
                                    <tr>
                                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">排名</th>
                                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">變數</th>
                                        <th class="px-4 py-2 text-right text-xs font-medium text-gray-500 uppercase">重要性</th>
                                        <th class="px-4 py-2 text-right text-xs font-medium text-gray-500 uppercase">百分比</th>
                                    </tr>
                                </thead>
                                <tbody class="bg-white divide-y divide-gray-200">
            `;

                    importances.forEach((imp, idx) => {
                        const percentage = (imp.importance * 100).toFixed(2);
                        const barWidth = imp.importance * 200; // 視覺化長條
                        html += `
                    <tr>
                        <td class="px-4 py-2 text-sm text-gray-900">${idx + 1}</td>
                        <td class="px-4 py-2 text-sm font-medium text-gray-900">${imp.feature}</td>
                        <td class="px-4 py-2 text-sm text-right text-gray-500">${imp.importance.toFixed(4)}</td>
                        <td class="px-4 py-2 text-sm text-right">
                            <div class="flex items-center justify-end">
                                <div class="w-20 bg-gray-200 rounded-full h-2 mr-2">
                                    <div class="bg-green-600 h-2 rounded-full" style="width: ${barWidth}px"></div>
                                </div>
                                <span class="text-gray-600">${percentage}%</span>
                            </div>
                        </td>
                    </tr>
                `;
                    });

                    html += `
                                </tbody>
                            </table>
                        </div>
                        <p class="text-xs text-gray-500 mt-3">💡 重要性越高，表示該變數對預測結果的影響越大（基於所有樹的平均貢獻度）</p>
                    </div>
                    
                    <!-- 實際 vs 預測散點圖 -->
                    <div class="mb-6">
                        <h4 class="font-semibold mb-3">📊 實際值 vs 預測值</h4>
                        <div id="rfRegScatterPlot"></div>
                    </div>
                    
                    <!-- 殘差圖 -->
                    <div>
                        <h4 class="font-semibold mb-3">📉 殘差分析</h4>
                        <div id="rfRegResidualPlot"></div>
                        <p class="text-xs text-gray-500 mt-2">💡 殘差應隨機分布在零線附近，無明顯模式</p>
                    </div>

                    <!-- Prediction Section -->
                    <div class="mt-6 p-4 bg-gray-50 rounded border border-gray-200">
                        <h4 class="text-md font-semibold mb-3">🔮 模型預測 (Prediction)</h4>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4" id="rfRegPredictionInputs">
                            ${xVars.map((xVar, i) => {
                        if (categoricalHeaders.includes(xVar)) {
                            const options = Object.keys(encoders[xVar]).map(c => `<option value="${c}">${c}</option>`).join('');
                            return `
                                        <div>
                                            <label class="block text-sm font-medium text-gray-700 mb-1">${xVar}</label>
                                            <select id="rf_reg_pred_input_${i}" class="w-full p-2 border rounded">
                                                ${options}
                                            </select>
                                        </div>
                                    `;
                        } else {
                            const defaultVal = featureMeans[i] !== null ? featureMeans[i].toFixed(2) : '';
                            return `
                                        <div>
                                            <label class="block text-sm font-medium text-gray-700 mb-1">${xVar}</label>
                                            <input type="number" step="any" id="rf_reg_pred_input_${i}" value="${defaultVal}" class="w-full p-2 border rounded" placeholder="輸入數值">
                                            <span class="text-xs text-gray-400">平均值: ${defaultVal}</span>
                                        </div>
                                    `;
                        }
                    }).join('')}
                        </div>
                        <button id="btnPredictRFReg" class="mt-4 px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 transition">
                            進行預測
                        </button>
                        <div id="rfRegPredictionResult" class="mt-4 hidden p-3 bg-white border rounded"></div>
                    </div>
                </div>
            `;

                    resultsDiv.innerHTML = html;
                    progressSpan.textContent = '';

                    // Bind Prediction Event
                    document.getElementById('btnPredictRFReg').addEventListener('click', () => {
                        const resultDiv = document.getElementById('rfRegPredictionResult');
                        resultDiv.classList.remove('hidden');

                        try {
                            const inputVector = [];
                            for (let i = 0; i < xVars.length; i++) {
                                const xVar = xVars[i];
                                const el = document.getElementById(`rf_reg_pred_input_${i}`);
                                const val = el.value;

                                if (categoricalHeaders.includes(xVar)) {
                                    if (!(val in encoders[xVar])) throw new Error(`無效的類別值：${xVar}`);
                                    inputVector.push(encoders[xVar][val]);
                                } else {
                                    const numVal = parseFloat(val);
                                    if (isNaN(numVal)) throw new Error(`請輸入有效的數值：${xVar}`);
                                    inputVector.push(numVal);
                                }
                            }

                            const pred = predictRandomForestRegressor(forest, [inputVector])[0];
                            resultDiv.innerHTML = `<p class="text-lg">預測結果 (${yVar})：<strong>${pred.toFixed(4)}</strong></p>`;
                        } catch (e) {
                            resultDiv.innerHTML = `<p class="text-red-600">錯誤：${e.message}</p>`;
                        }
                    });

                    // 繪製特徵重要性圖
                    const importanceTrace = {
                        x: importances.map(imp => imp.importance).reverse(),
                        y: importances.map(imp => imp.feature).reverse(),
                        type: 'bar',
                        orientation: 'h',
                        marker: { color: 'rgb(34, 197, 94)' }
                    };
                    Plotly.newPlot('rfRegImportancePlot', [importanceTrace], {
                        title: '變數重要性',
                        xaxis: { title: '重要性分數' },
                        margin: { l: 150 }
                    }, { responsive: true });

                    // 繪製散點圖
                    const scatterTrace = {
                        x: y,
                        y: yPred,
                        mode: 'markers',
                        type: 'scatter',
                        marker: { color: 'rgba(34, 197, 94, 0.6)', size: 6 },
                        name: '預測值'
                    };
                    const idealLine = {
                        x: [Math.min(...y), Math.max(...y)],
                        y: [Math.min(...y), Math.max(...y)],
                        mode: 'lines',
                        line: { color: 'red', dash: 'dash', width: 2 },
                        name: '理想預測'
                    };
                    Plotly.newPlot('rfRegScatterPlot', [scatterTrace, idealLine], {
                        title: `實際值 vs 預測值 (R² = ${metrics.r2.toFixed(3)})`,
                        xaxis: { title: `實際 ${yVar}` },
                        yaxis: { title: `預測 ${yVar}` }
                    }, { responsive: true });

                    // 繪製殘差圖
                    const residuals = y.map((actual, idx) => actual - yPred[idx]);
                    const residualTrace = {
                        x: yPred,
                        y: residuals,
                        mode: 'markers',
                        type: 'scatter',
                        marker: { color: 'rgba(239, 68, 68, 0.6)', size: 6 }
                    };
                    const zeroLine = {
                        x: [Math.min(...yPred), Math.max(...yPred)],
                        y: [0, 0],
                        mode: 'lines',
                        line: { color: 'black', dash: 'dash', width: 1 }
                    };
                    Plotly.newPlot('rfRegResidualPlot', [residualTrace, zeroLine], {
                        title: '殘差圖',
                        xaxis: { title: '預測值' },
                        yaxis: { title: '殘差 (實際 - 預測)' }
                    }, { responsive: true });

                } catch (err) {
                    resultsDiv.innerHTML = `<p class="text-red-600">訓練時發生錯誤：${err.message}</p>`;
                    console.error(err);
                    progressSpan.textContent = '';
                }
            }, 100);
        }

        /**
         * 執行隨機森林分類分析
         */
        function runRandomForestClassification() {
            const yVar = document.getElementById('rfClsY').value;
            const rawXVars = Array.from(document.getElementById('rfClsX').selectedOptions).map(opt => opt.value);

            // Check for overlap
            if (rawXVars.includes(yVar)) {
                alert(`錯誤：目標變數 (Y) "${yVar}" 不能同時作為特徵變數 (X)。請從特徵變數中移除它。`);
                return;
            }

            // 避免 Y 與 X 重複，並移除重複的 X 欄位
            const xVars = [...new Set(rawXVars.filter(v => v !== yVar))];
            const nTrees = parseInt(document.getElementById('rfClsNTrees').value);
            const maxDepth = parseInt(document.getElementById('rfClsMaxDepth').value);
            const minSamples = parseInt(document.getElementById('rfClsMinSamples').value);
            const featureMethod = document.getElementById('rfClsFeatureMethod').value;

            const resultsDiv = document.getElementById('rfClassificationResults');
            const progressSpan = document.getElementById('rfClsProgress');

            resultsDiv.innerHTML = '';
            progressSpan.textContent = '';

            if (!yVar || xVars.length === 0) {
                resultsDiv.innerHTML = `<p class="text-red-600">請選擇應變數 (Y) 和至少一個自變數 (X)。</p>`;
                return;
            }

            if (!jsonData || jsonData.length === 0) {
                resultsDiv.innerHTML = `<p class="text-red-600">請先載入資料並完成欄位設定。</p>`;
                return;
            }

            // 編碼 Y 變數（類別）
            const yValues = jsonData.map(row => row[yVar]).filter(v => v != null);
            const uniqueClasses = [...new Set(yValues)];

            if (uniqueClasses.length < 2 || uniqueClasses.length > 10) {
                resultsDiv.innerHTML = `<p class="text-red-600">應變數類別數應在 2-10 之間（當前：${uniqueClasses.length}）。</p>`;
                return;
            }

            const yEncoder = {};
            uniqueClasses.forEach((cls, idx) => { yEncoder[cls] = idx; });

            // 編碼 X 變數
            const encoders = {};
            xVars.forEach(header => {
                if (categoricalHeaders.includes(header)) {
                    const uniqueValues = [...new Set(jsonData.map(row => row[header]).filter(v => v != null))];
                    encoders[header] = {};
                    uniqueValues.forEach((val, i) => { encoders[header][val] = i; });
                }
            });

            const X = [], y = [];
            for (const row of jsonData) {
                let isValidRow = true;
                const featureRow = [];

                for (const xVar of xVars) {
                    const val = row[xVar];
                    if (val == null) { isValidRow = false; break; }
                    featureRow.push(categoricalHeaders.includes(xVar) ? encoders[xVar][val] : val);
                }

                const yVal = row[yVar];
                if (yVal == null || !(yVal in yEncoder)) isValidRow = false;

                if (isValidRow) {
                    X.push(featureRow);
                    y.push(yEncoder[yVal]);
                }
            }

            if (X.length < 40) {
                resultsDiv.innerHTML = `<p class="text-red-600">有效資料列不足 (${X.length} 筆)，建議至少 40 筆樣本。</p>`;
                return;
            }

            resultsDiv.innerHTML = `<div class="loader"></div><p class="text-center text-gray-600 mt-2">正在訓練 ${nTrees} 棵分類樹...</p>`;

            // Calculate feature means for default values in prediction
            const featureMeans = xVars.map((xVar, i) => {
                if (categoricalHeaders.includes(xVar)) {
                    return null; // categorical - use first option
                } else {
                    const sum = X.reduce((acc, row) => acc + row[i], 0);
                    return sum / X.length;
                }
            });

            setTimeout(() => {
                try {
                    const forest = trainRandomForestClassifier(X, y, {
                        nTrees,
                        maxDepth,
                        minSamplesLeaf: minSamples,
                        featureSubsetMethod: featureMethod,
                        progressCallback: (current, total) => {
                            progressSpan.textContent = `訓練進度：${current}/${total} 棵樹`;
                        }
                    });

                    progressSpan.textContent = '✅ 訓練完成！正在評估...';

                    const yPred = predictRandomForestClassifier(forest, X);
                    const confusionResult = calculateConfusionMatrix(y, yPred, forest.uniqueClasses);
                    const importances = calculateFeatureImportance(forest, xVars);

                    // 由編碼值還原類別標籤
                    const classLabels = forest.uniqueClasses.map(c =>
                        Object.keys(yEncoder).find(k => yEncoder[k] === c)
                    );

                    const classMetrics = confusionResult.classMetrics || [];
                    let macroPrecision = 0, macroRecall = 0, macroF1 = 0;
                    if (classMetrics.length > 0) {
                        macroPrecision = classMetrics.reduce((s, m) => s + m.precision, 0) / classMetrics.length;
                        macroRecall = classMetrics.reduce((s, m) => s + m.recall, 0) / classMetrics.length;
                        macroF1 = classMetrics.reduce((s, m) => s + m.f1, 0) / classMetrics.length;
                    }

                    // 組出帶標籤的指標陣列，方便排序與說明
                    const metricsWithLabels = forest.uniqueClasses.map((cls, idx) => {
                        const label = classLabels[idx] ?? cls;
                        const m = classMetrics.find(cm => cm.class === cls) || { precision: 0, recall: 0, f1: 0 };
                        return {
                            classId: cls,
                            label,
                            precision: m.precision,
                            recall: m.recall,
                            f1: m.f1
                        };
                    });

                    // 產生每一類別的 Precision / Recall / F1 列表
                    const metricsRowsHtml = metricsWithLabels.map(m => `
                <tr class="border-t">
                    <td class="px-3 py-1 text-gray-800">${m.label}</td>
                    <td class="px-3 py-1 text-right">${(m.precision * 100).toFixed(1)}%</td>
                    <td class="px-3 py-1 text-right">${(m.recall * 100).toFixed(1)}%</td>
                    <td class="px-3 py-1 text-right">${(m.f1 * 100).toFixed(1)}%</td>
                </tr>
            `).join('');

                    // 自動產生一段簡短的模型診斷說明
                    let summaryText = `整體準確度約為 ${(confusionResult.accuracy * 100).toFixed(1)}%，`;
                    if (metricsWithLabels.length > 0) {
                        const byRecall = [...metricsWithLabels].sort((a, b) => b.recall - a.recall);
                        const byPrecision = [...metricsWithLabels].sort((a, b) => b.precision - a.precision);
                        const bestRecall = byRecall[0];
                        const worstRecall = byRecall[byRecall.length - 1];
                        const bestPrec = byPrecision[0];
                        const worstPrec = byPrecision[byPrecision.length - 1];

                        summaryText += `平均 Precision 約為 ${(macroPrecision * 100).toFixed(1)}%，Recall 約為 ${(macroRecall * 100).toFixed(1)}%，F1 約為 ${(macroF1 * 100).toFixed(1)}%。`;
                        summaryText += ` 在召回率方面，「${bestRecall.label}」類別辨識最佳（${(bestRecall.recall * 100).toFixed(1)}%），`;
                        summaryText += `「${worstRecall.label}」較容易被漏判（${(worstRecall.recall * 100).toFixed(1)}%）。`;
                        summaryText += ` 在精確度方面，「${bestPrec.label}」預測最精準（${(bestPrec.precision * 100).toFixed(1)}%），`;
                        summaryText += `「${worstPrec.label}」則較常被誤判，建議檢視其樣本數與特徵分佈。`;
                    }

                    // 生成結果 HTML（混淆矩陣 + 指標表 + 特徵重要性）
                    let html = `
                <div class="bg-white p-6 rounded-lg border shadow-sm">
                    <h3 class="text-xl font-bold mb-4 text-green-700">🌲 隨機森林分類模型結果</h3>

                    <div class="bg-green-50 p-4 rounded mb-6">
                        <h4 class="font-semibold mb-2">📊 整體準確度</h4>
                        <p class="text-3xl font-bold text-green-700">${(confusionResult.accuracy * 100).toFixed(2)}%</p>
                        <p class="text-sm text-gray-600 mt-1">
                            訓練集準確度（${X.length} 筆樣本，${forest.uniqueClasses.length} 個類別）<br>
                            平均 Precision：${(macroPrecision * 100).toFixed(1)}%，
                            Recall：${(macroRecall * 100).toFixed(1)}%，
                            F1：${(macroF1 * 100).toFixed(1)}%
                        </p>
                    </div>

                    <div class="mb-6">
                        <h4 class="font-semibold mb-3">📉 混淆矩陣</h4>
                        <div id="rfClsConfusionPlot"></div>
                    </div>

                    <div class="mb-6">
                        <h4 class="font-semibold mb-2">📌 Precision / Recall / F1 指標</h4>
                        <div class="overflow-x-auto">
                            <table class="min-w-full text-sm border border-gray-200">
                                <thead class="bg-gray-50">
                                    <tr>
                                        <th class="px-3 py-2 text-left border-b">類別</th>
                                        <th class="px-3 py-2 text-right border-b">Precision</th>
                                        <th class="px-3 py-2 text-right border-b">Recall</th>
                                        <th class="px-3 py-2 text-right border-b">F1-score</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${metricsRowsHtml}
                                </tbody>
                            </table>
                        </div>
                        <p class="text-xs text-gray-500 mt-2">＊上述指標為「訓練資料」上的表現，實務上建議另行切分驗證集或使用交叉驗證。</p>
                    </div>

                    <div class="mb-6">
                        <h4 class="font-semibold mb-2">📝 模型診斷摘要</h4>
                        <p class="text-sm text-gray-700 leading-relaxed">${summaryText}</p>
                    </div>

                    <div class="mb-6">
                        <h4 class="font-semibold mb-3">🔑 變數重要性排名</h4>
                        <div id="rfClsImportancePlot"></div>
                    </div>

                    <!-- Prediction Section -->
                    <div class="mt-6 p-4 bg-gray-50 rounded border border-gray-200">
                        <h4 class="text-md font-semibold mb-3">🔮 模型預測 (Prediction)</h4>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4" id="rfClsPredictionInputs">
                            ${xVars.map((xVar, i) => {
                        if (categoricalHeaders.includes(xVar)) {
                            const options = Object.keys(encoders[xVar]).map(c => `<option value="${c}">${c}</option>`).join('');
                            return `
                                        <div>
                                            <label class="block text-sm font-medium text-gray-700 mb-1">${xVar}</label>
                                            <select id="rf_cls_pred_input_${i}" class="w-full p-2 border rounded">
                                                ${options}
                                            </select>
                                        </div>
                                    `;
                        } else {
                            const defaultVal = featureMeans[i] !== null ? featureMeans[i].toFixed(2) : '';
                            return `
                                        <div>
                                            <label class="block text-sm font-medium text-gray-700 mb-1">${xVar}</label>
                                            <input type="number" step="any" id="rf_cls_pred_input_${i}" value="${defaultVal}" class="w-full p-2 border rounded" placeholder="輸入數值">
                                            <span class="text-xs text-gray-400">平均值: ${defaultVal}</span>
                                        </div>
                                    `;
                        }
                    }).join('')}
                        </div>
                        <button id="btnPredictRFCls" class="mt-4 px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 transition">
                            進行預測
                        </button>
                        <div id="rfClsPredictionResult" class="mt-4 hidden p-3 bg-white border rounded"></div>
                    </div>
                </div>
            `;

                    resultsDiv.innerHTML = html;
                    progressSpan.textContent = '';

                    // Bind Prediction Event
                    document.getElementById('btnPredictRFCls').addEventListener('click', () => {
                        const resultDiv = document.getElementById('rfClsPredictionResult');
                        resultDiv.classList.remove('hidden');

                        try {
                            const inputVector = [];
                            for (let i = 0; i < xVars.length; i++) {
                                const xVar = xVars[i];
                                const el = document.getElementById(`rf_cls_pred_input_${i}`);
                                const val = el.value;

                                if (categoricalHeaders.includes(xVar)) {
                                    if (!(val in encoders[xVar])) throw new Error(`無效的類別值：${xVar}`);
                                    inputVector.push(encoders[xVar][val]);
                                } else {
                                    const numVal = parseFloat(val);
                                    if (isNaN(numVal)) throw new Error(`請輸入有效的數值：${xVar}`);
                                    inputVector.push(numVal);
                                }
                            }

                            // Manual Prediction with Probabilities
                            const treePredictions = forest.trees.map(treeObj => {
                                const { model, selectedFeatures } = treeObj;
                                const subset = selectedFeatures.map(idx => inputVector[idx]);
                                const pred = model.predict([subset])[0];
                                return Math.round(pred);
                            });

                            const counts = {};
                            forest.uniqueClasses.forEach(cls => counts[cls] = 0);
                            treePredictions.forEach(p => {
                                if (counts[p] !== undefined) counts[p]++;
                            });

                            const totalTrees = forest.trees.length;
                            const probs = forest.uniqueClasses.map(cls => ({
                                classId: cls,
                                label: Object.keys(yEncoder).find(k => yEncoder[k] === cls) || cls,
                                prob: counts[cls] / totalTrees
                            }));

                            // Find majority
                            const best = probs.reduce((prev, current) => (prev.prob > current.prob) ? prev : current);

                            const probList = probs.map(p => {
                                const pct = (p.prob * 100).toFixed(2);
                                const barColor = p.classId === best.classId ? 'bg-green-600' : 'bg-gray-300';
                                return `
                                    <div class="mb-2">
                                        <div class="flex justify-between text-sm mb-1">
                                            <span>${p.label}</span>
                                            <span>${pct}%</span>
                                        </div>
                                        <div class="w-full bg-gray-200 rounded-full h-2.5">
                                            <div class="${barColor} h-2.5 rounded-full" style="width: ${pct}%"></div>
                                        </div>
                                    </div>
                                `;
                            }).join('');

                            resultDiv.innerHTML = `
                                <h5 class="font-semibold mb-2">預測結果：<span class="text-green-700">${best.label}</span></h5>
                                <div class="mt-2">
                                    ${probList}
                                </div>
                            `;

                        } catch (e) {
                            resultDiv.innerHTML = `<p class="text-red-600">錯誤：${e.message}</p>`;
                        }
                    });

                    // 繪製混淆矩陣熱圖
                    Plotly.newPlot('rfClsConfusionPlot', [{
                        z: confusionResult.matrix,
                        x: classLabels,
                        y: classLabels,
                        type: 'heatmap',
                        colorscale: 'Blues',
                        text: confusionResult.matrix,
                        texttemplate: '%{text}',
                        textfont: { size: 14 }
                    }], {
                        title: '混淆矩陣',
                        xaxis: { title: '預測類別' },
                        yaxis: { title: '實際類別' }
                    }, { responsive: true });

                    // 繪製特徵重要性
                    Plotly.newPlot('rfClsImportancePlot', [{
                        x: importances.map(imp => imp.importance).reverse(),
                        y: importances.map(imp => imp.feature).reverse(),
                        type: 'bar',
                        orientation: 'h',
                        marker: { color: '#10b981' }
                    }], {
                        title: '變數重要性',
                        xaxis: { title: '重要性 (Importance)' },
                        margin: { l: 150, t: 20, b: 20 }
                    }, { responsive: true });

                } catch (err) {
                    resultsDiv.innerHTML = `<p class="text-red-600">訓練時發生錯誤：${err.message}</p>`;
                    console.error(err);
                    progressSpan.textContent = '';
                }
            }, 100);
        }






        function setupEventListeners() {
            document.getElementById('fileInput').addEventListener('change', () => {
                const fileInput = document.getElementById('fileInput');
                const loadDataBtn = document.getElementById('loadDataBtn');
                if (fileInput.files.length > 0) {
                    // 切換回 Excel 檔案模式並啟用載入按鈕
                    setInputMode('file');
                    loadDataBtn.disabled = false;
                    
                    // 自動執行載入 (Auto Load)
                    handleFileUpload();
                } else {
                    loadDataBtn.disabled = true;
                }
            });

            document.getElementById('loadDataBtn').addEventListener('click', handleFileUpload);

            // 載入範例資料按鈕
            const loadExampleBtn = document.getElementById('loadExampleBtn');
            if (loadExampleBtn) {
                loadExampleBtn.addEventListener('click', async () => {
                    try {
                        // 顯示載入指示器
                        document.getElementById('loadingIndicator').classList.remove('hidden');
                        document.getElementById('mainContent').classList.add('hidden');

                        // 檢查 protocol
                        if (window.location.protocol === 'file:') {
                            alert('注意：由於瀏覽器安全限制 (CORS)，無法在本地檔案模式 (file://) 直接載入範例檔案。\n\n請手動上傳檔案，或將此網頁部署至本地伺服器 (Local Server)。');
                            document.getElementById('loadingIndicator').classList.add('hidden');
                             // Show upload section again if it was hidden? 
                             // existing logic: mainContent hidden. We should probably just return.
                            return;
                        }

                        // 使用 fetch 載入 Example.xlsx
                        const response = await fetch('Example.xlsx');
                        if (!response.ok) throw new Error('無法載入範例檔案');

                        const arrayBuffer = await response.arrayBuffer();
                        const data = new Uint8Array(arrayBuffer);

                        // 使用 XLSX 讀取檔案
                        currentWorkbook = XLSX.read(data, { type: 'array', cellDates: true });
                        const sheetNames = currentWorkbook.SheetNames || [];

                        // 更新工作表選擇器
                        const sheetSelectorContainer = document.getElementById('sheetSelectorContainer');
                        const sheetSelector = document.getElementById('sheetSelector');
                        if (sheetSelector) {
                            sheetSelector.innerHTML = '';
                            sheetNames.forEach((name, idx) => {
                                const opt = document.createElement('option');
                                opt.value = name;
                                opt.textContent = `${idx + 1}. ${name}`;
                                sheetSelector.appendChild(opt);
                            });
                        }
                        if (sheetSelectorContainer) {
                            sheetSelectorContainer.classList.remove('hidden');
                        }

                        if (sheetNames.length === 0) {
                            throw new Error("範例檔案中找不到任何工作表。");
                        } else if (sheetNames.length === 1) {
                            // 只有一個工作表，自動載入
                            const firstSheetName = sheetNames[0];
                            const sheet = currentWorkbook.Sheets[firstSheetName];
                            jsonData = XLSX.utils.sheet_to_json(sheet, { defval: null });
                            if (jsonData.length === 0) throw new Error("範例工作表是空的或格式不正確。");
                            processData();
                        } else {
                            // 多個工作表，等待用戶選擇
                            // alert('已載入範例資料，請選擇要匯入的工作表並按「確認匯入」。');
                        }

                        // 切換到 Excel 檔案模式
                        setInputMode('file');

                    } catch (error) {
                        alert(`載入範例資料失敗: ${error.message}`);
                        resetUI();
                    } finally {
                        document.getElementById('loadingIndicator').classList.add('hidden');
                    }
                });
            }


            // 資料輸入方式切換按鈕
            const inputModeFileBtn = document.getElementById('inputModeFileBtn');
            const inputModePasteBtn = document.getElementById('inputModePasteBtn');
            if (inputModeFileBtn && inputModePasteBtn) {
                inputModeFileBtn.addEventListener('click', () => setInputMode('file'));
                inputModePasteBtn.addEventListener('click', () => setInputMode('paste'));
            }

            // Copy & Paste 匯入按鈕
            const pasteLoadBtn = document.getElementById('pasteLoadBtn');
            if (pasteLoadBtn) {
                pasteLoadBtn.addEventListener('click', handlePasteInput);
            }

            const confirmSheetBtn = document.getElementById('confirmSheetBtn');
            if (confirmSheetBtn) {
                confirmSheetBtn.addEventListener('click', handleSheetSelection);
            }
            document.querySelectorAll('.tab-button').forEach(button =>
                button.addEventListener('click', e => switchTab(button, '.tab-button', '.tab-content', 'data-tab')));
            document.querySelectorAll('.ml-tab-button').forEach(button =>
                button.addEventListener('click', e => switchTab(button, '.ml-tab-button', '.ml-tab-content', 'data-ml-tab')));
            document.querySelectorAll('.basic-tab-button').forEach(button =>
                button.addEventListener('click', e => switchTab(button, '.basic-tab-button', '.basic-tab-content', 'data-basic-tab')));

            // 時間序列預測子功能切換
            document.querySelectorAll('.forecast-tab-button').forEach(button =>
                button.addEventListener('click', e => switchTab(button, '.forecast-tab-button', '.forecast-tab-content', 'data-forecast-tab')));

            document.getElementById('runParetoBtn').addEventListener('click', runPareto);
            document.getElementById('runFishboneBtn')?.addEventListener('click', runFishbone);
            document.getElementById('runTTestBtn').addEventListener('click', runAnovaStyleTest);
            document.getElementById('runRegressionBtn').addEventListener('click', runRegression);
            document.getElementById('runMultipleRegressionBtn').addEventListener('click', runMultipleRegression);
            document.getElementById('runForecastBtn').addEventListener('click', runForecast);

            const runProphetBtn = document.getElementById('runProphetBtn');
            if (runProphetBtn) {
                runProphetBtn.addEventListener('click', runProphetForecast);
            }
            const runArimaBtn = document.getElementById('runArimaBtn');
            if (runArimaBtn) {
                runArimaBtn.addEventListener('click', runArimaForecast);
            }
            const runCrostonBtn = document.getElementById('runCrostonBtn');
            if (runCrostonBtn) {
                runCrostonBtn.addEventListener('click', runCrostonForecast);
            }
            document.getElementById('runLogisticBtn').addEventListener('click', runLogistic);
            document.getElementById('runDtBtn').addEventListener('click', runDecisionTree);
            document.getElementById('runCorrelationMatrixBtn').addEventListener('click', runCorrelationMatrix);
            document.getElementById('runScatterPlotBtn').addEventListener('click', runScatterPlotMatrix);
            document.getElementById('runPcaBtn').addEventListener('click', runPCA);
            document.getElementById('runFaBtn').addEventListener('click', runFactorAnalysis);
            document.getElementById('runChiSquareBtn').addEventListener('click', runChiSquareTest);
            document.getElementById('runKmeansElbowBtn').addEventListener('click', runKmeansElbow);
            document.getElementById('runKmeansBtn').addEventListener('click', runKmeansClustering);
            document.getElementById('runAprioriBtn').addEventListener('click', runAprioriAnalysis);
            document.getElementById('runOutlierBtn').addEventListener('click', runOutlierDetection);
            const runWordcloudBtn = document.getElementById('runWordcloudBtn');
            if (runWordcloudBtn) {
                runWordcloudBtn.addEventListener('click', runWordcloud);
            }
            
            // 管制圖事件監聽器
            document.getElementById('runControlChartBtn')?.addEventListener('click', runControlChart);
            
            // Toggle spec lines panel visibility
            document.getElementById('toggleSpecLinesBtn')?.addEventListener('click', () => {
                const panel = document.getElementById('specLinesPanel');
                panel.classList.toggle('hidden');
            });
            
            // Show/hide spec lines button based on subgroup size
            document.getElementById('ccSubgroupSize')?.addEventListener('input', (e) => {
                const n = parseInt(e.target.value) || 1;
                const toggleBtn = document.getElementById('toggleSpecLinesBtn');
                const specPanel = document.getElementById('specLinesPanel');
                if (n === 1) {
                    toggleBtn?.classList.remove('hidden');
                } else {
                    toggleBtn?.classList.add('hidden');
                    specPanel?.classList.add('hidden');
                }
            });
            
            // Auto-regenerate control chart when spec line values change (with debounce)
            let specLineDebounceTimer = null;
            const specLineInputs = ['ccSpecUSL', 'ccSpecTarget', 'ccSpecLSL'];
            specLineInputs.forEach(inputId => {
                document.getElementById(inputId)?.addEventListener('input', () => {
                    // Only auto-regenerate if chart has already been generated
                    const resultsDiv = document.getElementById('controlChartResults');
                    if (resultsDiv && !resultsDiv.classList.contains('hidden')) {
                        clearTimeout(specLineDebounceTimer);
                        specLineDebounceTimer = setTimeout(() => {
                            console.log('Auto-regenerating control chart with spec lines...');
                            runControlChart();
                        }, 500); // Wait 500ms after user stops typing
                    }
                });
            });
            
            // 製程能力分析事件監聯器
            document.getElementById('runProcessCapabilityBtn')?.addEventListener('click', runProcessCapability);
            
            // 多維度泡泡圖事件監聽器
            document.getElementById('runBubbleChartBtn')?.addEventListener('click', runBubbleChart);

            // 線性規劃事件監聽器
            document.getElementById('runLinearProgrammingBtn')?.addEventListener('click', runLinearProgramming);
            document.getElementById('lpAddConstraintBtn')?.addEventListener('click', addLPConstraint);
            document.getElementById('lpLoadExampleBtn')?.addEventListener('click', loadLPExample);
            document.getElementById('lpNumVariables')?.addEventListener('change', updateLPVariableInputs);
            setupLPRemoveConstraintListeners();

            // 隨機森林事件監聽器
            document.getElementById('runRFRegressionBtn')?.addEventListener('click', runRandomForestRegression);
            document.getElementById('runRFClassificationBtn')?.addEventListener('click', runRandomForestClassification);

            // SVM / SVR 事件監聯器
            document.getElementById('runSVMClassificationBtn')?.addEventListener('click', runSVMClassification);
            document.getElementById('runSVRRegressionBtn')?.addEventListener('click', runSVRRegression);

            document.getElementById('runHierarchicalBtn').addEventListener('click', runHierarchical);

            const hierClusterSlider = document.getElementById('hierClusterCount');
            if (hierClusterSlider) {
                hierClusterSlider.addEventListener('input', () => {
                    const k = parseInt(hierClusterSlider.value, 10);
                    document.getElementById('hierClusterCountLabel').textContent = k.toString();
                    if (hierarchicalState) {
                        updateHierarchicalClusterViews(k);
                    }
                });
            }

            // Add event listener for dynamic X variable filtering in Decision Tree
            document.getElementById('dtY').addEventListener('change', updateDtXOptions);

            // 初始化資料輸入模式（預設為 Excel 檔案上傳）
            // Also sync the initial active top-tab to the analysisContent wrapper
            const initiallyActiveTop = document.querySelector('.tab-button.active');
            if (initiallyActiveTop) {
                const initialTabName = initiallyActiveTop.getAttribute('data-tab');
                const analysisWrapperInit = document.getElementById('analysisContent');
                if (analysisWrapperInit) {
                    analysisWrapperInit.classList.add('active-tab-' + initialTabName);
                }
            }
            setInputMode('file');
        }

        function switchTab(clickedButton, buttonClass, contentClass, dataAttribute) {
            document.querySelectorAll(buttonClass).forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll(contentClass).forEach(content => content.classList.add('hidden'));
            clickedButton.classList.add('active');
            const tabName = clickedButton.getAttribute(dataAttribute);
            document.getElementById(tabName + 'Content').classList.remove('hidden');
            // Only update the analysisContent color class when switching top-level tabs
            if (dataAttribute === 'data-tab') {
                const analysisWrapper = document.getElementById('analysisContent');
                if (analysisWrapper) {
                    analysisWrapper.classList.remove('active-tab-eda', 'active-tab-basic', 'active-tab-forecast', 'active-tab-ml');
                    if (['eda', 'basic', 'forecast', 'ml'].includes(tabName)) {
                        analysisWrapper.classList.add('active-tab-' + tabName);
                    }
                }
            }
        }

        // --- Core Data Handling ---
        function handleFileUpload() {
            const file = document.getElementById('fileInput').files[0];
            if (!file) { alert('請先選擇一個 Excel 檔案'); return; }
            document.getElementById('loadingIndicator').classList.remove('hidden');
            document.getElementById('mainContent').classList.add('hidden');

            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    currentWorkbook = XLSX.read(data, { type: 'array', cellDates: true });
                    const sheetNames = currentWorkbook.SheetNames || [];

                    const sheetSelectorContainer = document.getElementById('sheetSelectorContainer');
                    const sheetSelector = document.getElementById('sheetSelector');
                    if (sheetSelector) {
                        sheetSelector.innerHTML = '';
                        sheetNames.forEach((name, idx) => {
                            const opt = document.createElement('option');
                            opt.value = name;
                            opt.textContent = `${idx + 1}. ${name}`;
                            sheetSelector.appendChild(opt);
                        });
                    }
                    if (sheetSelectorContainer) {
                        sheetSelectorContainer.classList.remove('hidden');
                    }

                    if (sheetNames.length === 0) {
                        throw new Error("找不到任何工作表，請確認 Excel 檔案內容。");
                    } else if (sheetNames.length === 1) {
                        const firstSheetName = sheetNames[0];
                        const sheet = currentWorkbook.Sheets[firstSheetName];
                        jsonData = XLSX.utils.sheet_to_json(sheet, { defval: null });
                        if (jsonData.length === 0) throw new Error("選取的工作表是空的或格式不正確。");
                        processData();
                    } else {
                        // 偵測到多個工作表：下方下拉選單已列出可選工作表，這裡不再彈出提醒，以維持流暢的 UI/UX。
                    }
                } catch (error) {
                    alert(`檔案處理失敗: ${error.message}`);
                    resetUI();
                } finally {
                    document.getElementById('loadingIndicator').classList.add('hidden');
                }
            };
            reader.readAsArrayBuffer(file);
        }

        function handleSheetSelection() {
            if (!currentWorkbook) {
                alert('請先選擇並載入 Excel 檔案');
                return;
            }
            const sheetSelector = document.getElementById('sheetSelector');
            if (!sheetSelector || !sheetSelector.value) {
                alert('請先選擇要匯入的工作表');
                return;
            }
            const sheetName = sheetSelector.value;
            try {
                document.getElementById('loadingIndicator').classList.remove('hidden');
                const sheet = currentWorkbook.Sheets[sheetName];
                if (!sheet) throw new Error('找不到選取的工作表。');
                jsonData = XLSX.utils.sheet_to_json(sheet, { defval: null });
                if (jsonData.length === 0) throw new Error('選取的工作表是空的或格式不正確。');
                processData();
            } catch (error) {
                alert(`匯入工作表失敗: ${error.message}`);
                resetUI();
            } finally {
                document.getElementById('loadingIndicator').classList.add('hidden');
            }
        }

        // --- Copy & Paste 資料匯入相關函式 ---
        function parsePastedData(rawText, delimiterMode) {
            if (!rawText || !rawText.trim()) {
                throw new Error('貼上的內容為空，請確認是否已從 Excel 或 CSV 複製資料。');
            }

            const lines = rawText
                .split(/\r?\n/)
                .map(line => line.trimEnd())
                .filter(line => line.length > 0);

            if (lines.length < 2) {
                throw new Error('請至少包含一列欄位名稱與一列資料。');
            }

            // 判斷分隔符號
            let delimiter = '\t';
            if (delimiterMode === 'tab') {
                delimiter = '\t';
            } else if (delimiterMode === 'comma') {
                delimiter = ',';
            } else if (delimiterMode === 'semicolon') {
                delimiter = ';';
            } else {
                // auto 模式：依欄位名稱列自動判斷
                const headerLine = lines[0];
                if (headerLine.indexOf('\t') !== -1) {
                    delimiter = '\t';
                } else if (headerLine.indexOf(',') !== -1) {
                    delimiter = ',';
                } else if (headerLine.indexOf(';') !== -1) {
                    delimiter = ';';
                } else {
                    // 回退策略：以任何連續空白當作分隔
                    delimiter = /\s+/;
                }
            }

            const splitLine = (line) => {
                return typeof delimiter === 'string'
                    ? line.split(delimiter)
                    : line.trim().split(delimiter);
            };

            const headerCells = splitLine(lines[0]).map(h => h.trim());
            const colCount = headerCells.length;
            if (colCount === 0) {
                throw new Error('無法解析欄位名稱列，請確認資料格式。');
            }

            const tryParseValue = (v) => {
                if (v === null || v === undefined) return null;
                const s = String(v).trim();
                if (s === '') return null;

                // 嘗試解析為數值
                const num = Number(s);
                if (!isNaN(num)) return num;

                // 嘗試解析為日期
                const date = new Date(s);
                if (!isNaN(date.getTime())) return date;

                // 回傳原始字串
                return s;
            };

            const records = [];
            for (let i = 1; i < lines.length; i++) {
                const cells = splitLine(lines[i]);
                if (cells.length === 1 && cells[0].trim() === '') continue;
                const rowObj = {};
                for (let c = 0; c < colCount; c++) {
                    const key = headerCells[c] || `欄位_${c + 1}`;
                    const value = c < cells.length ? tryParseValue(cells[c]) : null;
                    rowObj[key] = value;
                }
                records.push(rowObj);
            }

            if (records.length === 0) {
                throw new Error('無法從貼上的內容解析出有效資料列。');
            }

            return {
                data: records,
                headers: headerCells
            };
        }

        function handlePasteInput() {
            const textarea = document.getElementById('pasteTextarea');
            if (!textarea) {
                alert('找不到貼上輸入區塊，請重新整理頁面。');
                return;
            }

            const rawText = textarea.value;
            const delimiterInput = document.querySelector('input[name="pasteDelimiter"]:checked');
            const delimiterMode = delimiterInput ? delimiterInput.value : 'auto';

            try {
                document.getElementById('loadingIndicator').classList.remove('hidden');

                const parsed = parsePastedData(rawText, delimiterMode);
                jsonData = parsed.data;

                if (!jsonData || jsonData.length === 0) {
                    throw new Error('解析後的資料為空，請確認貼上的內容格式。');
                }

                // 更新檔名顯示
                const fileNameDisplay = document.getElementById('fileName');
                if (fileNameDisplay) {
                    fileNameDisplay.textContent = `已從貼上的資料匯入：${jsonData.length} 筆記錄，${Object.keys(jsonData[0] || {}).length} 個欄位。`;
                }

                // 清空檔案與工作表相關 UI（避免誤解）
                const fileInput = document.getElementById('fileInput');
                const sheetSelectorContainer = document.getElementById('sheetSelectorContainer');
                const sheetSelector = document.getElementById('sheetSelector');
                const loadDataBtn = document.getElementById('loadDataBtn');

                if (fileInput) fileInput.value = '';
                if (loadDataBtn) loadDataBtn.disabled = true;
                if (sheetSelectorContainer) sheetSelectorContainer.classList.add('hidden');
                if (sheetSelector) sheetSelector.innerHTML = '';

                processData();
            } catch (error) {
                alert(`貼上資料處理失敗: ${error.message}`);
                console.error(error);
            } finally {
                document.getElementById('loadingIndicator').classList.add('hidden');
            }
        }

        function setInputMode(mode) {
            currentInputMode = mode === 'paste' ? 'paste' : 'file';

            const excelArea = document.getElementById('excelInputArea');
            const pasteArea = document.getElementById('pasteInputArea');
            const fileBtn = document.getElementById('inputModeFileBtn');
            const pasteBtn = document.getElementById('inputModePasteBtn');

            if (excelArea && pasteArea && fileBtn && pasteBtn) {
                if (currentInputMode === 'file') {
                    excelArea.classList.remove('hidden');
                    pasteArea.classList.add('hidden');

                    fileBtn.classList.add('bg-blue-50', 'text-blue-700', 'border-blue-500', 'shadow-sm');
                    fileBtn.classList.remove('text-gray-600', 'border-gray-300');

                    pasteBtn.classList.remove('bg-blue-50', 'text-blue-700', 'border-blue-500', 'shadow-sm');
                    pasteBtn.classList.add('text-gray-600', 'border-gray-300');
                } else {
                    excelArea.classList.add('hidden');
                    pasteArea.classList.remove('hidden');

                    pasteBtn.classList.add('bg-blue-50', 'text-blue-700', 'border-blue-500', 'shadow-sm');
                    pasteBtn.classList.remove('text-gray-600', 'border-gray-300');

                    fileBtn.classList.remove('bg-blue-50', 'text-blue-700', 'border-blue-500', 'shadow-sm');
                    fileBtn.classList.add('text-gray-600', 'border-gray-300');
                }
            }
        }




        function clearAllOutputs() {
            const outputIds = [
                'edaResults', 'paretoResults', 'tTestResults', 'regressionResults',
                'forecastResults', 'logisticResults', 'dtResults', 'correlationMatrixResults',
                'chiSquareResults', 'kmeansResults', 'hierarchicalResults', 'aprioriResults',
                'outlierResults', 'pcaResults', 'faResults', 'rfRegressionResults', 'rfClassificationResults',
                'wordcloudContainer', 'prophetResults', 'arimaResults', 'crostonResults',
                'bubbleChartPlot', 'bubbleChartLegend'
            ];
            outputIds.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.innerHTML = '';
            });
            const dataPreview = document.getElementById('dataPreview');
            if (dataPreview) dataPreview.innerHTML = '';
            logisticModel = null;
            hierarchicalState = null;

            // Reset bubble chart animation state
            if (typeof bubbleAnimationState !== 'undefined') {
                stopBubbleAnimation();
                bubbleAnimationState.frames = [];
                bubbleAnimationState.timeValues = [];
                bubbleAnimationState.entityHistory = {};
                bubbleAnimationState.currentFrameIndex = 0;
            }
            // Hide bubble chart results
            const bubbleResults = document.getElementById('bubbleChartResults');
            if (bubbleResults) bubbleResults.classList.add('hidden');
            const bubbleAnimControls = document.getElementById('bubbleAnimationControls');
            if (bubbleAnimControls) bubbleAnimControls.style.display = 'none';
            const bubbleSlider = document.getElementById('bubbleTimeSliderContainer');
            if (bubbleSlider) bubbleSlider.style.display = 'none';
        }

        function processData() {

            clearAllOutputs();
            headers = Object.keys(jsonData[0]);
            classifyHeaders();
            displayDataPreview();
            populateSelects();
            document.getElementById('mainContent').classList.remove('hidden');
            runEDA();

            // Auto-collapse upload section and show status badge
            const uploadSection = document.getElementById('uploadSection');
            const uploadBadge = document.getElementById('uploadStatusBadge');
            if (uploadSection) {
                uploadSection.removeAttribute('open');
            }
            if (uploadBadge) {
                uploadBadge.classList.remove('hidden');
            }

            // Update preview section with row count and collapse it
            const previewSection = document.getElementById('previewSection');
            const previewRowCount = document.getElementById('previewRowCount');
            if (previewRowCount) {
                previewRowCount.textContent = `(${jsonData.length} 筆資料)`;
            }
            if (previewSection) {
                previewSection.removeAttribute('open');
            }
        }

        function resetUI() {
            document.getElementById('mainContent').classList.add('hidden');
            document.getElementById('loadDataBtn').disabled = true;
            document.getElementById('fileInput').value = '';
            const fileNameEl = document.getElementById('fileName');
            if (fileNameEl) fileNameEl.textContent = '';
            jsonData = [];
            headers = [];
            numericHeaders = [];
            categoricalHeaders = [];
            currentWorkbook = null;
            clearAllOutputs();
            const sheetSelectorContainer = document.getElementById('sheetSelectorContainer');
            const sheetSelector = document.getElementById('sheetSelector');
            if (sheetSelectorContainer) sheetSelectorContainer.classList.add('hidden');
            if (sheetSelector) sheetSelector.innerHTML = '';
        }

        function classifyHeaders() {
            numericHeaders = [];
            categoricalHeaders = [];
            headers.forEach(header => {
                const sampleRows = jsonData.slice(0, 50);
                const values = sampleRows
                    .map(row => row[header])
                    .filter(v => v !== null && v !== undefined && v !== '');
                if (values.length === 0) return;

                const isDate = sampleRows.some(row => row[header] instanceof Date);
                const allNumbers = values.every(v => typeof v === 'number' && !isNaN(v));

                if (allNumbers && !isDate) {
                    numericHeaders.push(header);
                    const uniqueValues = [...new Set(values)];
                    const allIntegers = uniqueValues.every(v => Number.isInteger(v));
                    if (allIntegers && uniqueValues.length > 1 && uniqueValues.length <= 10) {
                        if (!categoricalHeaders.includes(header)) {
                            categoricalHeaders.push(header);
                        }
                    }
                } else {
                    if (!categoricalHeaders.includes(header)) {
                        categoricalHeaders.push(header);
                    }
                }
            });
        }

        function displayDataPreview() {
            const previewDiv = document.getElementById('dataPreview');
            // Modern Table Styling
            let tableHTML = `
                <div class="border border-gray-200 rounded-lg overflow-hidden shadow-sm">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-50 sticky top-0 z-10">
                            <tr>`;
            headers.forEach(h => tableHTML += `<th class="px-6 py-3 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider whitespace-nowrap bg-gray-50 border-b border-gray-200">${h}</th>`);
            tableHTML += `  </tr>
                        </thead>
                        <tbody class="bg-white divide-y divide-gray-200">`;

            jsonData.slice(0, 50).forEach((row, index) => {
                const bgClass = index % 2 === 0 ? 'bg-white' : 'bg-gray-50/50'; // Subtle striping
                tableHTML += `<tr class="${bgClass} hover:bg-blue-50 transition-colors duration-150">`;
                headers.forEach(h => {
                    let cellValue = row[h];
                    if (cellValue instanceof Date) cellValue = cellValue.toLocaleDateString();
                    // Check if value is number for alignment
                    const alignClass = (typeof cellValue === 'number') ? 'text-right font-mono' : 'text-left';
                    tableHTML += `<td class="px-6 py-3 whitespace-nowrap text-sm text-gray-700 ${alignClass}">${cellValue != null ? cellValue : '<span class="text-gray-300 italic">N/A</span>'}</td>`;
                });
                tableHTML += `</tr>`;
            });
            tableHTML += `</tbody></table></div>`;

            // Add a footer note
            tableHTML += `<div class="mt-2 text-xs text-gray-500 text-right">顯示前 50 筆資料預覽</div>`;

            previewDiv.innerHTML = tableHTML;
        }


        // T-Test UI Event Listeners
        document.addEventListener('DOMContentLoaded', () => {
             const radios = document.querySelectorAll('input[name="tTestType"]');
             radios.forEach(radio => {
                 radio.addEventListener('change', (e) => {
                     const type = e.target.value;
                     const group1 = document.getElementById('tTestInputGroup1');
                     const group2 = document.getElementById('tTestInputGroup2');
                     const col1 = document.getElementById('tTestInputCol1');
                     const col2 = document.getElementById('tTestInputCol2');

                     
                     if (type === 'independent_group' || type === 'f_test_group') {
                         group1.classList.remove('hidden');
                         group2.classList.remove('hidden');
                         col1.classList.add('hidden');
                         col2.classList.add('hidden');
                     } else {
                         // independent_columns, paired
                         group1.classList.add('hidden');
                         group2.classList.add('hidden');
                         col1.classList.remove('hidden');
                         col2.classList.remove('hidden');
                     }
                 });
             });
        });

        function populateSelects() {
            const binaryCategoricalHeaders = headers.filter(h => {
                const uniqueValues = [...new Set(jsonData.map(row => row[h]).filter(v => v != null))];
                return uniqueValues.length === 2;
            });

            const selects = [
                { id: 'paretoCategoryVar', headers: categoricalHeaders },
                { id: 'paretoValueVar', headers: numericHeaders },
                { id: 'fishboneParentVar', headers: headers },
                { id: 'fishboneChildVar', headers: headers },
                { id: 'tTestCategoricalVar', headers: categoricalHeaders },
                { id: 'tTestNumericalVar', headers: numericHeaders },
                { id: 'tTestVar1', headers: numericHeaders },
                { id: 'tTestVar2', headers: numericHeaders },
                { id: 'regressionX', headers: numericHeaders },
                { id: 'regressionY', headers: numericHeaders },
                { id: 'multipleRegressionX', headers: numericHeaders },
                { id: 'multipleRegressionY', headers: numericHeaders },
                { id: 'forecastTimeVar', headers: headers },
                { id: 'forecastValueVar', headers: headers },
                { id: 'movingAverageTimeVar', headers: headers },
                { id: 'movingAverageValueVar', headers: headers },
                { id: 'singleExpTimeVar', headers: headers },
                { id: 'singleExpValueVar', headers: headers },
                { id: 'doubleExpTimeVar', headers: headers },
                { id: 'doubleExpValueVar', headers: headers },
                { id: 'prophetTimeVar', headers: headers },
                { id: 'prophetValueVar', headers: numericHeaders },
                { id: 'arimaTimeVar', headers: headers },
                { id: 'arimaValueVar', headers: numericHeaders },
                { id: 'lstmTimeVar', headers: headers },
                { id: 'lstmValueVar', headers: numericHeaders },
                { id: 'crostonTimeVar', headers: headers },
                { id: 'crostonValueVar', headers: numericHeaders },
                { id: 'logisticY', headers: binaryCategoricalHeaders },
                { id: 'logisticX', headers: numericHeaders },
                { id: 'dtY', headers: numericHeaders }, // Decision Tree Y is now numeric
                { id: 'dtX', headers: headers },
                { id: 'pcaVariables', headers: numericHeaders },
                { id: 'faVariables', headers: numericHeaders },
                { id: 'chiSquareVar1', headers: categoricalHeaders },
                { id: 'chiSquareVar2', headers: categoricalHeaders },
                { id: 'kmeansVariables', headers: numericHeaders },
                { id: 'correlationVarSelect', headers: numericHeaders },
                { id: 'hierVariables', headers: headers },         // 新增：階層式集群可選所有欄位
                { id: 'aprioriTransactionId', headers: headers },
                { id: 'aprioriItemName', headers: headers },
                { id: 'outlierVariable', headers: numericHeaders },
                { id: 'rfRegY', headers: numericHeaders },
                { id: 'rfRegX', headers: headers },
                { id: 'rfClsY', headers: categoricalHeaders },
                { id: 'rfClsX', headers: headers },
                { id: 'nnY', headers: headers },
                { id: 'nnX', headers: headers },
                { id: 'svmClsY', headers: categoricalHeaders },
                { id: 'svmClsX', headers: numericHeaders },
                { id: 'svrRegY', headers: numericHeaders },
                { id: 'svrRegX', headers: numericHeaders }
            ];
            selects.forEach(s => {
                const selectEl = document.getElementById(s.id);
                if (!selectEl) return;
                selectEl.innerHTML = selectEl.multiple ? '' : '<option value="">請選擇欄位</option>';
                s.headers.forEach(header => {
                    const option = document.createElement('option');
                    option.value = header, option.textContent = header;
                    selectEl.appendChild(option);
                });
            });

            // 文字雲欄位選擇：優先使用類別/文字欄位，若無則退回全部欄位
            const wcSelect = document.getElementById('wordcloudTextColumn');
            if (wcSelect) {
                wcSelect.innerHTML = '<option value="">請選擇欄位</option>';
                const textHeaders = (categoricalHeaders && categoricalHeaders.length > 0)
                    ? categoricalHeaders
                    : headers;
                textHeaders.forEach(h => {
                    const opt = document.createElement('option');
                    opt.value = h;
                    opt.textContent = h;
                    wcSelect.appendChild(opt);
                });
            }

            // 管制圖欄位選擇：使用數值欄位
            const ccVarSelect = document.getElementById('ccVariable');
            if (ccVarSelect) {
                ccVarSelect.innerHTML = '<option value="">請選擇欄位</option>';
                numericHeaders.forEach(h => {
                    const opt = document.createElement('option');
                    opt.value = h;
                    opt.textContent = h;
                    ccVarSelect.appendChild(opt);
                });
            }

            // 製程能力分析欄位選擇：使用數值欄位
            const pcVarSelect = document.getElementById('pcVariable');
            if (pcVarSelect) {
                pcVarSelect.innerHTML = '<option value="">請選擇欄位</option>';
                numericHeaders.forEach(h => {
                    const opt = document.createElement('option');
                    opt.value = h;
                    opt.textContent = h;
                    pcVarSelect.appendChild(opt);
                });
            }

            // 多維度泡泡圖欄位選擇
            const bubbleXSelect = document.getElementById('bubbleXVar');
            const bubbleYSelect = document.getElementById('bubbleYVar');
            const bubbleSizeSelect = document.getElementById('bubbleSizeVar');
            const bubbleColorSelect = document.getElementById('bubbleColorVar');

            // X 和 Y 軸：使用數值欄位
            [bubbleXSelect, bubbleYSelect].forEach(sel => {
                if (sel) {
                    sel.innerHTML = '<option value="">請選擇欄位</option>';
                    numericHeaders.forEach(h => {
                        const opt = document.createElement('option');
                        opt.value = h;
                        opt.textContent = h;
                        sel.appendChild(opt);
                    });
                }
            });

            // 泡泡大小：使用數值欄位
            if (bubbleSizeSelect) {
                bubbleSizeSelect.innerHTML = '<option value="">不使用</option>';
                numericHeaders.forEach(h => {
                    const opt = document.createElement('option');
                    opt.value = h;
                    opt.textContent = h;
                    bubbleSizeSelect.appendChild(opt);
                });
            }

            // 泡泡顏色：可用數值或類別欄位
            if (bubbleColorSelect) {
                bubbleColorSelect.innerHTML = '<option value="">不使用</option>';
                headers.forEach(h => {
                    const opt = document.createElement('option');
                    opt.value = h;
                    opt.textContent = h;
                    bubbleColorSelect.appendChild(opt);
                });
            }

            // 標籤欄位：兩個模式 (疊圖 / 不疊圖)
            const bubbleLabelOverlay = document.getElementById('bubbleLabelOverlay');
            const bubbleLabelSeparate = document.getElementById('bubbleLabelSeparate');
            [bubbleLabelOverlay, bubbleLabelSeparate].forEach(select => {
                if (select) {
                    select.innerHTML = '<option value="">不使用</option>';
                    headers.forEach(h => {
                        const opt = document.createElement('option');
                        opt.value = h;
                        opt.textContent = h;
                        select.appendChild(opt);
                    });
                }
            });

            // 時間軸欄位（動畫用）：所有欄位都可以
            const bubbleTimeSelect = document.getElementById('bubbleTimeVar');
            if (bubbleTimeSelect) {
                bubbleTimeSelect.innerHTML = '<option value="">不使用動畫</option>';
                headers.forEach(h => {
                    const opt = document.createElement('option');
                    opt.value = h;
                    opt.textContent = h;
                    bubbleTimeSelect.appendChild(opt);
                });
            }

            updateDtXOptions(); // Initial call
        }

        function updateDtXOptions() {
            const yVar = document.getElementById('dtY').value;
            const xSelect = document.getElementById('dtX');
            const currentX = Array.from(xSelect.selectedOptions).map(opt => opt.value);

            xSelect.innerHTML = '';
            headers.forEach(header => {
                if (header !== yVar) {
                    const option = document.createElement('option');
                    option.value = header;
                    option.textContent = header;
                    if (currentX.includes(header)) {
                        option.selected = true;
                    }
                    xSelect.appendChild(option);
                }
            });
        }



        function runWordcloud() {
            // 移除舊的下載按鈕事件監聽器，避免重複
            const oldBtn = document.getElementById('downloadWordcloudBtn');
            if (oldBtn) {
                const newBtn = oldBtn.cloneNode(true);
                oldBtn.parentNode.replaceChild(newBtn, oldBtn);
                newBtn.disabled = true;
            }
            if (!jsonData || jsonData.length === 0) {
                alert('請先載入資料');
                return;
            }
            const colSelect = document.getElementById('wordcloudTextColumn');
            if (!colSelect) {
                alert('找不到文字雲欄位選擇元件');
                return;
            }
            const col = colSelect.value;
            if (!col) {
                alert('請先選擇文字欄位');
                return;
            }

            const minFreq = parseInt(document.getElementById('wordcloudMinFreq').value) || 1;
            const maxWords = parseInt(document.getElementById('wordcloudMaxWords').value) || 60;
            const container = document.getElementById('wordcloudContainer');
            if (!container) return;
            container.innerHTML = '';
            container.style.position = 'relative';

            // 1. 統計詞頻
            const freqMap = {};
            jsonData.forEach(row => {
                const val = row[col];
                if (val === null || val === undefined) return;
                const text = String(val).toLowerCase();
                const tokens = text.split(/[\s,;，。\.\!！\?？:：;、]+/);
                tokens.forEach(tok => {
                    const w = tok.trim();
                    if (!w) return;
                    if (w.length <= 1) return; // 若要保留單一字元，可註解此行
                    freqMap[w] = (freqMap[w] || 0) + 1;
                });
            });

            let entries = Object.entries(freqMap)
                .filter(([w, c]) => c >= minFreq)
                .sort((a, b) => b[1] - a[1])
                .slice(0, maxWords);

            if (entries.length === 0) {
                container.innerHTML = '<p class="text-sm text-gray-500">沒有符合條件的文字，請調整欄位或門檻。</p>';
                return;
            }

            // 2. 準備畫布與測量工具
            const rect = container.getBoundingClientRect();
            const cx = (rect.width || container.clientWidth || 400) / 2;
            const cy = (rect.height || container.clientHeight || 300) / 2;

            // 建立隱藏 Canvas 用於測量文字大小
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            const counts = entries.map(e => e[1]);
            const minC = Math.min.apply(null, counts);
            const maxC = Math.max.apply(null, counts);
            const range = maxC - minC || 1;

            const placedWords = []; // {x, y, width, height, right, bottom}

            // 輔助函式：檢查碰撞
            function checkCollision(box) {
                for (let i = 0; i < placedWords.length; i++) {
                    const other = placedWords[i];
                    if (!(box.right < other.x ||
                        box.x > other.right ||
                        box.bottom < other.y ||
                        box.y > other.bottom)) {
                        return true;
                    }
                }
                return false;
            }

            // 3. 螺旋排布 + 碰撞檢測
            entries.forEach(([word, count], index) => {
                const norm = (count - minC) / range; // 0 = 低頻, 1 = 高頻

                // 字體大小與樣式計算 (保持原邏輯)
                const minFont = 16;
                const maxFont = 48;
                const fontSize = minFont + norm * (maxFont - minFont);

                let fontWeight = '400';
                if (norm > 0.7) fontWeight = '900';
                else if (norm > 0.4) fontWeight = '700';
                else if (norm > 0.1) fontWeight = '500';

                // 顏色計算 (保持原邏輯)
                let hue;
                if (norm > 0.6) {
                    const t = (norm - 0.6) / 0.4;
                    hue = 30 - t * 30; // 30 (橘) -> 0 (紅)
                } else if (norm > 0.3) {
                    const t = (norm - 0.3) / 0.3;
                    hue = 30 + t * (240 - 30); // 30 -> 240
                } else {
                    const t = norm / 0.3;
                    hue = 240 - t * (240 - 120); // 240 (藍) -> 120 (綠)
                }
                const sat = 75;
                const light = 50 + norm * 10;
                const color = `hsl(${hue}, ${sat}%, ${light}%)`;

                // 測量文字尺寸
                ctx.font = `${fontWeight} ${fontSize}px Inter, "Noto Sans TC", sans-serif`;
                const metrics = ctx.measureText(word);
                const textWidth = metrics.width;
                const textHeight = fontSize * 1.2; // 估算高度

                // 螺旋搜尋位置
                let angle = 0;
                let radius = 0;
                const angleStep = 0.2; // 角度增量
                const radiusStep = 5;  // 半徑參數 (b in r = a + b*theta)

                // 第一個字直接放中間
                if (index === 0) {
                    const box = {
                        x: cx - textWidth / 2,
                        y: cy - textHeight / 2,
                        width: textWidth,
                        height: textHeight,
                        right: cx + textWidth / 2,
                        bottom: cy + textHeight / 2
                    };
                    placedWords.push(box);
                    createWordSpan(word, box.x, box.y, fontSize, fontWeight, color, norm);
                    return;
                }

                // 其他字螺旋尋找
                let found = false;
                // 限制最大嘗試次數以防無限迴圈
                const maxIter = 2000;
                for (let i = 0; i < maxIter; i++) {
                    // 阿基米德螺旋
                    radius = radiusStep * angle;

                    const x = cx + radius * Math.cos(angle) - textWidth / 2;
                    const y = cy + radius * Math.sin(angle) - textHeight / 2;

                    const box = {
                        x: x,
                        y: y,
                        width: textWidth,
                        height: textHeight,
                        right: x + textWidth,
                        bottom: y + textHeight
                    };

                    if (!checkCollision(box)) {
                        placedWords.push(box);
                        createWordSpan(word, x, y, fontSize, fontWeight, color, norm);
                        found = true;
                        break;
                    }

                    angle += angleStep;
                }

                if (!found) {
                    console.warn(`無法放置文字: ${word} (空間不足或嘗試次數過多)`);
                }
            });

            function createWordSpan(text, x, y, fontSize, fontWeight, color, norm) {
                const span = document.createElement('span');
                span.textContent = text;
                span.className = 'wordcloud-word';
                span.style.position = 'absolute';
                span.style.fontSize = fontSize + 'px';
                span.style.fontWeight = fontWeight;
                span.style.left = x + 'px';
                span.style.top = y + 'px';
                span.style.color = color;
                span.style.zIndex = 10 + Math.round(norm * 90);
                span.style.whiteSpace = 'nowrap';
                span.style.lineHeight = '1.2';
                container.appendChild(span);
            }

            // 4. 啟用下載功能
            const downloadBtn = document.getElementById('downloadWordcloudBtn');
            if (downloadBtn) {
                downloadBtn.disabled = false;
                downloadBtn.addEventListener('click', downloadWordcloud);
            }

            // 5. 生成高頻字詞排行榜 (Top 20)
            const listContainer = document.getElementById('wordcloudList');
            if (listContainer) {
                listContainer.innerHTML = '';
                listContainer.classList.remove('hidden');

                // 排序並取前 20 名
                const topEntries = entries.slice(0, 20);

                const maxCount = topEntries.length > 0 ? topEntries[0][1] : 1;
                
                // 顏色循環 (Blue, Purple, Green, Red, Orange, Teal)
                const barColors = ['bg-blue-600', 'bg-purple-600', 'bg-emerald-600', 'bg-red-600', 'bg-amber-600', 'bg-cyan-600'];

                let tableHtml = `
                    <h3 class="text-lg font-bold mb-4 flex items-center text-gray-800">
                        <span class="mr-2">📋</span> 高頻字詞排行
                    </h3>
                    <div class="overflow-hidden rounded-lg shadow-sm border border-gray-200">
                        <table class="min-w-full divide-y divide-gray-200 bg-white">
                            <thead class="bg-gray-50">
                                <tr>
                                    <th scope="col" class="px-6 py-3 text-left text-xs font-bold text-gray-500 uppercase tracking-wider w-16">排名</th>
                                    <th scope="col" class="px-6 py-3 text-left text-xs font-bold text-gray-500 uppercase tracking-wider w-1/4">字詞</th>
                                    <th scope="col" class="px-6 py-3 text-right text-xs font-bold text-gray-500 uppercase tracking-wider w-24">出現次數</th>
                                    <th scope="col" class="px-6 py-3 text-left text-xs font-bold text-gray-500 uppercase tracking-wider">頻率條</th>
                                </tr>
                            </thead>
                            <tbody class="divide-y divide-gray-200">
                `;

                topEntries.forEach((entry, idx) => {
                    const word = entry[0];
                    const count = entry[1];
                    const percent = (count / maxCount) * 100;
                    const colorClass = barColors[idx % barColors.length];

                    tableHtml += `
                        <tr class="hover:bg-gray-50 transition-colors">
                            <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-500">
                                ${idx + 1}
                            </td>
                            <td class="px-6 py-4 whitespace-nowrap text-sm font-bold text-gray-900">
                                ${word}
                            </td>
                            <td class="px-6 py-4 whitespace-nowrap text-sm text-right text-gray-600 font-mono">
                                ${count}
                            </td>
                            <td class="px-6 py-4 whitespace-nowrap align-middle">
                                <div class="w-full bg-gray-100 rounded-full h-2.5 overflow-hidden">
                                    <div class="${colorClass} h-2.5 rounded-full" style="width: ${percent}%"></div>
                                </div>
                            </td>
                        </tr>
                    `;
                });

                tableHtml += `
                            </tbody>
                        </table>
                    </div>
                `;

                listContainer.innerHTML = tableHtml;
            }
        }

        function downloadWordcloud() {
            const container = document.getElementById('wordcloudContainer');
            if (!container) return;

            // 使用 html2canvas 渲染文字雲容器
            html2canvas(container, {
                scale: 2, // 提高解析度
                backgroundColor: '#ffffff', // 設定背景為白色
                useCORS: true,
                allowTaint: true,
            }).then(canvas => {
                // 轉換為 PNG 圖片
                const image = canvas.toDataURL('image/png');

                // 建立下載連結
                const link = document.createElement('a');
                link.href = image;
                link.download = 'wordcloud_analysis.png';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }).catch(error => {
                console.error('文字雲下載失敗:', error);
                alert('文字雲下載失敗，請檢查瀏覽器控制台。');
            });
        }

        // ============================================
        // 製程能力分析 (Process Capability Analysis)
        // ============================================
        function runProcessCapability() {
            if (!jsonData || jsonData.length === 0) {
                alert('請先載入資料');
                return;
            }

            const variableSelect = document.getElementById('pcVariable');
            const uslInput = document.getElementById('pcUSL');
            const lslInput = document.getElementById('pcLSL');
            const targetInput = document.getElementById('pcTarget');
            const subgroupSizeInput = document.getElementById('pcSubgroupSize');
            const sigmaMethodSelect = document.getElementById('pcSigmaMethod');

            const variable = variableSelect.value;
            const usl = uslInput.value !== '' ? parseFloat(uslInput.value) : null;
            const lsl = lslInput.value !== '' ? parseFloat(lslInput.value) : null;
            const target = targetInput.value !== '' ? parseFloat(targetInput.value) : null;
            const subgroupSize = parseInt(subgroupSizeInput.value, 10) || 1;
            const sigmaMethod = sigmaMethodSelect.value;

            if (!variable) {
                alert('請選擇要分析的數值變數');
                return;
            }

            if (usl === null && lsl === null) {
                alert('請至少輸入一項規格限制 (USL 或 LSL)');
                return;
            }

            // Extract data values
            const values = jsonData
                .map(row => parseFloat(row[variable]))
                .filter(v => !isNaN(v) && isFinite(v));

            if (values.length < 2) {
                alert('有效資料點不足，需至少 2 筆數據');
                return;
            }

            // Calculate basic statistics
            const n = values.length;
            const mean = ss.mean(values);
            const overallStdDev = ss.standardDeviation(values); // Pp/Ppk uses overall std dev
            const min = ss.min(values);
            const max = ss.max(values);
            const median = ss.median(values);

            // Calculate within-subgroup sigma for Cp/Cpk (short-term)
            let withinSigma = overallStdDev;
            if (subgroupSize > 1 && sigmaMethod === 'rbar') {
                // R-bar / d2 method for short-term sigma estimation
                const d2Table = { 2: 1.128, 3: 1.693, 4: 2.059, 5: 2.326, 6: 2.534, 7: 2.704, 8: 2.847, 9: 2.970, 10: 3.078 };
                const d2 = d2Table[subgroupSize] || d2Table[Math.min(subgroupSize, 10)];
                
                // Calculate range for each subgroup
                const numSubgroups = Math.floor(n / subgroupSize);
                let rangeSum = 0;
                for (let i = 0; i < numSubgroups; i++) {
                    const subgroup = values.slice(i * subgroupSize, (i + 1) * subgroupSize);
                    rangeSum += ss.max(subgroup) - ss.min(subgroup);
                }
                const rBar = rangeSum / numSubgroups;
                withinSigma = rBar / d2;
            } else {
                // Pooled standard deviation approach
                withinSigma = overallStdDev;
            }

            // Calculate Cp, Cpk (short-term, within)
            let cp = null, cpk = null, cpu = null, cpl = null;
            if (usl !== null && lsl !== null) {
                cp = (usl - lsl) / (6 * withinSigma);
                cpu = (usl - mean) / (3 * withinSigma);
                cpl = (mean - lsl) / (3 * withinSigma);
                cpk = Math.min(cpu, cpl);
            } else if (usl !== null) {
                cpu = (usl - mean) / (3 * withinSigma);
                cpk = cpu;
            } else if (lsl !== null) {
                cpl = (mean - lsl) / (3 * withinSigma);
                cpk = cpl;
            }

            // Calculate Pp, Ppk (long-term, overall)
            let pp = null, ppk = null, ppu = null, ppl = null;
            if (usl !== null && lsl !== null) {
                pp = (usl - lsl) / (6 * overallStdDev);
                ppu = (usl - mean) / (3 * overallStdDev);
                ppl = (mean - lsl) / (3 * overallStdDev);
                ppk = Math.min(ppu, ppl);
            } else if (usl !== null) {
                ppu = (usl - mean) / (3 * overallStdDev);
                ppk = ppu;
            } else if (lsl !== null) {
                ppl = (mean - lsl) / (3 * overallStdDev);
                ppk = ppl;
            }

            // Calculate Cpm if target is specified (Taguchi capability index)
            let cpm = null;
            if (target !== null && usl !== null && lsl !== null) {
                const tau = Math.sqrt(Math.pow(overallStdDev, 2) + Math.pow(mean - target, 2));
                cpm = (usl - lsl) / (6 * tau);
            }

            // Estimate defect rate (PPM - Parts Per Million)
            let ppmTotal = null;
            if (usl !== null && lsl !== null) {
                const zUpper = (usl - mean) / overallStdDev;
                const zLower = (mean - lsl) / overallStdDev;
                const pAboveUSL = 1 - jStat.normal.cdf(zUpper, 0, 1);
                const pBelowLSL = jStat.normal.cdf(-zLower, 0, 1);
                ppmTotal = (pAboveUSL + pBelowLSL) * 1000000;
            } else if (usl !== null) {
                const zUpper = (usl - mean) / overallStdDev;
                ppmTotal = (1 - jStat.normal.cdf(zUpper, 0, 1)) * 1000000;
            } else if (lsl !== null) {
                const zLower = (mean - lsl) / overallStdDev;
                ppmTotal = jStat.normal.cdf(-zLower, 0, 1) * 1000000;
            }

            // Display results
            const resultsDiv = document.getElementById('processCapabilityResults');
            resultsDiv.classList.remove('hidden');

            // Metrics Cards
            const metricsCardsDiv = document.getElementById('pcMetricsCards');
            const getColorClass = (value) => {
                if (value >= 1.67) return 'bg-green-500';
                if (value >= 1.33) return 'bg-emerald-400';
                if (value >= 1.0) return 'bg-yellow-400';
                return 'bg-red-500';
            };

            const getGradeText = (value) => {
                if (value >= 1.67) return '優秀';
                if (value >= 1.33) return '良好';
                if (value >= 1.0) return '尚可';
                return '不足';
            };

            let cardsHtml = '';
            if (cp !== null) {
                cardsHtml += `
                    <div class="bg-white border rounded-lg p-4 text-center shadow-sm">
                        <h4 class="text-sm font-medium text-gray-500 mb-1">Cp (製程精密度)</h4>
                        <p class="text-3xl font-bold ${getColorClass(cp)} text-white px-2 py-1 rounded inline-block">${cp.toFixed(3)}</p>
                        <p class="text-xs text-gray-400 mt-1">${getGradeText(cp)}</p>
                    </div>`;
            }
            if (cpk !== null) {
                cardsHtml += `
                    <div class="bg-white border rounded-lg p-4 text-center shadow-sm">
                        <h4 class="text-sm font-medium text-gray-500 mb-1">Cpk (製程能力指標)</h4>
                        <p class="text-3xl font-bold ${getColorClass(cpk)} text-white px-2 py-1 rounded inline-block">${cpk.toFixed(3)}</p>
                        <p class="text-xs text-gray-400 mt-1">${getGradeText(cpk)}</p>
                    </div>`;
            }
            if (pp !== null) {
                cardsHtml += `
                    <div class="bg-white border rounded-lg p-4 text-center shadow-sm">
                        <h4 class="text-sm font-medium text-gray-500 mb-1">Pp (整體精密度)</h4>
                        <p class="text-3xl font-bold ${getColorClass(pp)} text-white px-2 py-1 rounded inline-block">${pp.toFixed(3)}</p>
                        <p class="text-xs text-gray-400 mt-1">${getGradeText(pp)}</p>
                    </div>`;
            }
            if (ppk !== null) {
                cardsHtml += `
                    <div class="bg-white border rounded-lg p-4 text-center shadow-sm">
                        <h4 class="text-sm font-medium text-gray-500 mb-1">Ppk (整體能力指標)</h4>
                        <p class="text-3xl font-bold ${getColorClass(ppk)} text-white px-2 py-1 rounded inline-block">${ppk.toFixed(3)}</p>
                        <p class="text-xs text-gray-400 mt-1">${getGradeText(ppk)}</p>
                    </div>`;
            }
            metricsCardsDiv.innerHTML = cardsHtml;

            // Statistics Summary
            const statsSummaryDiv = document.getElementById('pcStatsSummary');
            let statsHtml = `
                <h4 class="font-semibold mb-3">📊 統計摘要</h4>
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
                    <div><span class="text-gray-500">樣本數 (n):</span> <strong>${n}</strong></div>
                    <div><span class="text-gray-500">平均數 (μ):</span> <strong>${mean.toFixed(4)}</strong></div>
                    <div><span class="text-gray-500">標準差 (σ):</span> <strong>${overallStdDev.toFixed(4)}</strong></div>
                    <div><span class="text-gray-500">中位數:</span> <strong>${median.toFixed(4)}</strong></div>
                    <div><span class="text-gray-500">最小值:</span> <strong>${min.toFixed(4)}</strong></div>
                    <div><span class="text-gray-500">最大值:</span> <strong>${max.toFixed(4)}</strong></div>
                    <div><span class="text-gray-500">USL:</span> <strong>${usl !== null ? usl.toFixed(4) : '-'}</strong></div>
                    <div><span class="text-gray-500">LSL:</span> <strong>${lsl !== null ? lsl.toFixed(4) : '-'}</strong></div>
                </div>`;
            
            if (cpm !== null) {
                statsHtml += `<p class="mt-3 text-sm"><span class="text-gray-500">Cpm (田口指標):</span> <strong>${cpm.toFixed(3)}</strong></p>`;
            }
            if (ppmTotal !== null) {
                statsHtml += `<p class="mt-1 text-sm"><span class="text-gray-500">預估不良率 (PPM):</span> <strong>${ppmTotal.toFixed(1)} ppm</strong> (每百萬件 ${ppmTotal.toFixed(1)} 件不良)</p>`;
            }
            statsSummaryDiv.innerHTML = statsHtml;

            // Histogram with specification limits
            const histogramTrace = {
                x: values,
                type: 'histogram',
                name: '分佈',
                marker: { color: 'rgba(59, 130, 246, 0.7)', line: { color: 'rgba(59, 130, 246, 1)', width: 1 } },
                opacity: 0.75
            };

            // Normal distribution curve
            const xRange = max - min;
            const xMin = min - xRange * 0.2;
            const xMax = max + xRange * 0.2;
            const xCurve = [];
            const yCurve = [];
            const numPoints = 100;
            for (let i = 0; i <= numPoints; i++) {
                const x = xMin + (xMax - xMin) * i / numPoints;
                xCurve.push(x);
                const y = jStat.normal.pdf(x, mean, overallStdDev);
                yCurve.push(y);
            }

            // Scale normal curve to match histogram
            const binWidth = (max - min) / 30;
            const scaleFactor = n * binWidth;
            const yScaled = yCurve.map(y => y * scaleFactor);

            const normalCurveTrace = {
                x: xCurve,
                y: yScaled,
                type: 'scatter',
                mode: 'lines',
                name: '常態分佈',
                line: { color: '#374151', width: 2 }
            };

            const shapes = [];
            const annotations = [];

            if (lsl !== null) {
                shapes.push({
                    type: 'line', x0: lsl, x1: lsl, y0: 0, y1: 1, yref: 'paper',
                    line: { color: 'red', width: 2, dash: 'dash' }
                });
                annotations.push({
                    x: lsl, y: 1, yref: 'paper', text: `LSL: ${lsl}`,
                    showarrow: false, yanchor: 'bottom', font: { color: 'red', size: 11 }
                });
            }

            if (usl !== null) {
                shapes.push({
                    type: 'line', x0: usl, x1: usl, y0: 0, y1: 1, yref: 'paper',
                    line: { color: 'red', width: 2, dash: 'dash' }
                });
                annotations.push({
                    x: usl, y: 1, yref: 'paper', text: `USL: ${usl}`,
                    showarrow: false, yanchor: 'bottom', font: { color: 'red', size: 11 }
                });
            }

            if (target !== null) {
                shapes.push({
                    type: 'line', x0: target, x1: target, y0: 0, y1: 1, yref: 'paper',
                    line: { color: 'green', width: 2, dash: 'dot' }
                });
                annotations.push({
                    x: target, y: 0.95, yref: 'paper', text: `Target: ${target}`,
                    showarrow: false, yanchor: 'bottom', font: { color: 'green', size: 11 }
                });
            }

            // Mean line
            shapes.push({
                type: 'line', x0: mean, x1: mean, y0: 0, y1: 1, yref: 'paper',
                line: { color: '#2563eb', width: 2 }
            });
            annotations.push({
                x: mean, y: 0.9, yref: 'paper', text: `μ: ${mean.toFixed(3)}`,
                showarrow: false, yanchor: 'bottom', font: { color: '#2563eb', size: 11 }
            });

            const layout = {
                title: `${variable} - 製程能力分析`,
                xaxis: { title: variable },
                yaxis: { title: '頻率' },
                shapes: shapes,
                annotations: annotations,
                showlegend: true,
                legend: { orientation: 'h', y: -0.2 },
                margin: { t: 60, b: 80 }
            };

            Plotly.newPlot('pcHistogramChart', [histogramTrace, normalCurveTrace], layout, { responsive: true });

            // Interpretation
            const interpDiv = document.getElementById('pcInterpretation');
            let interpHtml = '<h4 class="font-semibold mb-3">📋 指標解讀</h4><ul class="space-y-2 text-sm">';

            if (cpk !== null) {
                if (cpk >= 1.67) {
                    interpHtml += '<li class="text-green-700">✅ <strong>Cpk ≥ 1.67:</strong> 製程能力優秀，超過 Six Sigma 水準。</li>';
                } else if (cpk >= 1.33) {
                    interpHtml += '<li class="text-emerald-600">✅ <strong>Cpk ≥ 1.33:</strong> 製程能力良好，符合一般品質要求。</li>';
                } else if (cpk >= 1.0) {
                    interpHtml += '<li class="text-yellow-600">⚠️ <strong>Cpk ≥ 1.0:</strong> 製程能力尚可，但需注意改善空間。</li>';
                } else {
                    interpHtml += '<li class="text-red-600">❌ <strong>Cpk < 1.0:</strong> 製程能力不足，有顯著不良風險，需立即改善。</li>';
                }
            }

            if (cp !== null && cpk !== null && cp > 0) {
                const centering = cpk / cp;
                if (centering < 0.8) {
                    interpHtml += `<li class="text-orange-600">⚠️ <strong>製程偏移:</strong> Cpk/Cp = ${centering.toFixed(2)}，表示製程中心偏離規格中心，建議調整製程設定。</li>`;
                } else {
                    interpHtml += `<li class="text-gray-600">ℹ️ <strong>製程置中良好:</strong> Cpk/Cp = ${centering.toFixed(2)}，製程中心接近規格中心。</li>`;
                }
            }

            if (pp !== null && cp !== null) {
                const ratio = pp / cp;
                if (ratio < 0.75) {
                    interpHtml += '<li class="text-orange-600">⚠️ <strong>長短期變異差異大:</strong> Pp/Cp 比值較低，可能存在特殊原因變異，需進一步調查。</li>';
                }
            }

            if (ppmTotal !== null) {
                if (ppmTotal < 3.4) {
                    interpHtml += `<li class="text-green-700">🎯 <strong>卓越品質:</strong> 預估不良率 ${ppmTotal.toFixed(1)} PPM，達到 Six Sigma 水準。</li>`;
                } else if (ppmTotal < 233) {
                    interpHtml += `<li class="text-emerald-600">👍 <strong>良好品質:</strong> 預估不良率 ${ppmTotal.toFixed(1)} PPM。</li>`;
                } else if (ppmTotal < 6210) {
                    interpHtml += `<li class="text-yellow-600">⚠️ <strong>需改善:</strong> 預估不良率 ${ppmTotal.toFixed(1)} PPM，約 3 Sigma 水準。</li>`;
                } else {
                    interpHtml += `<li class="text-red-600">❌ <strong>品質警告:</strong> 預估不良率 ${ppmTotal.toFixed(1)} PPM，需立即採取改善行動。</li>`;
                }
            }

            interpHtml += '</ul>';
            interpHtml += `
                <div class="mt-4 text-xs text-gray-500 border-t pt-3">
                    <p><strong>指標說明：</strong></p>
                    <ul class="list-disc list-inside space-y-1">
                        <li><strong>Cp:</strong> 製程精密度，衡量製程變異相對於規格寬度的比例</li>
                        <li><strong>Cpk:</strong> 製程能力指標，考慮製程中心與規格中心的偏移</li>
                        <li><strong>Pp:</strong> 整體精密度，使用長期標準差計算</li>
                        <li><strong>Ppk:</strong> 整體能力指標，反映實際觀察到的製程表現</li>
                        <li><strong>PPM:</strong> 百萬分之不良率 (Parts Per Million)</li>
                    </ul>
                </div>`;
            interpDiv.innerHTML = interpHtml;
        }

        // ============================================
        // 管制圖 (Control Chart: X-bar & R Chart)
        // ============================================
        
        // Control Chart Constants Table
        const CONTROL_CHART_CONSTANTS = {
            2:  { A2: 1.880, D3: 0,     D4: 3.267, d2: 1.128 },
            3:  { A2: 1.023, D3: 0,     D4: 2.574, d2: 1.693 },
            4:  { A2: 0.729, D3: 0,     D4: 2.282, d2: 2.059 },
            5:  { A2: 0.577, D3: 0,     D4: 2.114, d2: 2.326 },
            6:  { A2: 0.483, D3: 0,     D4: 2.004, d2: 2.534 },
            7:  { A2: 0.419, D3: 0.076, D4: 1.924, d2: 2.704 },
            8:  { A2: 0.373, D3: 0.136, D4: 1.864, d2: 2.847 },
            9:  { A2: 0.337, D3: 0.184, D4: 1.816, d2: 2.970 },
            10: { A2: 0.308, D3: 0.223, D4: 1.777, d2: 3.078 }
        };

        function runControlChart() {
            if (!jsonData || jsonData.length === 0) {
                alert('請先載入資料');
                return;
            }

            const variable = document.getElementById('ccVariable').value;
            const subgroupSize = parseInt(document.getElementById('ccSubgroupSize').value) || 5;
            const sigmaLevel = parseInt(document.getElementById('ccSigmaLevel').value) || 3;
            const showWarning = document.getElementById('ccShowWarningLimits').checked;

            if (!variable) {
                alert('請選擇要分析的數值變數');
                return;
            }

            if (subgroupSize < 1 || subgroupSize > 10) {
                alert('子群組大小需介於 1 到 10 之間');
                return;
            }

            // Extract data values
            const values = jsonData
                .map(row => parseFloat(row[variable]))
                .filter(v => !isNaN(v) && isFinite(v));

            // Determine chart type
            const isIMR = subgroupSize === 1;

            if (isIMR) {
                // I-MR Chart: need at least 3 data points
                if (values.length < 3) {
                    alert('I-MR Chart 需至少 3 筆數據');
                    return;
                }
            } else {
                // X-bar R Chart: need at least 2 subgroups
                if (values.length < subgroupSize * 2) {
                    alert(`有效資料點不足，需至少 ${subgroupSize * 2} 筆數據 (至少 2 個子群組)`);
                    return;
                }
            }

            let xbars, ranges, xDoublebar, rBar, numSubgroups;
            let xbarUCL, xbarLCL, xbarCL, xbarUWL, xbarLWL;
            let rUCL_actual, rLCL_actual, rCL, rUWL, rLWL;
            let chartTypeLabel, xChartLabel, rChartLabel;

            if (isIMR) {
                // I-MR Chart (Individual-Moving Range)
                chartTypeLabel = 'I-MR Chart';
                xChartLabel = 'I Chart (個別值)';
                rChartLabel = 'MR Chart (移動全距)';

                // Individual values are the xbars
                xbars = values.slice();
                numSubgroups = values.length;

                // Calculate moving ranges (consecutive differences)
                ranges = [];
                for (let i = 1; i < values.length; i++) {
                    ranges.push(Math.abs(values[i] - values[i - 1]));
                }

                // Moving range average: R̄m = ΣRm / (n-1)
                rBar = ss.mean(ranges);
                xDoublebar = ss.mean(xbars);

                // I-MR Constants (based on n=2 for moving range)
                // E2 = 2.66 = 3/d2 where d2 = 1.128
                // D4 = 3.268 for n=2, D3 = 0
                const E2 = 2.66;
                const D4_MR = 3.268;
                const D3_MR = 0;

                // X (Individual) Chart Limits
                const sigmaFactor = sigmaLevel === 2 ? (2/3) : 1;
                xbarUCL = xDoublebar + sigmaFactor * E2 * rBar;
                xbarLCL = xDoublebar - sigmaFactor * E2 * rBar;
                xbarCL = xDoublebar;

                // Warning limits (2σ)
                xbarUWL = xDoublebar + (2/3) * E2 * rBar;
                xbarLWL = xDoublebar - (2/3) * E2 * rBar;

                // MR Chart Limits
                rCL = rBar;
                rUCL_actual = sigmaLevel === 2 ? rBar + (2/3) * (D4_MR - 1) * rBar : D4_MR * rBar;
                rLCL_actual = 0; // LCL for MR is always 0

                // Warning limits for MR chart
                rUWL = rBar + (2/3) * (D4_MR - 1) * rBar;
                rLWL = 0;

            } else {
                // X-bar R Chart
                chartTypeLabel = 'X̄-R Chart';
                xChartLabel = 'X̄ Chart (子群組平均)';
                rChartLabel = 'R Chart (全距)';

                // Get control chart constants
                const constants = CONTROL_CHART_CONSTANTS[subgroupSize];
                const { A2, D3, D4, d2 } = constants;

                // Create subgroups
                numSubgroups = Math.floor(values.length / subgroupSize);
                const subgroups = [];
                for (let i = 0; i < numSubgroups; i++) {
                    subgroups.push(values.slice(i * subgroupSize, (i + 1) * subgroupSize));
                }

                // Calculate subgroup statistics
                xbars = subgroups.map(sg => ss.mean(sg));
                ranges = subgroups.map(sg => ss.max(sg) - ss.min(sg));

                // Calculate grand mean (X double bar) and R-bar
                xDoublebar = ss.mean(xbars);
                rBar = ss.mean(ranges);

                // Calculate control limits for X-bar chart
                const sigmaFactor = sigmaLevel === 2 ? (2/3) : 1;
                xbarUCL = xDoublebar + sigmaFactor * A2 * rBar;
                xbarLCL = xDoublebar - sigmaFactor * A2 * rBar;
                xbarCL = xDoublebar;

                // Warning limits (2σ)
                xbarUWL = xDoublebar + (2/3) * A2 * rBar;
                xbarLWL = xDoublebar - (2/3) * A2 * rBar;

                // Calculate control limits for R chart
                rCL = rBar;
                rUCL_actual = sigmaLevel === 2 ? rBar + (2/3) * (D4 - 1) * rBar : D4 * rBar;
                rLCL_actual = Math.max(0, sigmaLevel === 2 ? rBar - (2/3) * (1 - D3) * rBar : D3 * rBar);

                // Warning limits for R chart
                rUWL = rBar + (2/3) * (D4 - 1) * rBar;
                rLWL = Math.max(0, rBar - (2/3) * (1 - D3) * rBar);
            }

            // Detect out-of-control points for X/I chart
            const xbarOOC = xbars.map((x, i) => ({
                index: i + 1,
                value: x,
                outOfControl: x > xbarUCL || x < xbarLCL
            })).filter(p => p.outOfControl);

            // Detect out-of-control points for R/MR chart
            const rOOC = ranges.map((r, i) => ({
                index: isIMR ? i + 2 : i + 1, // MR starts at index 2 (between point 1 and 2)
                value: r,
                outOfControl: r > rUCL_actual || r < rLCL_actual
            })).filter(p => p.outOfControl);

            // Display results
            const resultsDiv = document.getElementById('controlChartResults');
            resultsDiv.classList.remove('hidden');

            // Status Summary
            const statusDiv = document.getElementById('ccStatusSummary');
            const totalOOC = xbarOOC.length + rOOC.length;
            const inControl = totalOOC === 0;
            statusDiv.innerHTML = `
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div class="p-4 ${inControl ? 'bg-green-50 border-l-4 border-green-500' : 'bg-red-50 border-l-4 border-red-500'} rounded-r-lg">
                        <h4 class="font-bold ${inControl ? 'text-green-800' : 'text-red-800'}">製程狀態</h4>
                        <p class="text-2xl font-semibold ${inControl ? 'text-green-700' : 'text-red-700'}">${inControl ? '✓ 統計管制內' : '⚠ 管制外'}</p>
                    </div>
                    <div class="p-4 bg-blue-50 border-l-4 border-blue-500 rounded-r-lg">
                        <h4 class="font-bold text-blue-800">子群組數量</h4>
                        <p class="text-2xl font-semibold text-blue-700">${numSubgroups}</p>
                        <p class="text-xs text-gray-500">${isIMR ? '個別值' : '每組 ' + subgroupSize + ' 筆數據'}</p>
                    </div>
                    <div class="p-4 bg-purple-50 border-l-4 border-purple-500 rounded-r-lg">
                        <h4 class="font-bold text-purple-800">異常點數量</h4>
                        <p class="text-2xl font-semibold text-purple-700">${totalOOC}</p>
                        <p class="text-xs text-gray-500">${isIMR ? 'I' : 'X̄'}: ${xbarOOC.length}, ${isIMR ? 'MR' : 'R'}: ${rOOC.length}</p>
                    </div>
                </div>
            `;

            // Create indices for x-axis
            const xIndices = Array.from({ length: xbars.length }, (_, i) => i + 1);
            const rIndices = isIMR ? Array.from({ length: ranges.length }, (_, i) => i + 2) : xIndices;

            // X/I Chart
            const xbarTraces = [
                {
                    x: xIndices,
                    y: xbars,
                    mode: 'lines+markers',
                    name: isIMR ? 'X (個別值)' : 'X̄ (子群組平均)',
                    line: { color: '#3B82F6', width: 2 },
                    marker: { size: 8 }
                },
                {
                    x: xIndices,
                    y: Array(xbars.length).fill(xbarUCL),
                    mode: 'lines',
                    name: `UCL (${xbarUCL.toFixed(4)})`,
                    line: { color: '#EF4444', dash: 'dash', width: 2 }
                },
                {
                    x: xIndices,
                    y: Array(xbars.length).fill(xbarCL),
                    mode: 'lines',
                    name: `CL (${xbarCL.toFixed(4)})`,
                    line: { color: '#10B981', width: 2 }
                },
                {
                    x: xIndices,
                    y: Array(xbars.length).fill(xbarLCL),
                    mode: 'lines',
                    name: `LCL (${xbarLCL.toFixed(4)})`,
                    line: { color: '#EF4444', dash: 'dash', width: 2 }
                }
            ];

            // Add warning limits if enabled
            if (showWarning) {
                xbarTraces.push(
                    {
                        x: xIndices,
                        y: Array(xbars.length).fill(xbarUWL),
                        mode: 'lines',
                        name: `UWL (${xbarUWL.toFixed(4)})`,
                        line: { color: '#F59E0B', dash: 'dot', width: 1 }
                    },
                    {
                        x: xIndices,
                        y: Array(xbars.length).fill(xbarLWL),
                        mode: 'lines',
                        name: `LWL (${xbarLWL.toFixed(4)})`,
                        line: { color: '#F59E0B', dash: 'dot', width: 1 }
                    }
                );
            }

            // Add specification lines for I-MR chart (n=1)
            if (isIMR) {
                const uslInput = document.getElementById('ccSpecUSL');
                const targetInput = document.getElementById('ccSpecTarget');
                const lslInput = document.getElementById('ccSpecLSL');
                
                console.log('Input elements found:', { 
                    uslExists: !!uslInput, 
                    targetExists: !!targetInput, 
                    lslExists: !!lslInput,
                    uslValue: uslInput ? uslInput.value : 'N/A',
                    targetValue: targetInput ? targetInput.value : 'N/A',
                    lslValue: lslInput ? lslInput.value : 'N/A'
                });
                
                const uslVal = uslInput && uslInput.value !== '' ? parseFloat(uslInput.value) : NaN;
                const targetVal = targetInput && targetInput.value !== '' ? parseFloat(targetInput.value) : NaN;
                const lslVal = lslInput && lslInput.value !== '' ? parseFloat(lslInput.value) : NaN;

                console.log('Spec lines values:', { uslVal, targetVal, lslVal });

                if (!isNaN(uslVal)) {
                    xbarTraces.push({
                        x: xIndices,
                        y: Array(xbars.length).fill(uslVal),
                        mode: 'lines',
                        name: `📐 USL: ${uslVal}`,
                        line: { color: '#EA580C', width: 2.5, dash: 'dashdot' },
                        legendgroup: 'spec'
                    });
                }
                if (!isNaN(targetVal)) {
                    xbarTraces.push({
                        x: xIndices,
                        y: Array(xbars.length).fill(targetVal),
                        mode: 'lines',
                        name: `🎯 Target: ${targetVal}`,
                        line: { color: '#7C3AED', width: 2.5, dash: 'dot' },
                        legendgroup: 'spec'
                    });
                }
                if (!isNaN(lslVal)) {
                    xbarTraces.push({
                        x: xIndices,
                        y: Array(xbars.length).fill(lslVal),
                        mode: 'lines',
                        name: `📐 LSL: ${lslVal}`,
                        line: { color: '#EA580C', width: 2.5, dash: 'dashdot' },
                        legendgroup: 'spec'
                    });
                }
            }

            // Highlight out-of-control points
            if (xbarOOC.length > 0) {
                xbarTraces.push({
                    x: xbarOOC.map(p => p.index),
                    y: xbarOOC.map(p => p.value),
                    mode: 'markers',
                    name: '異常點',
                    marker: { color: '#EF4444', size: 12, symbol: 'circle-open', line: { width: 3 } }
                });
            }

            const xbarLayout = {
                title: `${isIMR ? 'I Chart' : 'X̄ Chart'} - ${variable}`,
                xaxis: { title: isIMR ? '數據點編號' : '子群組編號', dtick: Math.ceil(xbars.length / 20) },
                yaxis: { title: isIMR ? 'X (個別值)' : 'X̄ (平均值)' },
                paper_bgcolor: '#f9f9f9',
                showlegend: true,
                legend: { 
                    orientation: 'v', 
                    x: 1.02, 
                    y: 1,
                    xanchor: 'left',
                    bgcolor: 'rgba(255,255,255,0.8)',
                    bordercolor: '#e0e0e0',
                    borderwidth: 1,
                    font: { size: 11 }
                },
                margin: { r: 150 } // Extra right margin for legend
            };

            Plotly.newPlot('ccXbarChart', xbarTraces, xbarLayout, { responsive: true });

            // R/MR Chart
            const rTraces = [
                {
                    x: rIndices,
                    y: ranges,
                    mode: 'lines+markers',
                    name: isIMR ? 'MR (移動全距)' : 'R (全距)',
                    line: { color: '#8B5CF6', width: 2 },
                    marker: { size: 8 }
                },
                {
                    x: rIndices,
                    y: Array(ranges.length).fill(rUCL_actual),
                    mode: 'lines',
                    name: `UCL (${rUCL_actual.toFixed(4)})`,
                    line: { color: '#EF4444', dash: 'dash', width: 2 }
                },
                {
                    x: rIndices,
                    y: Array(ranges.length).fill(rCL),
                    mode: 'lines',
                    name: `CL (${rCL.toFixed(4)})`,
                    line: { color: '#10B981', width: 2 }
                },
                {
                    x: rIndices,
                    y: Array(ranges.length).fill(rLCL_actual),
                    mode: 'lines',
                    name: `LCL (${rLCL_actual.toFixed(4)})`,
                    line: { color: '#EF4444', dash: 'dash', width: 2 }
                }
            ];

            // Add warning limits for R/MR chart if enabled
            if (showWarning) {
                rTraces.push(
                    {
                        x: rIndices,
                        y: Array(ranges.length).fill(rUWL),
                        mode: 'lines',
                        name: `UWL (${rUWL.toFixed(4)})`,
                        line: { color: '#F59E0B', dash: 'dot', width: 1 }
                    },
                    {
                        x: rIndices,
                        y: Array(ranges.length).fill(rLWL),
                        mode: 'lines',
                        name: `LWL (${rLWL.toFixed(4)})`,
                        line: { color: '#F59E0B', dash: 'dot', width: 1 }
                    }
                );
            }

            // Highlight out-of-control points for R chart
            if (rOOC.length > 0) {
                rTraces.push({
                    x: rOOC.map(p => p.index),
                    y: rOOC.map(p => p.value),
                    mode: 'markers',
                    name: '異常點',
                    marker: { color: '#EF4444', size: 12, symbol: 'circle-open', line: { width: 3 } }
                });
            }

            const rLayout = {
                title: `${isIMR ? 'MR Chart' : 'R Chart'} - ${variable}`,
                xaxis: { title: isIMR ? '數據點編號' : '子群組編號', dtick: Math.ceil(ranges.length / 20) },
                yaxis: { title: isIMR ? 'MR (移動全距)' : 'R (全距)', rangemode: 'tozero' },
                paper_bgcolor: '#f9f9f9',
                showlegend: true,
                legend: { orientation: 'h', y: -0.2 }
            };

            Plotly.newPlot('ccRChart', rTraces, rLayout, { responsive: true });

            // Control Limits Table
            const limitsTable = document.getElementById('ccControlLimitsTable');
            const constantsInfo = isIMR 
                ? `<div><strong>E₂:</strong> 2.66</div><div><strong>D₄ (MR):</strong> 3.268</div>`
                : `<div><strong>A₂:</strong> ${CONTROL_CHART_CONSTANTS[subgroupSize].A2}</div><div><strong>D₃:</strong> ${CONTROL_CHART_CONSTANTS[subgroupSize].D3}, <strong>D₄:</strong> ${CONTROL_CHART_CONSTANTS[subgroupSize].D4}</div>`;
            
            limitsTable.innerHTML = `
                <h4 class="font-semibold mb-3">📊 管制限摘要 (${isIMR ? 'I-MR Chart' : 'X̄-R Chart'})</h4>
                <div class="overflow-x-auto">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-50">
                            <tr>
                                <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">管制圖</th>
                                <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">UCL (管制上限)</th>
                                <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">CL (中心線)</th>
                                <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">LCL (管制下限)</th>
                            </tr>
                        </thead>
                        <tbody class="bg-white divide-y divide-gray-200">
                            <tr>
                                <td class="px-4 py-2 text-sm font-medium text-gray-900">${isIMR ? 'I Chart' : 'X̄ Chart'}</td>
                                <td class="px-4 py-2 text-sm text-gray-700">${xbarUCL.toFixed(4)}</td>
                                <td class="px-4 py-2 text-sm text-gray-700">${xbarCL.toFixed(4)}</td>
                                <td class="px-4 py-2 text-sm text-gray-700">${xbarLCL.toFixed(4)}</td>
                            </tr>
                            <tr>
                                <td class="px-4 py-2 text-sm font-medium text-gray-900">${isIMR ? 'MR Chart' : 'R Chart'}</td>
                                <td class="px-4 py-2 text-sm text-gray-700">${rUCL_actual.toFixed(4)}</td>
                                <td class="px-4 py-2 text-sm text-gray-700">${rCL.toFixed(4)}</td>
                                <td class="px-4 py-2 text-sm text-gray-700">${rLCL_actual.toFixed(4)}</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <div class="mt-4 grid grid-cols-2 md:grid-cols-4 gap-2 text-xs text-gray-600">
                    <div><strong>${isIMR ? 'X̄' : 'X̄̄'}:</strong> ${xDoublebar.toFixed(4)}</div>
                    <div><strong>${isIMR ? 'MR̄' : 'R̄'}:</strong> ${rBar.toFixed(4)}</div>
                    ${constantsInfo}
                </div>
            `;

            // Out-of-control details
            const oocDiv = document.getElementById('ccOutOfControlDetails');
            if (totalOOC > 0) {
                oocDiv.classList.remove('hidden');
                let oocHtml = '<h4 class="font-semibold mb-3 text-yellow-800">⚠️ 異常點詳細資訊</h4>';
                
                if (xbarOOC.length > 0) {
                    oocHtml += `<div class="mb-2"><strong>${isIMR ? 'I Chart' : 'X̄ Chart'} 異常點:</strong><ul class="list-disc ml-6 text-sm">`;
                    xbarOOC.forEach(p => {
                        const violation = p.value > xbarUCL ? '超出 UCL' : '低於 LCL';
                        oocHtml += `<li>${isIMR ? '數據點' : '子群組'} #${p.index}: ${isIMR ? 'X' : 'X̄'} = ${p.value.toFixed(4)} (${violation})</li>`;
                    });
                    oocHtml += '</ul></div>';
                }
                
                if (rOOC.length > 0) {
                    oocHtml += `<div><strong>${isIMR ? 'MR Chart' : 'R Chart'} 異常點:</strong><ul class="list-disc ml-6 text-sm">`;
                    rOOC.forEach(p => {
                        const violation = p.value > rUCL_actual ? '超出 UCL' : '低於 LCL';
                        oocHtml += `<li>${isIMR ? '數據點' : '子群組'} #${p.index}: ${isIMR ? 'MR' : 'R'} = ${p.value.toFixed(4)} (${violation})</li>`;
                    });
                    oocHtml += '</ul></div>';
                }
                
                oocHtml += `
                    <div class="mt-3 text-sm text-gray-600">
                        <strong>建議:</strong> 針對異常點進行根本原因分析 (Root Cause Analysis)，檢查是否存在特殊原因變異。
                    </div>
                `;
                oocDiv.innerHTML = oocHtml;
            } else {
                oocDiv.classList.add('hidden');
            }
        }

        // ============================================
        // 多維度泡泡圖 (Multi-dimensional Bubble Chart)
        // ============================================
                // ============================================
        // 線性規劃 (Linear Programming)
        // ============================================

        function setupLPRemoveConstraintListeners() {
            document.querySelectorAll('.lp-remove-constraint').forEach(btn => {
                btn.onclick = function() {
                    if (document.querySelectorAll('.constraint-row').length > 1) {
                        this.closest('.constraint-row').remove();
                        renumberConstraints();
                    } else {
                        alert('至少需要保留一個約束條件');
                    }
                };
            });
        }

        function renumberConstraints() {
            document.querySelectorAll('.constraint-row').forEach((row, idx) => {
                row.querySelector('.text-sm.font-medium').textContent = `約束 ${idx + 1}:`;
            });
        }

        function updateLPVariableInputs() {
            const numVars = parseInt(document.getElementById('lpNumVariables').value);
            
            // Update variable names
            const varNamesContainer = document.getElementById('lpVariableNames');
            let varNamesHtml = '';
            for (let i = 1; i <= numVars; i++) {
                const defaultName = ['產品A', '產品B', '產品C', '產品D', '產品E'][i-1] || `變數${i}`;
                varNamesHtml += `
                    <div>
                        <label class="block text-xs text-gray-600">變數 x₍${i}₎ 名稱</label>
                        <input type="text" id="lpVar${i}Name" value="${defaultName}" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm text-sm">
                    </div>
                `;
            }
            varNamesContainer.innerHTML = varNamesHtml;

            // Update objective coefficients
            const coefContainer = document.getElementById('lpObjectiveCoefficients');
            let coefHtml = '';
            for (let i = 1; i <= numVars; i++) {
                const defaultVal = [40, 30, 25, 20, 15][i-1] || 10;
                coefHtml += `
                    <div>
                        <label class="block text-xs text-gray-600">x₍${i}₎ 係數 (c₍${i}₎)</label>
                        <input type="number" id="lpCoef${i}" value="${defaultVal}" step="any" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm text-sm">
                    </div>
                `;
            }
            coefContainer.innerHTML = coefHtml;

            // Update constraints
            document.querySelectorAll('.constraint-row').forEach(row => {
                const coefInputs = row.querySelectorAll('.lp-constraint-coef');
                const currentCount = coefInputs.length;
                
                if (currentCount < numVars) {
                    // Add more coefficient inputs
                    const lastCoef = coefInputs[coefInputs.length - 1];
                    for (let i = currentCount; i < numVars; i++) {
                        const span = document.createElement('span');
                        span.className = 'text-xs';
                        span.textContent = ` + `;
                        lastCoef.parentNode.insertBefore(span, lastCoef.nextSibling.nextSibling);
                        
                        const input = document.createElement('input');
                        input.type = 'number';
                        input.className = 'lp-constraint-coef w-16 rounded border-gray-300 text-sm';
                        input.placeholder = `a₍${i+1}₎`;
                        input.value = '0';
                        span.parentNode.insertBefore(input, span.nextSibling);
                        
                        const varSpan = document.createElement('span');
                        varSpan.className = 'text-xs';
                        varSpan.textContent = `x₍${i+1}₎`;
                        input.parentNode.insertBefore(varSpan, input.nextSibling);
                    }
                }
            });
        }

        function addLPConstraint() {
            const numVars = parseInt(document.getElementById('lpNumVariables').value);
            const container = document.getElementById('lpConstraintsContainer');
            const constraintCount = container.querySelectorAll('.constraint-row').length + 1;
            
            let coefInputs = '';
            for (let i = 1; i <= numVars; i++) {
                const separator = i < numVars ? ' +' : '';
                coefInputs += `
                    <input type="number" class="lp-constraint-coef w-16 rounded border-gray-300 text-sm" placeholder="a₍${constraintCount}${i}₎" value="0">
                    <span class="text-xs">x₍${i}₎${separator}</span>
                `;
            }
            
            const newRow = document.createElement('div');
            newRow.className = 'constraint-row flex flex-wrap items-center gap-2 bg-white p-3 rounded border';
            newRow.innerHTML = `
                <span class="text-sm font-medium w-16">約束 ${constraintCount}:</span>
                ${coefInputs}
                <select class="lp-constraint-op w-16 rounded border-gray-300 text-sm">
                    <option value="<=" selected>≤</option>
                    <option value=">=">≥</option>
                    <option value="=">=</option>
                </select>
                <input type="number" class="lp-constraint-rhs w-20 rounded border-gray-300 text-sm" placeholder="b₍${constraintCount}₎" value="0">
                <input type="text" class="lp-constraint-name flex-1 rounded border-gray-300 text-sm min-w-[100px]" placeholder="約束名稱">
                <button class="lp-remove-constraint text-red-500 hover:text-red-700 text-lg">✕</button>
            `;
            container.appendChild(newRow);
            setupLPRemoveConstraintListeners();
        }

        function loadLPExample() {
            // 茶飲公司範例：烏龍茶與綠茶
            // Reset to 2 variables
            document.getElementById('lpNumVariables').value = '2';
            updateLPVariableInputs();
            
            // Set variable names
            document.getElementById('lpVar1Name').value = 'A烏龍茶';
            document.getElementById('lpVar2Name').value = 'B綠茶';
            
            // Set objective coefficients (maximize profit)
            // A烏龍茶利益 200/個, B綠茶利益 100/個
            document.getElementById('lpCoef1').value = '200';
            document.getElementById('lpCoef2').value = '100';
            
            // Set maximize
            document.querySelector('input[name="lpObjective"][value="maximize"]').checked = true;
            
            // Clear existing constraints and add new ones
            const container = document.getElementById('lpConstraintsContainer');
            container.innerHTML = `
                <div class="constraint-row flex flex-wrap items-center gap-2 bg-white p-3 rounded border">
                    <span class="text-sm font-medium w-16">約束 1:</span>
                    <input type="number" class="lp-constraint-coef w-16 rounded border-gray-300 text-sm" value="200">
                    <span class="text-xs">x₁ +</span>
                    <input type="number" class="lp-constraint-coef w-16 rounded border-gray-300 text-sm" value="100">
                    <span class="text-xs">x₂</span>
                    <select class="lp-constraint-op w-16 rounded border-gray-300 text-sm">
                        <option value="<=">≤</option>
                        <option value=">=" selected>≥</option>
                        <option value="=">=</option>
                    </select>
                    <input type="number" class="lp-constraint-rhs w-20 rounded border-gray-300 text-sm" value="1500">
                    <input type="text" class="lp-constraint-name flex-1 rounded border-gray-300 text-sm min-w-[100px]" value="獲利至少">
                    <button class="lp-remove-constraint text-red-500 hover:text-red-700 text-lg">✕</button>
                </div>
                <div class="constraint-row flex flex-wrap items-center gap-2 bg-white p-3 rounded border">
                    <span class="text-sm font-medium w-16">約束 2:</span>
                    <input type="number" class="lp-constraint-coef w-16 rounded border-gray-300 text-sm" value="5">
                    <span class="text-xs">x₁ +</span>
                    <input type="number" class="lp-constraint-coef w-16 rounded border-gray-300 text-sm" value="4">
                    <span class="text-xs">x₂</span>
                    <select class="lp-constraint-op w-16 rounded border-gray-300 text-sm">
                        <option value="<=" selected>≤</option>
                        <option value=">=">≥</option>
                        <option value="=">=</option>
                    </select>
                    <input type="number" class="lp-constraint-rhs w-20 rounded border-gray-300 text-sm" value="50">
                    <input type="text" class="lp-constraint-name flex-1 rounded border-gray-300 text-sm min-w-[100px]" value="人工總和">
                    <button class="lp-remove-constraint text-red-500 hover:text-red-700 text-lg">✕</button>
                </div>
                <div class="constraint-row flex flex-wrap items-center gap-2 bg-white p-3 rounded border">
                    <span class="text-sm font-medium w-16">約束 3:</span>
                    <input type="number" class="lp-constraint-coef w-16 rounded border-gray-300 text-sm" value="1">
                    <span class="text-xs">x₁ +</span>
                    <input type="number" class="lp-constraint-coef w-16 rounded border-gray-300 text-sm" value="0">
                    <span class="text-xs">x₂</span>
                    <select class="lp-constraint-op w-16 rounded border-gray-300 text-sm">
                        <option value="<=">≤</option>
                        <option value=">=" selected>≥</option>
                        <option value="=">=</option>
                    </select>
                    <input type="number" class="lp-constraint-rhs w-20 rounded border-gray-300 text-sm" value="3">
                    <input type="text" class="lp-constraint-name flex-1 rounded border-gray-300 text-sm min-w-[100px]" value="A最小數量">
                    <button class="lp-remove-constraint text-red-500 hover:text-red-700 text-lg">✕</button>
                </div>
                <div class="constraint-row flex flex-wrap items-center gap-2 bg-white p-3 rounded border">
                    <span class="text-sm font-medium w-16">約束 4:</span>
                    <input type="number" class="lp-constraint-coef w-16 rounded border-gray-300 text-sm" value="0">
                    <span class="text-xs">x₁ +</span>
                    <input type="number" class="lp-constraint-coef w-16 rounded border-gray-300 text-sm" value="1">
                    <span class="text-xs">x₂</span>
                    <select class="lp-constraint-op w-16 rounded border-gray-300 text-sm">
                        <option value="<=">≤</option>
                        <option value=">=" selected>≥</option>
                        <option value="=">=</option>
                    </select>
                    <input type="number" class="lp-constraint-rhs w-20 rounded border-gray-300 text-sm" value="3">
                    <input type="text" class="lp-constraint-name flex-1 rounded border-gray-300 text-sm min-w-[100px]" value="B最小數量">
                    <button class="lp-remove-constraint text-red-500 hover:text-red-700 text-lg">✕</button>
                </div>
            `;
            setupLPRemoveConstraintListeners();
            
            // Enable integer constraint for this example
            const integerCheckbox = document.getElementById('lpIntegerConstraint');
            if (integerCheckbox) integerCheckbox.checked = true;
        }

        function runLinearProgramming() {
            const numVars = parseInt(document.getElementById('lpNumVariables').value);
            const isMaximize = document.querySelector('input[name="lpObjective"]:checked').value === 'maximize';
            
            // Get variable names
            const varNames = [];
            for (let i = 1; i <= numVars; i++) {
                const el = document.getElementById(`lpVar${i}Name`);
                varNames.push(el ? el.value || `x${i}` : `x${i}`);
            }
            
            // Get objective coefficients
            const objCoefs = [];
            for (let i = 1; i <= numVars; i++) {
                const el = document.getElementById(`lpCoef${i}`);
                objCoefs.push(el ? parseFloat(el.value) || 0 : 0);
            }
            
            // Get constraints
            const constraints = [];
            document.querySelectorAll('.constraint-row').forEach(row => {
                const coefs = Array.from(row.querySelectorAll('.lp-constraint-coef')).map(input => parseFloat(input.value) || 0);
                const op = row.querySelector('.lp-constraint-op').value;
                const rhs = parseFloat(row.querySelector('.lp-constraint-rhs').value) || 0;
                const name = row.querySelector('.lp-constraint-name').value || '';
                
                // Ensure we have the right number of coefficients
                while (coefs.length < numVars) coefs.push(0);
                
                constraints.push({ coefs: coefs.slice(0, numVars), op, rhs, name });
            });

            // Check if integer constraint is enabled
            const requireInteger = document.getElementById('lpIntegerConstraint')?.checked || false;

            // Solve the LP problem
            let result = solveLPSimplex(objCoefs, constraints, isMaximize);
            
            // If integer constraint is enabled, search for best integer solution
            if (requireInteger && result.feasible) {
                result = findIntegerSolution(objCoefs, constraints, isMaximize, result);
            }
            
            // Display results
            displayLPResults(result, varNames, objCoefs, constraints, isMaximize, numVars, requireInteger);
        }

        // Find best integer solution by searching around the continuous optimal
        function findIntegerSolution(c, constraints, isMaximize, continuousResult) {
            const numVars = c.length;
            const x = continuousResult.x;
            
            // Define search range around the continuous solution
            const searchRange = 3;
            let bestZ = isMaximize ? -Infinity : Infinity;
            let bestX = null;
            
            // For 2 variables, do a grid search around the optimal point
            if (numVars === 2) {
                const xBase = Math.floor(x[0]);
                const yBase = Math.floor(x[1]);
                
                for (let dx = -searchRange; dx <= searchRange + 1; dx++) {
                    for (let dy = -searchRange; dy <= searchRange + 1; dy++) {
                        const xi = Math.max(0, xBase + dx);
                        const yi = Math.max(0, yBase + dy);
                        
                        // Check feasibility
                        const feasible = constraints.every(con => {
                            const lhs = con.coefs[0] * xi + con.coefs[1] * yi;
                            if (con.op === '<=') return lhs <= con.rhs + 1e-6;
                            if (con.op === '>=') return lhs >= con.rhs - 1e-6;
                            return Math.abs(lhs - con.rhs) < 1e-6;
                        });
                        
                        if (feasible) {
                            const z = c[0] * xi + c[1] * yi;
                            if ((isMaximize && z > bestZ) || (!isMaximize && z < bestZ)) {
                                bestZ = z;
                                bestX = [xi, yi];
                            }
                        }
                    }
                }
            } else {
                // For more variables, try rounding combinations
                const floorX = x.map(v => Math.floor(v));
                const ceilX = x.map(v => Math.ceil(v));
                
                // Test combinations of floor and ceil
                const combinations = [];
                function generateCombinations(idx, current) {
                    if (idx === numVars) {
                        combinations.push([...current]);
                        return;
                    }
                    current.push(floorX[idx]);
                    generateCombinations(idx + 1, current);
                    current.pop();
                    current.push(ceilX[idx]);
                    generateCombinations(idx + 1, current);
                    current.pop();
                }
                generateCombinations(0, []);
                
                combinations.forEach(candidate => {
                    const feasible = constraints.every(con => {
                        let lhs = 0;
                        for (let i = 0; i < numVars; i++) {
                            lhs += con.coefs[i] * candidate[i];
                        }
                        if (con.op === '<=') return lhs <= con.rhs + 1e-6;
                        if (con.op === '>=') return lhs >= con.rhs - 1e-6;
                        return Math.abs(lhs - con.rhs) < 1e-6;
                    });
                    
                    if (feasible && candidate.every(v => v >= 0)) {
                        let z = 0;
                        for (let i = 0; i < numVars; i++) {
                            z += c[i] * candidate[i];
                        }
                        if ((isMaximize && z > bestZ) || (!isMaximize && z < bestZ)) {
                            bestZ = z;
                            bestX = candidate;
                        }
                    }
                });
            }
            
            if (bestX) {
                return {
                    ...continuousResult,
                    x: bestX,
                    z: bestZ,
                    isInteger: true
                };
            }
            
            return { feasible: false, message: '無可行整數解' };
        }

        function solveLPSimplex(objCoefs, constraints, isMaximize) {
            const numVars = objCoefs.length;
            const numConstraints = constraints.length;
            
            // Build extended tableau (adding slack/surplus variables)
            // For simplicity, we'll use a graphical method for 2 variables
            // and a simplified Simplex for more variables
            
            if (numVars === 2) {
                return solveLPGraphical(objCoefs, constraints, isMaximize);
            }
            
            // General Simplex implementation for more variables
            return solveLPSimplexGeneral(objCoefs, constraints, isMaximize);
        }

        function solveLPGraphical(c, constraints, isMaximize) {
            // Find corner points of feasible region
            // For LP with both <= and >= constraints, we need to find all intersections
            const cornerPoints = [];
            
            // Estimate bounds from constraints to search within reasonable range
            let maxX = 100, maxY = 100;
            constraints.forEach(con => {
                if (con.op === '<=' && con.coefs[0] > 0) {
                    maxX = Math.max(maxX, con.rhs / con.coefs[0] * 1.5);
                }
                if (con.op === '<=' && con.coefs[1] > 0) {
                    maxY = Math.max(maxY, con.rhs / con.coefs[1] * 1.5);
                }
            });
            
            // Add origin (0, 0)
            cornerPoints.push([0, 0]);
            
            // Find intersections with axes for ALL constraint types
            constraints.forEach(con => {
                // Intersection with x-axis (y = 0)
                if (con.coefs[0] !== 0) {
                    const x = con.rhs / con.coefs[0];
                    if (x >= 0 && x <= maxX) cornerPoints.push([x, 0]);
                }
                // Intersection with y-axis (x = 0)
                if (con.coefs[1] !== 0) {
                    const y = con.rhs / con.coefs[1];
                    if (y >= 0 && y <= maxY) cornerPoints.push([0, y]);
                }
            });
            
            // Add axis bounds
            cornerPoints.push([maxX, 0]);
            cornerPoints.push([0, maxY]);
            cornerPoints.push([maxX, maxY]);
            
            // Find intersections between constraint lines
            for (let i = 0; i < constraints.length; i++) {
                for (let j = i + 1; j < constraints.length; j++) {
                    const a1 = constraints[i].coefs[0], b1 = constraints[i].coefs[1], c1 = constraints[i].rhs;
                    const a2 = constraints[j].coefs[0], b2 = constraints[j].coefs[1], c2 = constraints[j].rhs;
                    
                    const det = a1 * b2 - a2 * b1;
                    if (Math.abs(det) > 1e-10) {
                        const x = (c1 * b2 - c2 * b1) / det;
                        const y = (a1 * c2 - a2 * c1) / det;
                        if (x >= -1e-10 && y >= -1e-10 && x <= maxX * 2 && y <= maxY * 2) {
                            cornerPoints.push([Math.max(0, x), Math.max(0, y)]);
                        }
                    }
                }
                
                // Also find intersections with x-axis and y-axis
                const a = constraints[i].coefs[0], b = constraints[i].coefs[1], cc = constraints[i].rhs;
                // Intersection with x-axis (y=0)
                if (Math.abs(a) > 1e-10) {
                    const x = cc / a;
                    if (x >= 0) cornerPoints.push([x, 0]);
                }
                // Intersection with y-axis (x=0)
                if (Math.abs(b) > 1e-10) {
                    const y = cc / b;
                    if (y >= 0) cornerPoints.push([0, y]);
                }
            }
            
            // Remove duplicate points
            const uniquePoints = [];
            cornerPoints.forEach(pt => {
                const exists = uniquePoints.some(p => 
                    Math.abs(p[0] - pt[0]) < 1e-6 && Math.abs(p[1] - pt[1]) < 1e-6
                );
                if (!exists) uniquePoints.push(pt);
            });
            
            // Filter to only feasible points
            const feasiblePoints = uniquePoints.filter(pt => {
                return constraints.every(con => {
                    const lhs = con.coefs[0] * pt[0] + con.coefs[1] * pt[1];
                    if (con.op === '<=') return lhs <= con.rhs + 1e-6;
                    if (con.op === '>=') return lhs >= con.rhs - 1e-6;
                    return Math.abs(lhs - con.rhs) < 1e-6;
                });
            });
            
            if (feasiblePoints.length === 0) {
                return { feasible: false, message: '無可行解 (Infeasible)' };
            }
            
            // Evaluate objective function at each corner point
            let optimalValue = isMaximize ? -Infinity : Infinity;
            let optimalPoint = null;
            
            feasiblePoints.forEach(pt => {
                const z = c[0] * pt[0] + c[1] * pt[1];
                if ((isMaximize && z > optimalValue) || (!isMaximize && z < optimalValue)) {
                    optimalValue = z;
                    optimalPoint = pt;
                }
            });
            
            return {
                feasible: true,
                optimal: true,
                x: optimalPoint,
                z: optimalValue,
                cornerPoints: feasiblePoints,
                constraints: constraints
            };
        }

        function solveLPSimplexGeneral(c, constraints, isMaximize) {
            // Simplified general Simplex (basic implementation)
            const numVars = c.length;
            const numConstraints = constraints.length;
            
            // Convert to standard form (all <= with slack variables)
            // This is a simplified version
            
            // For now, use corner point enumeration (works for small problems)
            const result = {
                feasible: true,
                optimal: true,
                x: new Array(numVars).fill(0),
                z: 0,
                message: '已使用數值方法求解'
            };
            
            // Basic feasible solution search
            // Start from origin and check feasibility
            let bestZ = isMaximize ? -Infinity : Infinity;
            let bestX = new Array(numVars).fill(0);
            
            // Simple grid search for demonstration
            const gridSize = 100;
            let maxVals = new Array(numVars).fill(0);
            
            // Estimate bounds from constraints
            constraints.forEach(con => {
                for (let i = 0; i < numVars; i++) {
                    if (con.coefs[i] > 0 && con.op === '<=') {
                        const bound = con.rhs / con.coefs[i];
                        maxVals[i] = Math.max(maxVals[i], bound);
                    }
                }
            });
            
            // Fallback bounds
            maxVals = maxVals.map(v => v > 0 ? v : 1000);
            
            // Grid search (simplified)
            const steps = 50;
            function searchRecursive(currentX, varIdx) {
                if (varIdx === numVars) {
                    // Check feasibility
                    const feasible = constraints.every(con => {
                        let lhs = 0;
                        for (let i = 0; i < numVars; i++) {
                            lhs += con.coefs[i] * currentX[i];
                        }
                        if (con.op === '<=') return lhs <= con.rhs + 1e-6;
                        if (con.op === '>=') return lhs >= con.rhs - 1e-6;
                        return Math.abs(lhs - con.rhs) < 1e-6;
                    });
                    
                    if (feasible) {
                        let z = 0;
                        for (let i = 0; i < numVars; i++) {
                            z += c[i] * currentX[i];
                        }
                        if ((isMaximize && z > bestZ) || (!isMaximize && z < bestZ)) {
                            bestZ = z;
                            bestX = [...currentX];
                        }
                    }
                    return;
                }
                
                for (let step = 0; step <= steps; step++) {
                    currentX[varIdx] = (step / steps) * maxVals[varIdx];
                    searchRecursive(currentX, varIdx + 1);
                }
            }
            
            searchRecursive(new Array(numVars).fill(0), 0);
            
            if (bestZ === (isMaximize ? -Infinity : Infinity)) {
                return { feasible: false, message: '無可行解' };
            }
            
            result.x = bestX;
            result.z = bestZ;
            return result;
        }

        function displayLPResults(result, varNames, objCoefs, constraints, isMaximize, numVars, requireInteger = false) {
            document.getElementById('lpResults').classList.remove('hidden');
            
            const solutionDiv = document.getElementById('lpOptimalSolution');
            const plotDiv = document.getElementById('lpFeasibleRegionPlot');
            const sensitivityDiv = document.getElementById('lpSensitivityAnalysis');
            
            if (!result.feasible) {
                solutionDiv.innerHTML = `
                    <div class="text-red-600 font-bold text-lg">❌ ${result.message}</div>
                    <p class="text-gray-600 mt-2">無法找到滿足所有約束條件的解。請檢查約束條件是否過於嚴格或相互矛盾。</p>
                `;
                plotDiv.innerHTML = '';
                sensitivityDiv.innerHTML = '';
                return;
            }
            
            // Display optimal solution
            const objectiveType = isMaximize ? '最大化' : '最小化';
            const integerBadge = requireInteger ? '<span class="ml-2 px-2 py-0.5 bg-indigo-100 text-indigo-700 text-xs rounded">🔢 整數解</span>' : '';
            let solutionHtml = `
                <div class="text-green-700 font-bold text-xl mb-3">✅ 找到最佳解！${integerBadge}</div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <h4 class="font-semibold mb-2">📦 最佳決策變數值：</h4>
                        <ul class="space-y-1">
            `;
            
            for (let i = 0; i < numVars; i++) {
                // Show integer value without decimals if integer constraint is enabled
                const value = requireInteger ? Math.round(result.x[i]) : result.x[i].toFixed(2);
                solutionHtml += `<li><strong>${varNames[i]}</strong> (x₍${i+1}₎) = ${value}</li>`;
            }
            
            const zDisplay = requireInteger ? Math.round(result.z) : result.z.toFixed(2);
            const calcDisplay = objCoefs.map((c, i) => {
                const xVal = requireInteger ? Math.round(result.x[i]) : result.x[i].toFixed(2);
                return `${c}×${xVal}`;
            }).join(' + ');
            
            solutionHtml += `
                        </ul>
                    </div>
                    <div class="bg-white p-4 rounded-lg border-2 border-green-400">
                        <h4 class="font-semibold mb-2">🎯 ${objectiveType}目標值：</h4>
                        <div class="text-3xl font-bold text-green-600">${zDisplay}</div>
                        <p class="text-sm text-gray-500 mt-1">Z = ${calcDisplay}</p>
                    </div>
                </div>
            `;
            solutionDiv.innerHTML = solutionHtml;
            
            // Draw feasible region for 2D problems
            if (numVars === 2 && result.cornerPoints) {
                drawFeasibleRegion(plotDiv, result, varNames, objCoefs, constraints, isMaximize);
            } else {
                plotDiv.innerHTML = `<p class="text-gray-500 text-center py-8">可行區域圖僅支援 2 個變數的問題</p>`;
            }
            
            // Sensitivity analysis
            let sensHtml = `
                <h4 class="font-semibold mb-3">📈 敏感度分析</h4>
                <div class="space-y-3">
                    <div>
                        <h5 class="font-medium">約束條件狀態：</h5>
                        <table class="w-full text-sm mt-2">
                            <thead class="bg-gray-100">
                                <tr>
                                    <th class="p-2 text-left">約束名稱</th>
                                    <th class="p-2 text-center">使用量</th>
                                    <th class="p-2 text-center">上限</th>
                                    <th class="p-2 text-center">剩餘</th>
                                    <th class="p-2 text-center">狀態</th>
                                </tr>
                            </thead>
                            <tbody>
            `;
            
            constraints.forEach((con, idx) => {
                let usage = 0;
                for (let i = 0; i < numVars; i++) {
                    usage += con.coefs[i] * result.x[i];
                }
                const slack = con.rhs - usage;
                const isTight = Math.abs(slack) < 0.01;
                const status = isTight ? 
                    '<span class="text-red-600 font-medium">⚠️ 瓶頸</span>' : 
                    '<span class="text-green-600">✓ 充裕</span>';
                
                sensHtml += `
                    <tr class="${isTight ? 'bg-red-50' : ''}">
                        <td class="p-2">${con.name || `約束 ${idx + 1}`}</td>
                        <td class="p-2 text-center">${usage.toFixed(2)}</td>
                        <td class="p-2 text-center">${con.rhs}</td>
                        <td class="p-2 text-center">${slack.toFixed(2)}</td>
                        <td class="p-2 text-center">${status}</td>
                    </tr>
                `;
            });
            
            sensHtml += `
                            </tbody>
                        </table>
                    </div>
                    <div class="text-sm text-gray-600 mt-3">
                        <p><strong>💡 提示：</strong>「瓶頸」表示該資源已完全使用，增加此資源可能提高目標值。</p>
                    </div>
                </div>
            `;
            sensitivityDiv.innerHTML = sensHtml;
        }

        function drawFeasibleRegion(plotDiv, result, varNames, objCoefs, constraints, isMaximize) {
            const traces = [];
            
            // Determine plot range
            let maxX = 0, maxY = 0;
            result.cornerPoints.forEach(pt => {
                maxX = Math.max(maxX, pt[0] * 1.2);
                maxY = Math.max(maxY, pt[1] * 1.2);
            });
            maxX = Math.max(maxX, 10);
            maxY = Math.max(maxY, 10);
            
            // Draw constraint lines
            constraints.forEach((con, idx) => {
                const a = con.coefs[0], b = con.coefs[1], c = con.rhs;
                let x = [], y = [];
                
                if (Math.abs(b) > 1e-10) {
                    // y = (c - ax) / b
                    x = [0, maxX];
                    y = x.map(xi => (c - a * xi) / b);
                } else if (Math.abs(a) > 1e-10) {
                    // vertical line x = c/a
                    const xVal = c / a;
                    x = [xVal, xVal];
                    y = [0, maxY];
                }
                
                traces.push({
                    x: x,
                    y: y,
                    mode: 'lines',
                    name: con.name || `約束 ${idx + 1}`,
                    line: { dash: 'dash', width: 2 }
                });
            });
            
            // Draw feasible region (polygon)
            if (result.cornerPoints.length >= 3) {
                // Sort corner points by angle from centroid
                const centroidX = result.cornerPoints.reduce((s, p) => s + p[0], 0) / result.cornerPoints.length;
                const centroidY = result.cornerPoints.reduce((s, p) => s + p[1], 0) / result.cornerPoints.length;
                
                const sortedPoints = [...result.cornerPoints].sort((a, b) => {
                    const angleA = Math.atan2(a[1] - centroidY, a[0] - centroidX);
                    const angleB = Math.atan2(b[1] - centroidY, b[0] - centroidX);
                    return angleA - angleB;
                });
                
                // Close the polygon
                sortedPoints.push(sortedPoints[0]);
                
                traces.push({
                    x: sortedPoints.map(p => p[0]),
                    y: sortedPoints.map(p => p[1]),
                    fill: 'toself',
                    fillcolor: 'rgba(99, 102, 241, 0.2)',
                    line: { color: 'rgb(99, 102, 241)', width: 2 },
                    name: '可行區域',
                    mode: 'lines'
                });
            }
            
            // Draw corner points
            traces.push({
                x: result.cornerPoints.map(p => p[0]),
                y: result.cornerPoints.map(p => p[1]),
                mode: 'markers',
                name: '角點',
                marker: { size: 10, color: 'blue' }
            });
            
            // Draw optimal point
            traces.push({
                x: [result.x[0]],
                y: [result.x[1]],
                mode: 'markers+text',
                name: '最佳解',
                marker: { size: 16, color: 'green', symbol: 'star' },
                text: [`最佳解<br>(${result.x[0].toFixed(2)}, ${result.x[1].toFixed(2)})`],
                textposition: 'top center'
            });
            
            // Draw iso-profit/cost line through optimal solution
            const c1 = objCoefs[0], c2 = objCoefs[1];
            if (Math.abs(c2) > 1e-10) {
                const isoX = [0, maxX];
                const isoY = isoX.map(xi => (result.z - c1 * xi) / c2);
                traces.push({
                    x: isoX,
                    y: isoY,
                    mode: 'lines',
                    name: `等值線 Z=${result.z.toFixed(2)}`,
                    line: { color: 'green', width: 3 }
                });
            }
            
            const layout = {
                title: { text: '線性規劃可行區域與最佳解', font: { size: 18 } },
                xaxis: { title: varNames[0] + ' (x₁)', range: [0, maxX], gridcolor: '#e5e7eb' },
                yaxis: { title: varNames[1] + ' (x₂)', range: [0, maxY], gridcolor: '#e5e7eb' },
                showlegend: true,
                legend: { x: 1, xanchor: 'right', y: 1 },
                margin: { t: 60, b: 60, l: 60, r: 60 },
                plot_bgcolor: '#fafafa',
                paper_bgcolor: '#ffffff'
            };
            
            Plotly.newPlot(plotDiv, traces, layout, { responsive: true });
        }

        // Global state for bubble chart animation
        let bubbleAnimationState = {
            isPlaying: false,
            intervalId: null,
            currentFrameIndex: 0,
            frames: [],
            timeValues: [],
            colorPalette: ['#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899', '#06b6d4', '#84cc16', '#f97316', '#6366f1']
        };

        function runBubbleChart() {
            if (!jsonData || jsonData.length === 0) {
                alert('請先載入資料');
                return;
            }

            const xVar = document.getElementById('bubbleXVar').value;
            const yVar = document.getElementById('bubbleYVar').value;
            const sizeVar = document.getElementById('bubbleSizeVar').value;
            const colorVar = document.getElementById('bubbleColorVar').value;
            const labelVarOverlay = document.getElementById('bubbleLabelOverlay').value;
            const labelVarSeparate = document.getElementById('bubbleLabelSeparate').value;
            const labelVar = labelVarOverlay; // For overlay mode, use this
            const timeVar = document.getElementById('bubbleTimeVar').value;
            const minSize = parseInt(document.getElementById('bubbleMinSize').value) || 8;
            const maxSize = parseInt(document.getElementById('bubbleMaxSize').value) || 60;

            if (!xVar || !yVar) {
                alert('請選擇 X 軸和 Y 軸變數');
                return;
            }

            // Stop any existing animation
            stopBubbleAnimation();

            // Extract valid data points
            const validData = jsonData.filter(row => {
                const x = parseFloat(row[xVar]);
                const y = parseFloat(row[yVar]);
                return !isNaN(x) && isFinite(x) && !isNaN(y) && isFinite(y);
            });

            if (validData.length < 2) {
                alert('有效資料點不足');
                return;
            }

            const colorPalette = bubbleAnimationState.colorPalette;

            // Helper function to get size values
            function getSizeValues(data) {
                if (sizeVar) {
                    const rawSizes = data.map(row => parseFloat(row[sizeVar]) || 0);
                    const allSizes = validData.map(row => parseFloat(row[sizeVar]) || 0);
                    const minVal = Math.min(...allSizes);
                    const maxVal = Math.max(...allSizes);
                    const range = maxVal - minVal || 1;
                    return rawSizes.map(v => minSize + ((v - minVal) / range) * (maxSize - minSize));
                } else {
                    return data.map(() => (minSize + maxSize) / 2);
                }
            }

            // Helper function to get color values
            function getColorInfo(data) {
                let colorValues, colorScale = null, showColorbar = false;
                if (colorVar) {
                    const rawColors = data.map(row => row[colorVar]);
                    const allColors = validData.map(row => row[colorVar]);
                    const isNumeric = allColors.every(v => !isNaN(parseFloat(v)) && isFinite(parseFloat(v)));
                    
                    if (isNumeric) {
                        colorValues = rawColors.map(v => parseFloat(v));
                        colorScale = 'Viridis';
                        showColorbar = true;
                    } else {
                        const uniqueVals = [...new Set(allColors)];
                        const colorMap = {};
                        uniqueVals.forEach((val, idx) => {
                            colorMap[val] = colorPalette[idx % colorPalette.length];
                        });
                        colorValues = rawColors.map(v => colorMap[v]);
                    }
                } else {
                    colorValues = data.map(() => '#3b82f6');
                }
                return { colorValues, colorScale, showColorbar };
            }

            // Helper function to get hover texts
            function getHoverTexts(data, xVals, yVals, currentTime = null) {
                return data.map((row, i) => {
                    let text = '';
                    if (labelVar) text += `<b>${row[labelVar]}</b><br>`;
                    if (currentTime !== null) text += `${timeVar}: ${currentTime}<br>`;
                    text += `${xVar}: ${xVals[i].toFixed(2)}<br>`;
                    text += `${yVar}: ${yVals[i].toFixed(2)}`;
                    if (sizeVar) text += `<br>${sizeVar}: ${row[sizeVar]}`;
                    if (colorVar) text += `<br>${colorVar}: ${row[colorVar]}`;
                    return text;
                });
            }

            // Calculate global axis ranges for consistent scaling
            const allX = validData.map(row => parseFloat(row[xVar]));
            const allY = validData.map(row => parseFloat(row[yVar]));
            const xPadding = (Math.max(...allX) - Math.min(...allX)) * 0.1 || 1;
            const yPadding = (Math.max(...allY) - Math.min(...allY)) * 0.1 || 1;
            const xRange = [Math.min(...allX) - xPadding, Math.max(...allX) + xPadding];
            const yRange = [Math.min(...allY) - yPadding, Math.max(...allY) + yPadding];

            // Show results area
            document.getElementById('bubbleChartResults').classList.remove('hidden');

            // Handle container visibility based on mode
            const singleChartPlot = document.getElementById('bubbleChartPlot');
            const multiChartsContainer = document.getElementById('bubbleMultiChartsContainer');
            const multiChartsHeader = document.getElementById('bubbleMultiChartsHeader');
            const multiChartsGrid = document.getElementById('bubbleMultiChartsGrid');

            // SEPARATE CHARTS MODE (不疊圖)
            if (labelVarSeparate && !timeVar) {
                // Hide single chart, show multi-charts container
                singleChartPlot.style.display = 'none';
                multiChartsContainer.classList.remove('hidden');
                document.getElementById('bubbleAnimationControls').style.display = 'none';
                document.getElementById('bubbleTimeSliderContainer').style.display = 'none';

                // Get unique label values
                const uniqueLabels = [...new Set(validData.map(row => row[labelVarSeparate]))];
                const limitedLabels = uniqueLabels.slice(0, 25);
                const totalCount = uniqueLabels.length;
                const displayedCount = limitedLabels.length;

                // Show header info
                if (totalCount > 25) {
                    multiChartsHeader.innerHTML = `
                        <div class="flex items-center gap-2">
                            <span class="text-blue-800 font-semibold">📊 依「${labelVarSeparate}」分組產生 ${displayedCount} 張圖表</span>
                            <span class="text-orange-600 text-sm">(共 ${totalCount} 組，僅顯示前 25 組)</span>
                        </div>`;
                } else {
                    multiChartsHeader.innerHTML = `
                        <span class="text-blue-800 font-semibold">📊 依「${labelVarSeparate}」分組產生 ${displayedCount} 張圖表</span>`;
                }

                // Clear existing charts
                multiChartsGrid.innerHTML = '';

                // Generate a chart for each label value
                limitedLabels.forEach((labelValue, idx) => {
                    const filteredData = validData.filter(row => row[labelVarSeparate] === labelValue);
                    
                    if (filteredData.length < 1) return;

                    // Create chart container
                    const chartDiv = document.createElement('div');
                    chartDiv.id = `bubbleChart_${idx}`;
                    chartDiv.className = 'bg-white border rounded-lg p-3';
                    chartDiv.style.minHeight = '350px';
                    multiChartsGrid.appendChild(chartDiv);

                    // Calculate values for this subset
                    const xValues = filteredData.map(row => parseFloat(row[xVar]));
                    const yValues = filteredData.map(row => parseFloat(row[yVar]));
                    const sizeValues = getSizeValues(filteredData);
                    const { colorValues, colorScale, showColorbar } = getColorInfo(filteredData);
                    
                    // Build hover texts
                    const hoverTexts = filteredData.map((row, i) => {
                        let text = `<b>${labelVarSeparate}: ${labelValue}</b><br>`;
                        text += `${xVar}: ${xValues[i].toFixed(2)}<br>`;
                        text += `${yVar}: ${yValues[i].toFixed(2)}`;
                        if (sizeVar) text += `<br>${sizeVar}: ${row[sizeVar]}`;
                        if (colorVar) text += `<br>${colorVar}: ${row[colorVar]}`;
                        return text;
                    });

                    const trace = {
                        x: xValues,
                        y: yValues,
                        mode: 'markers',
                        type: 'scatter',
                        marker: {
                            size: sizeValues,
                            color: colorValues,
                            opacity: 0.7,
                            line: { color: 'rgba(255,255,255,0.8)', width: 1 }
                        },
                        text: hoverTexts,
                        hoverinfo: 'text'
                    };

                    if (colorScale) {
                        trace.marker.colorscale = colorScale;
                        trace.marker.showscale = showColorbar;
                        trace.marker.colorbar = { title: colorVar, thickness: 10 };
                    }

                    const layout = {
                        title: { text: `${labelValue}`, font: { size: 14 } },
                        xaxis: { title: xVar, range: xRange, gridcolor: '#e5e7eb', zerolinecolor: '#9ca3af', tickfont: { size: 10 } },
                        yaxis: { title: yVar, range: yRange, gridcolor: '#e5e7eb', zerolinecolor: '#9ca3af', tickfont: { size: 10 } },
                        hovermode: 'closest',
                        showlegend: false,
                        margin: { t: 40, b: 50, l: 50, r: 30 },
                        plot_bgcolor: '#fafafa',
                        paper_bgcolor: '#ffffff'
                    };

                    Plotly.newPlot(chartDiv.id, [trace], layout, { responsive: true });
                });

                // Update legend
                updateBubbleLegend(xVar, yVar, sizeVar, colorVar, null, validData, colorPalette);
                return; // Exit function - don't continue to overlay/animation modes
            }

            // OVERLAY MODE or ANIMATION MODE - show single chart, hide multi-charts container
            singleChartPlot.style.display = 'block';
            multiChartsContainer.classList.add('hidden');

            if (timeVar) {
                // ANIMATION MODE
                const timeValues = [...new Set(validData.map(row => row[timeVar]))].sort((a, b) => {
                    const numA = parseFloat(a), numB = parseFloat(b);
                    if (!isNaN(numA) && !isNaN(numB)) return numA - numB;
                    return String(a).localeCompare(String(b));
                });

                if (timeValues.length < 2) {
                    alert('時間欄位需要至少 2 個不同的值才能產生動畫');
                    return;
                }

                bubbleAnimationState.timeValues = timeValues;
                bubbleAnimationState.frames = [];
                bubbleAnimationState.labelVar = labelVar; // Store for trail rendering

                // Show animation controls
                document.getElementById('bubbleAnimationControls').style.display = 'flex';
                document.getElementById('bubbleTimeSliderContainer').style.display = 'block';

                // Setup slider
                const slider = document.getElementById('bubbleTimeSlider');
                slider.min = 0;
                slider.max = timeValues.length - 1;
                slider.value = 0;

                // Build entity history for trace trails (if label variable is selected)
                const entityHistory = {}; // { entityLabel: [{x, y, color, timeVal}, ...] }
                
                if (labelVar) {
                    // Build complete history for all entities across all time points
                    timeValues.forEach((timeVal) => {
                        const frameData = validData.filter(row => row[timeVar] === timeVal);
                        frameData.forEach(row => {
                            const entity = row[labelVar];
                            const x = parseFloat(row[xVar]);
                            const y = parseFloat(row[yVar]);
                            if (!entityHistory[entity]) {
                                entityHistory[entity] = [];
                            }
                            // Get color for this entity
                            const rawColor = colorVar ? row[colorVar] : null;
                            entityHistory[entity].push({ x, y, timeVal, rawColor });
                        });
                    });
                }

                bubbleAnimationState.entityHistory = entityHistory;

                // Create frames for each time point
                timeValues.forEach((timeVal, frameIdx) => {
                    const frameData = validData.filter(row => row[timeVar] === timeVal);
                    const xVals = frameData.map(row => parseFloat(row[xVar]));
                    const yVals = frameData.map(row => parseFloat(row[yVar]));
                    const sizeVals = getSizeValues(frameData);
                    const { colorValues, colorScale, showColorbar } = getColorInfo(frameData);
                    const hoverTexts = getHoverTexts(frameData, xVals, yVals, timeVal);
                    const entityLabels = labelVar ? frameData.map(row => row[labelVar]) : [];

                    bubbleAnimationState.frames.push({
                        timeVal,
                        x: xVals,
                        y: yVals,
                        sizes: sizeVals,
                        colors: colorValues,
                        colorScale,
                        showColorbar,
                        texts: hoverTexts,
                        dataCount: frameData.length,
                        entities: entityLabels,
                        frameIdx
                    });
                });

                // Render first frame
                renderBubbleFrame(0, xVar, yVar, xRange, yRange, colorVar);

                // Setup slider event
                slider.oninput = function() {
                    const idx = parseInt(this.value);
                    bubbleAnimationState.currentFrameIndex = idx;
                    renderBubbleFrame(idx, xVar, yVar, xRange, yRange, colorVar);
                };

                // Setup play button
                document.getElementById('bubblePlayBtn').onclick = function() {
                    if (bubbleAnimationState.isPlaying) {
                        stopBubbleAnimation();
                    } else {
                        startBubbleAnimation(xVar, yVar, xRange, yRange, colorVar);
                    }
                };

            } else {
                // STATIC MODE - no animation
                document.getElementById('bubbleAnimationControls').style.display = 'none';
                document.getElementById('bubbleTimeSliderContainer').style.display = 'none';

                const xValues = validData.map(row => parseFloat(row[xVar]));
                const yValues = validData.map(row => parseFloat(row[yVar]));
                const sizeValues = getSizeValues(validData);
                const { colorValues, colorScale, showColorbar } = getColorInfo(validData);
                const hoverTexts = getHoverTexts(validData, xValues, yValues);

                const trace = {
                    x: xValues,
                    y: yValues,
                    mode: 'markers',
                    type: 'scatter',
                    marker: {
                        size: sizeValues,
                        color: colorValues,
                        opacity: 0.7,
                        line: { color: 'rgba(255,255,255,0.8)', width: 1 }
                    },
                    text: hoverTexts,
                    hoverinfo: 'text'
                };

                if (colorScale) {
                    trace.marker.colorscale = colorScale;
                    trace.marker.showscale = showColorbar;
                    trace.marker.colorbar = { title: colorVar, thickness: 15 };
                }

                const layout = {
                    title: { text: `多維度泡泡圖：${xVar} vs ${yVar}`, font: { size: 18 } },
                    xaxis: { title: xVar, range: xRange, gridcolor: '#e5e7eb', zerolinecolor: '#9ca3af' },
                    yaxis: { title: yVar, range: yRange, gridcolor: '#e5e7eb', zerolinecolor: '#9ca3af' },
                    hovermode: 'closest',
                    showlegend: false,
                    margin: { t: 60, b: 60, l: 60, r: 40 },
                    plot_bgcolor: '#fafafa',
                    paper_bgcolor: '#ffffff'
                };

                Plotly.newPlot('bubbleChartPlot', [trace], layout, { responsive: true });
            }

            // Legend info
            updateBubbleLegend(xVar, yVar, sizeVar, colorVar, timeVar, validData, colorPalette);
        }

        function renderBubbleFrame(frameIndex, xVar, yVar, xRange, yRange, colorVar) {
            const frame = bubbleAnimationState.frames[frameIndex];
            if (!frame) return;

            document.getElementById('bubbleCurrentTime').textContent = frame.timeVal;
            document.getElementById('bubbleTimeSlider').value = frameIndex;

            const traces = [];
            const entityHistory = bubbleAnimationState.entityHistory || {};
            const labelVar = bubbleAnimationState.labelVar;
            const timeValues = bubbleAnimationState.timeValues;
            const currentTimeIdx = frameIndex;
            const colorPalette = bubbleAnimationState.colorPalette;

            // Build color map for entities if using categorical colors
            let entityColorMap = {};
            if (colorVar && !frame.colorScale) {
                const allColors = [];
                Object.values(entityHistory).forEach(hist => {
                    hist.forEach(h => allColors.push(h.rawColor));
                });
                const uniqueColors = [...new Set(allColors)];
                uniqueColors.forEach((val, idx) => {
                    entityColorMap[val] = colorPalette[idx % colorPalette.length];
                });
            }

            // Draw trace trails for each entity (if label variable is set)
            if (labelVar && Object.keys(entityHistory).length > 0) {
                // For each entity present in current frame, draw its trail
                frame.entities.forEach((entity, i) => {
                    const history = entityHistory[entity];
                    if (!history || history.length < 2) return;

                    // Get history up to current time point
                    const currentTimeVal = frame.timeVal;
                    const currentTimeIndex = timeValues.indexOf(currentTimeVal);
                    
                    // Filter history to only include points up to current time
                    const trailHistory = history.filter((h, idx) => {
                        const hTimeIndex = timeValues.indexOf(h.timeVal);
                        return hTimeIndex <= currentTimeIndex;
                    });

                    if (trailHistory.length >= 2) {
                        const trailX = trailHistory.map(h => h.x);
                        const trailY = trailHistory.map(h => h.y);
                        
                        // Determine trail color - use entity's color
                        let trailColor = '#999999';
                        if (colorVar && trailHistory[0].rawColor) {
                            if (entityColorMap[trailHistory[0].rawColor]) {
                                trailColor = entityColorMap[trailHistory[0].rawColor];
                            }
                        } else if (frame.colors && frame.colors[i]) {
                            trailColor = frame.colors[i];
                        }

                        // Create trail trace with gradient opacity
                        const trailTrace = {
                            x: trailX,
                            y: trailY,
                            mode: 'lines+markers',
                            type: 'scatter',
                            line: {
                                color: trailColor,
                                width: 2,
                                shape: 'spline',
                                smoothing: 0.5
                            },
                            marker: {
                                size: 4,
                                color: trailColor,
                                opacity: 0.4
                            },
                            opacity: 0.4,
                            hoverinfo: 'skip',
                            showlegend: false
                        };
                        traces.push(trailTrace);
                    }
                });
            }

            // Main bubble trace (current frame)
            const bubbleTrace = {
                x: frame.x,
                y: frame.y,
                mode: 'markers',
                type: 'scatter',
                marker: {
                    size: frame.sizes,
                    color: frame.colors,
                    opacity: 0.85,
                    line: { color: 'rgba(255,255,255,0.9)', width: 2 }
                },
                text: frame.texts,
                hoverinfo: 'text'
            };

            if (frame.colorScale) {
                bubbleTrace.marker.colorscale = frame.colorScale;
                bubbleTrace.marker.showscale = frame.showColorbar;
                bubbleTrace.marker.colorbar = { title: colorVar, thickness: 15 };
            }

            traces.push(bubbleTrace);

            const layout = {
                title: { text: `多維度泡泡圖：${xVar} vs ${yVar} (${frame.timeVal})`, font: { size: 18 } },
                xaxis: { title: xVar, range: xRange, gridcolor: '#e5e7eb', zerolinecolor: '#9ca3af' },
                yaxis: { title: yVar, range: yRange, gridcolor: '#e5e7eb', zerolinecolor: '#9ca3af' },
                hovermode: 'closest',
                showlegend: false,
                margin: { t: 60, b: 60, l: 60, r: 40 },
                plot_bgcolor: '#fafafa',
                paper_bgcolor: '#ffffff',
                annotations: [{
                    x: 0.5,
                    y: 0.95,
                    xref: 'paper',
                    yref: 'paper',
                    text: `<b style="font-size:24px">${frame.timeVal}</b>`,
                    showarrow: false,
                    font: { size: 28, color: '#1f2937' }
                }]
            };

            Plotly.react('bubbleChartPlot', traces, layout);
        }

        function startBubbleAnimation(xVar, yVar, xRange, yRange, colorVar) {
            bubbleAnimationState.isPlaying = true;
            document.getElementById('bubblePlayIcon').textContent = '⏸️';
            document.getElementById('bubblePlayText').textContent = '暫停';

            const speed = parseInt(document.getElementById('bubbleAnimSpeed').value) || 1000;

            bubbleAnimationState.intervalId = setInterval(() => {
                bubbleAnimationState.currentFrameIndex++;
                if (bubbleAnimationState.currentFrameIndex >= bubbleAnimationState.frames.length) {
                    bubbleAnimationState.currentFrameIndex = 0;
                }
                renderBubbleFrame(bubbleAnimationState.currentFrameIndex, xVar, yVar, xRange, yRange, colorVar);
            }, speed);
        }

        function stopBubbleAnimation() {
            bubbleAnimationState.isPlaying = false;
            if (bubbleAnimationState.intervalId) {
                clearInterval(bubbleAnimationState.intervalId);
                bubbleAnimationState.intervalId = null;
            }
            const playIcon = document.getElementById('bubblePlayIcon');
            const playText = document.getElementById('bubblePlayText');
            if (playIcon) playIcon.textContent = '▶️';
            if (playText) playText.textContent = '播放';
        }

        function updateBubbleLegend(xVar, yVar, sizeVar, colorVar, timeVar, validData, colorPalette) {
            const legendDiv = document.getElementById('bubbleChartLegend');
            let legendHtml = '<div class="flex flex-wrap gap-4 justify-center text-xs">';
            legendHtml += `<span>📍 X軸: <strong>${xVar}</strong></span>`;
            legendHtml += `<span>📍 Y軸: <strong>${yVar}</strong></span>`;
            if (sizeVar) legendHtml += `<span>📐 大小: <strong>${sizeVar}</strong></span>`;
            if (colorVar) legendHtml += `<span>🎨 顏色: <strong>${colorVar}</strong></span>`;
            if (timeVar) legendHtml += `<span>🎬 時間: <strong>${timeVar}</strong> (${bubbleAnimationState.timeValues.length} 幀)</span>`;
            legendHtml += `<span>📊 資料點數: <strong>${validData.length}</strong></span>`;
            legendHtml += '</div>';

            // If categorical color, show legend
            if (colorVar) {
                const rawColors = validData.map(row => row[colorVar]);
                const isNumeric = rawColors.every(v => !isNaN(parseFloat(v)) && isFinite(parseFloat(v)));
                if (!isNumeric) {
                    const uniqueVals = [...new Set(rawColors)];
                    if (uniqueVals.length <= 10) {
                        legendHtml += '<div class="flex flex-wrap gap-2 justify-center mt-3">';
                        uniqueVals.forEach((val, idx) => {
                            const color = colorPalette[idx % colorPalette.length];
                            legendHtml += `<span class="flex items-center gap-1"><span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:${color}"></span>${val}</span>`;
                        });
                        legendHtml += '</div>';
                    }
                }
            }

            legendDiv.innerHTML = legendHtml;
        }


        // --- Analysis Functions ---

        // --- Enhanced EDA Helper Functions ---

        function renderNumericDistribution(plotId, values, header) {
            const traceViolin = {
                type: 'violin',
                x: values,
                points: 'all',
                box: { visible: true },
                line: { color: 'black' },
                fillcolor: '#8dd3c7',
                opacity: 0.6,
                meanline: { visible: true },
                name: header,
                jitter: 0.05,
                pointpos: -1.8
            };

            const layout = {
                title: {
                    text: `${header} 分佈詳情 (Violin + Box)`,
                    font: { size: 16, color: '#333' }
                },
                xaxis: { title: header, zeroline: false },
                yaxis: { title: '密度/頻率', zeroline: false },
                margin: { t: 50, b: 40, l: 60, r: 20 },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                showlegend: false,
                hovermode: 'closest'
            };

            Plotly.newPlot(plotId, [traceViolin], layout, { responsive: true, displayModeBar: false });
        }

        function renderCategoricalDistribution(plotId, counts, header) {
            const labels = Object.keys(counts);
            const values = Object.values(counts);

            // Sort by count descending
            const sortedIndices = values.map((v, i) => i).sort((a, b) => values[b] - values[a]);
            const sortedLabels = sortedIndices.map(i => labels[i]);
            const sortedValues = sortedIndices.map(i => values[i]);

            // Decide between Bar and Donut based on category count
            let data = [];
            let layout = {};

            if (labels.length <= 5) {
                // Donut Chart for few categories
                data = [{
                    values: sortedValues,
                    labels: sortedLabels,
                    type: 'pie',
                    hole: 0.4,
                    textinfo: 'label+percent',
                    textposition: 'outside',
                    automargin: true,
                    marker: {
                        colors: ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd']
                    }
                }];
                layout = {
                    title: { text: `${header} 類別佔比`, font: { size: 16 } },
                    showlegend: true,
                    paper_bgcolor: 'rgba(0,0,0,0)',
                    margin: { t: 50, b: 20, l: 20, r: 20 }
                };
            } else {
                // Bar Chart for many categories
                data = [{
                    x: sortedLabels,
                    y: sortedValues,
                    type: 'bar',
                    marker: {
                        color: sortedValues,
                        colorscale: 'Viridis',
                        showscale: false
                    }
                }];
                layout = {
                    title: { text: `${header} 類別計數`, font: { size: 16 } },
                    xaxis: { title: header, tickangle: -45 },
                    yaxis: { title: '數量' },
                    paper_bgcolor: 'rgba(0,0,0,0)',
                    plot_bgcolor: 'rgba(0,0,0,0)',
                    margin: { t: 50, b: 60, l: 60, r: 20 }
                };
            }

            Plotly.newPlot(plotId, data, layout, { responsive: true, displayModeBar: false });
        }

        function renderCorrelationHeatmap(containerId, data, headers) {
            if (headers.length < 2) return;

            // Calculate correlation matrix with pairwise deletion (same as 基本分析)
            const matrix = [];
            for (let i = 0; i < headers.length; i++) {
                matrix[i] = [];
                for (let j = 0; j < headers.length; j++) {
                    if (i === j) {
                        matrix[i][j] = 1;
                    } else if (i > j) {
                        // Symmetric - copy from already calculated
                        matrix[i][j] = matrix[j][i];
                    } else {
                        // Pairwise deletion for correlation calculation
                        const pairs = [];
                        for (let k = 0; k < data.length; k++) {
                            const val1 = data[k][headers[i]];
                            const val2 = data[k][headers[j]];
                            if (typeof val1 === 'number' && !isNaN(val1) && 
                                typeof val2 === 'number' && !isNaN(val2)) {
                                pairs.push([val1, val2]);
                            }
                        }
                        
                        if (pairs.length < 2) {
                            matrix[i][j] = NaN;
                        } else {
                            const seriesX = pairs.map(p => p[0]);
                            const seriesY = pairs.map(p => p[1]);
                            const corr = ss.sampleCorrelation(seriesX, seriesY);
                            matrix[i][j] = isNaN(corr) ? 0 : corr;
                        }
                    }
                }
            }

            const trace = {
                z: matrix,
                x: headers,
                y: headers,
                type: 'heatmap',
                colorscale: 'RdBu',
                zmin: -1,
                zmax: 1,
                hoverongaps: false
            };

            const layout = {
                title: '數值變數相關係數熱力圖',
                xaxis: { side: 'bottom' },
                yaxis: { autorange: 'reversed' },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                margin: { t: 60, b: 60, l: 80, r: 20 } // Increased left margin for labels
            };

            Plotly.newPlot(containerId, [trace], layout, { responsive: true });
        }

        function runEDA() {
            const resultsDiv = document.getElementById('edaResults');
            resultsDiv.innerHTML = '';

            // 1. Numeric Stats Table (Enhanced Style)
            const stats = numericHeaders.map(header => {
                const values = jsonData.map(row => row[header]).filter(v => typeof v === 'number');
                if (values.length === 0) return null;
                const q1 = ss.quantile(values, 0.25);
                const q3 = ss.quantile(values, 0.75);
                return {
                    column: header,
                    count: values.length,
                    mean: ss.mean(values).toFixed(2),
                    median: ss.median(values).toFixed(2),
                    stdDev: ss.standardDeviation(values).toFixed(2),
                    min: ss.min(values),
                    max: ss.max(values),
                    skewness: calculateSkewness(values).toFixed(2),
                    kurtosis: calculateKurtosis(values).toFixed(2)
                };
            }).filter(s => s !== null);

            let statsHtml = `
                <div class="bg-white/80 backdrop-blur-md rounded-xl shadow-lg border border-white/20 p-6 mb-8">
                    <h3 class="text-xl font-bold text-gray-800 mb-4 flex items-center gap-2">
                        <span class="bg-blue-100 text-blue-600 p-2 rounded-lg">📊</span> 數值資料摘要
                    </h3>
                    <div class="overflow-x-auto">
                        <table class="min-w-full divide-y divide-gray-200">
                            <thead class="bg-gray-50/50">
                                <tr>
                                    <th class="px-4 py-3 text-left text-xs font-bold text-gray-500 uppercase tracking-wider">欄位</th>
                                    <th class="px-4 py-3 text-right text-xs font-bold text-gray-500 uppercase tracking-wider">個數 n</th>
                                    <th class="px-4 py-3 text-right text-xs font-bold text-gray-500 uppercase tracking-wider">平均值</th>
                                    <th class="px-4 py-3 text-right text-xs font-bold text-gray-500 uppercase tracking-wider">中位數</th>
                                    <th class="px-4 py-3 text-right text-xs font-bold text-gray-500 uppercase tracking-wider">標準差</th>
                                    <th class="px-4 py-3 text-right text-xs font-bold text-gray-500 uppercase tracking-wider">Min / Max</th>
                                    <th class="px-4 py-3 text-right text-xs font-bold text-gray-500 uppercase tracking-wider">偏態 / 峰態</th>
                                </tr>
                            </thead>
                            <tbody class="divide-y divide-gray-100">
                                ${stats.map(s => `
                                    <tr class="hover:bg-blue-50/30 transition-colors">
                                        <td class="px-4 py-3 text-sm font-medium text-gray-900">${s.column}</td>
                                        <td class="px-4 py-3 text-sm text-gray-600 text-right font-mono">${s.count}</td>
                                        <td class="px-4 py-3 text-sm text-gray-600 text-right font-mono">${s.mean}</td>
                                        <td class="px-4 py-3 text-sm text-gray-600 text-right font-mono">${s.median}</td>
                                        <td class="px-4 py-3 text-sm text-gray-600 text-right font-mono">${s.stdDev}</td>
                                        <td class="px-4 py-3 text-sm text-gray-500 text-right font-mono text-xs">${s.min} / ${s.max}</td>
                                        <td class="px-4 py-3 text-sm text-gray-500 text-right font-mono text-xs">${s.skewness} / ${s.kurtosis}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
            resultsDiv.innerHTML += statsHtml;

            // 2. Visualizations Grid
            resultsDiv.innerHTML += `<h3 class="text-xl font-bold text-gray-800 mb-6 pl-2 border-l-4 border-purple-500">進階資料視覺化</h3>`;

            const plotsContainer = document.createElement('div');
            plotsContainer.className = 'grid grid-cols-1 md:grid-cols-2 gap-8 mb-8';
            resultsDiv.appendChild(plotsContainer);

            // Render Numeric Plots
            numericHeaders.forEach(header => {
                const values = jsonData.map(row => row[header]).filter(v => typeof v === 'number');
                if (values.length > 0) {
                    const card = document.createElement('div');
                    card.className = 'bg-white/90 backdrop-blur rounded-xl shadow-md border border-gray-100 p-4 hover:shadow-xl transition-shadow duration-300';
                    const plotId = `plot-num-${header.replace(/\s/g, '')}`;
                    card.id = plotId;
                    card.style.minHeight = '400px';
                    plotsContainer.appendChild(card);
                    renderNumericDistribution(plotId, values, header);
                }
            });

            // Render Categorical Plots
            categoricalHeaders.forEach(header => {
                const values = jsonData.map(row => row[header]).filter(v => v != null);
                if (values.length > 0) {
                    const counts = values.reduce((acc, val) => { acc[val] = (acc[val] || 0) + 1; return acc; }, {});
                    const card = document.createElement('div');
                    card.className = 'bg-white/90 backdrop-blur rounded-xl shadow-md border border-gray-100 p-4 hover:shadow-xl transition-shadow duration-300';
                    const plotId = `plot-cat-${header.replace(/\s/g, '')}`;
                    card.id = plotId;
                    card.style.minHeight = '400px';
                    plotsContainer.appendChild(card);
                    renderCategoricalDistribution(plotId, counts, header);
                }
            });

            // 3. Correlation Heatmap
            if (numericHeaders.length >= 2) {
                const heatmapContainer = document.createElement('div');
                heatmapContainer.className = 'bg-white/90 backdrop-blur rounded-xl shadow-lg border border-gray-100 p-6 mt-8';
                heatmapContainer.id = 'correlationHeatmap';
                heatmapContainer.style.minHeight = '600px';
                resultsDiv.appendChild(heatmapContainer);

                renderCorrelationHeatmap('correlationHeatmap', jsonData, numericHeaders);
            }
        }

        function runPareto() {
            const categoryVar = document.getElementById('paretoCategoryVar').value;
            const valueVar = document.getElementById('paretoValueVar').value;
            const resultsDiv = document.getElementById('paretoResults');
            resultsDiv.innerHTML = '';
            if (!categoryVar || !valueVar) { resultsDiv.innerHTML = `<p class="text-red-600">請選擇類別與數值欄位。</p>`; return; }

            const sums = jsonData.reduce((acc, row) => {
                const category = row[categoryVar];
                const value = parseFloat(row[valueVar]);
                if (category != null && !isNaN(value)) {
                    acc[category] = (acc[category] || 0) + value;
                }
                return acc;
            }, {});

            const sortedData = Object.entries(sums).sort(([, a], [, b]) => b - a);
            if (sortedData.length === 0) { resultsDiv.innerHTML = `<p class="text-gray-500">找不到有效的配對資料來產生柏拉圖。</p>`; return; }

            const totalSum = sortedData.reduce((sum, [, value]) => sum + value, 0);

            let cumulativePercentage = 0;
            const labels = [], values = [], percentages = [];
            sortedData.forEach(([label, value]) => {
                labels.push(label);
                values.push(value);
                cumulativePercentage += (value / totalSum) * 100;
                percentages.push(cumulativePercentage);
            });

            const plotDiv = document.createElement('div');
            plotDiv.id = 'paretoPlot';
            resultsDiv.appendChild(plotDiv);

            const trace1 = { x: labels, y: values, type: 'bar', name: '數值', marker: { color: 'rgb(37, 99, 235)' } };
            const trace2 = { x: labels, y: percentages, type: 'scatter', mode: 'lines+markers', name: '累積百分比 (%)', yaxis: 'y2', line: { color: 'rgb(220, 38, 38)' } };

            const layout = {
                title: `柏拉圖分析: ${valueVar} by ${categoryVar}`,
                xaxis: { title: categoryVar },
                yaxis: { title: `加總 ${valueVar}` },
                yaxis2: { title: '累積百分比 (%)', overlaying: 'y', side: 'right', range: [0, 105] },
                showlegend: true,
                legend: { x: 0.7, y: 1.15 }
            };
            Plotly.newPlot(plotDiv, [trace1, trace2], layout, { responsive: true });
        }

        // 魚骨圖 (Fishbone / Ishikawa Diagram)
        function runFishbone() {
            const parentVar = document.getElementById('fishboneParentVar').value;
            const childVar = document.getElementById('fishboneChildVar').value;
            const problemText = document.getElementById('fishboneProblem').value || '問題';
            const resultsDiv = document.getElementById('fishboneResults');
            resultsDiv.innerHTML = '';

            if (!parentVar || !childVar) {
                resultsDiv.innerHTML = `<p class="text-red-600">請選擇主因欄位 (PARENT) 與細因欄位 (CHILD)。</p>`;
                return;
            }

            // 1. Build Adjacency List (Parent -> Children Map)
            const adjacencyList = {};
            const allNodes = new Set();
            const childNodes = new Set();

            jsonData.forEach(row => {
                const p = row[parentVar];
                const c = row[childVar];
                if (p && c) {
                    if (!adjacencyList[p]) adjacencyList[p] = [];
                    if (!adjacencyList[p].includes(c)) {
                        adjacencyList[p].push(c);
                        allNodes.add(p);
                        allNodes.add(c);
                        childNodes.add(c);
                    }
                }
            });

            // 2. Find Root Node (GrandParent)
            // The root is a node that is in allNodes but NOT in childNodes
            let rootNode = null;
            const candidates = [...allNodes].filter(node => !childNodes.has(node));
            
            if (candidates.length === 1) {
                rootNode = candidates[0];
            } else if (candidates.length > 1) {
                // If multiple roots, pick the one with the most children (heuristic)
                rootNode = candidates.reduce((a, b) => 
                    (adjacencyList[a]?.length || 0) > (adjacencyList[b]?.length || 0) ? a : b
                );
            } else {
                // Fallback: If circular or no obvious root, use the manually entered problem text
                // or just pick the first parent key
                rootNode = Object.keys(adjacencyList)[0];
            }

            // 3. Determine Fish Head Text
            // If we found a valid root from data, use it. Otherwise use manual input.
            const finalProblemText = rootNode || document.getElementById('fishboneProblem').value || '問題';

            // 4. Organize Data for Plotting
            // Main Categories are the children of the Root Node
            const mainCategories = adjacencyList[rootNode] || [];
            
            // If no categories found under root, maybe the user selected wrong columns or flat data
            // Fallback: Use original logic (Grouping by Parent column directly) if standard hierarchy fails
            let categories = [];
            let groupedData = {};

            if (mainCategories.length > 0) {
                categories = mainCategories;
                // For each category, get ITS children (Leaf nodes)
                categories.forEach(cat => {
                    groupedData[cat] = adjacencyList[cat] || [];
                });
            } else {
                // Fallback to flat grouping (Original Logic) if no 3-level hierarchy found
                categories = Object.keys(adjacencyList);
                categories.forEach(cat => {
                    groupedData[cat] = adjacencyList[cat];
                });
                // Remove the root itself if it appears in categories (shouldn't happen if logic holds)
            }

            if (categories.length === 0) {
                resultsDiv.innerHTML = `<p class="text-gray-500">無法建立有效的層級結構 (主因/細因)。請確認資料包含 (總問題 -> 主類別) 及 (主類別 -> 細因) 的關係。</p>`;
                return;
            }

            const problemTextToDisplay = rootNode ? rootNode : finalProblemText;

            // Create SVG fishbone diagram
            const svgWidth = 1100;
            const svgHeight = 520;
            const centerY = svgHeight / 2;
            const fishHeadX = svgWidth - 160;
            const fishTailX = 80;
            const spineLength = fishHeadX - fishTailX;

            // Create container
            const container = document.createElement('div');
            container.className = 'bg-white border rounded-lg p-4 overflow-x-auto';
            resultsDiv.appendChild(container);

            // Word wrap helper for fish head text
            const wrapText = (text, maxWidth) => {
                if (text.length <= maxWidth) return [text];
                const lines = [];
                let remaining = text;
                while (remaining.length > 0) {
                    lines.push(remaining.substring(0, maxWidth));
                    remaining = remaining.substring(maxWidth);
                }
                return lines;
            };
            const headLines = wrapText(problemTextToDisplay, 10);

            // Build SVG
            let svgContent = `
                <svg width="${svgWidth}" height="${svgHeight}" viewBox="0 0 ${svgWidth} ${svgHeight}" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="#374151"/>
                        </marker>
                    </defs>
                    
                    <!-- Main Spine -->
                    <line x1="${fishTailX}" y1="${centerY}" x2="${fishHeadX}" y2="${centerY}" 
                        stroke="#374151" stroke-width="3" marker-end="url(#arrowhead)"/>
                    
                    <!-- Fish Head (Problem) - wider box with text wrapping -->
                    <rect x="${fishHeadX}" y="${centerY - 50}" width="140" height="100" rx="12" 
                        fill="#dc2626" stroke="#991b1b" stroke-width="2"/>
                    ${headLines.map((line, i) => `
                        <text x="${fishHeadX + 70}" y="${centerY - 20 + i * 20}" text-anchor="middle" 
                            fill="white" font-size="13" font-weight="bold">${escapeHtml(line)}</text>
                    `).join('')}
            `;

            // Draw category bones - Standard Ishikawa Style
            // Bones should angle INWARD toward the spine/head like fish ribs (>>> shape)
            // Top bones: /  (Start low-left, end high-right? NO, effectively \ if we draw from spine)
            // Standard diagram: Bones slant from Top-Left to Bottom-Right (Top) and Bottom-Left to Top-Right (Bottom)
            // To look like >>> toward the right head:
            // Top Bone:  Starts at (x-offset, y-offset), Ends at Spine(x, center)
            // Bottom Bone: Starts at (x-offset, y+offset), Ends at Spine(x, center)
            
            const numCategories = categories.length;
            const spacing = spineLength / (Math.max(numCategories, 1) + 1);
            
            // Configuration for 60 degree slant
            const dx = 60; // Horizontal distance from spine point to outer label point (Left)
            const dy = 80; // Vertical distance from spine point to outer label point (Up/Down)

            categories.forEach((category, idx) => {
                const isTop = idx % 2 === 0;
                
                // Point on the MAIN SPINE where the bone connects
                const spineX = fishTailX + spacing * (idx + 1);
                const spineY = centerY;
                
                // Point where the LABEL sits (Outer tip of the bone)
                // It should be to the LEFT of the connection point to create the >>> flow
                const labelX = spineX - dx; 
                const labelY = isTop ? spineY - dy : spineY + dy;
                
                // Draw bone from Label Point -> Spine Point
                // This creates the proper 'rib' angle pointing toward the head
                // Top: \ (Label High-Left -> Spine Low-Right) ?? Wait, no.
                // If we want >>> shape:
                // Top rib should be / (Low-Left to High-Right)? No, that points away.
                // Standard arrow head: > 
                // Top part is \ (High-Left to Low-Right)
                // Bottom part is / (Low-Left to High-Right)
                // So LabelX must be < SpineX
                
                svgContent += `
                    <line x1="${labelX}" y1="${labelY}" x2="${spineX}" y2="${spineY}" 
                        stroke="#2563eb" stroke-width="2.5"/>
                    <text x="${labelX}" y="${labelY + (isTop ? -5 : 15)}" text-anchor="end"
                        fill="#1e40af" font-size="13" font-weight="bold">${escapeHtml(category)}</text>
                `;

                // Child bones (sub-causes)
                // These usually branch off horizontally from the main rib
                const children = groupedData[category] || [];
                children.forEach((child, childIdx) => {
                    if (childIdx >= 6) return; 
                    
                    // Position along the rib bone
                    const t = (childIdx + 1) / 7;
                    // Interpolate point on the rib
                    const ribX = labelX + (spineX - labelX) * t;
                    const ribY = labelY + (spineY - labelY) * t;
                    
                    // Child branch extends horizontally to the RIGHT (or left?)
                    // Usually they create smaller arrows. Let's make them horizontal to the right
                    const branchLen = 40;
                    const branchEndX = ribX + branchLen;
                    const branchEndY = ribY;
                    
                    svgContent += `
                        <line x1="${ribX}" y1="${ribY}" x2="${branchEndX}" y2="${branchEndY}" 
                            stroke="#10b981" stroke-width="1.5"/>
                        <text x="${branchEndX + 5}" y="${branchEndY + 4}" text-anchor="start" 
                            fill="#047857" font-size="10">${escapeHtml(child)}</text>
                    `;

                    // Level 4: Twigs (Micro-causes) branching off the Green Branch
                    // Look up children of THIS child
                    const grandChildren = adjacencyList[child] || [];
                    grandChildren.forEach((grandChild, gcIdx) => {
                        if (gcIdx >= 4) return; // Limit to 4 twigs per branch to avoid clutter
                        
                        // Twigs branch off the GREEN line (Level 3)
                        const t2 = (gcIdx + 1) / 5;
                        const twigBaseX = ribX + (branchEndX - ribX) * t2;
                        const twigBaseY = branchEndY;
                        
                        // Twig geometry: Slant parallel to the Main Blue Bone (Level 2)
                        // Main Bone goes from Label(Left) -> Spine(Right)
                        // Top Bone: \ (Label High-Left) to Spine (Low-Right) -> Slope is Positive dx, Positive dy (wait, y increases down)
                        // My coords: y increases DOWN.
                        // isTop Bone: LabelY < SpineY. Moving Label->Spine increases Y. So vector is (+, +). Slope > 0.
                        // Bottom Bone: LabelY > SpineY. Moving Label->Spine decreases Y. Vector is (+, -). Slope < 0.
                        
                        // Let's make Twigs slant INWARD like the main bones.
                        // If Top Branch: Twig should go Up-Left? or Down-Left?
                        // Let's make them parallel.
                        // Top Bone Vector: (dx, dy).  (Right 60, Down 80)
                        // Bottom Bone Vector: (dx, -dy). (Right 60, Up 80)
                        
                        // We want Twig to start at twigBase and go OUT.
                        // Usually they point "backwards" relative to the flow?
                        // Let's make them slant towards the main bone?
                        // Simple: Just slant them opposite to the main flow?
                        // Let's try slanting them same as Main Bone but smaller.
                        // Top Twig endpoint: (x - 15, y - 20) -> Up-Left
                        // Bottom Twig endpoint: (x - 15, y + 20) -> Down-Left
                        
                        const twigLen = 25;
                        const twigDx = 15;
                        const twigDy = 20;
                        
                        const twigEndX = twigBaseX - twigDx; // Point Left
                        const twigEndY = isTop ? twigBaseY - twigDy : twigBaseY + twigDy; // Up for Top, Down for Bottom
                        
                        svgContent += `
                            <line x1="${twigBaseX}" y1="${twigBaseY}" x2="${twigEndX}" y2="${twigEndY}" 
                                stroke="#f59e0b" stroke-width="1"/>
                            <text x="${twigEndX}" y="${twigEndY + (isTop ? -2 : 10)}" text-anchor="end" 
                                fill="#b45309" font-size="9">${escapeHtml(grandChild)}</text>
                        `;
                    });
                });

                // More indicator
                if (children.length > 6) {
                    const ribX = labelX + (spineX - labelX) * 0.9;
                    const ribY = labelY + (spineY - labelY) * 0.9;
                    svgContent += `
                        <text x="${ribX + 10}" y="${ribY}" text-anchor="start" 
                            fill="#6b7280" font-size="9" font-style="italic">+${children.length - 6} more...</text>
                    `;
                }
            });

            svgContent += '</svg>';
            container.innerHTML = svgContent;

            // Add summary table
            const summaryHtml = `
                <div class="mt-4 p-4 bg-gray-50 rounded-lg">
                    <h4 class="font-semibold mb-2">📊 魚骨圖摘要</h4>
                    <p><strong>問題描述：</strong>${escapeHtml(problemTextToDisplay)}</p>
                    <p><strong>主因類別數：</strong>${categories.length}</p>
                    <p><strong>細因總數：</strong>${Object.values(groupedData).flat().length}</p>
                    <details class="mt-2">
                        <summary class="cursor-pointer text-blue-600 hover:underline">展開詳細資料</summary>
                        <div class="mt-2 space-y-2">
                            ${categories.map(cat => `
                                <div class="bg-white p-2 rounded border">
                                    <strong class="text-blue-800">${escapeHtml(cat)}</strong>: 
                                    <span class="text-gray-600">${(groupedData[cat] || []).map(c => escapeHtml(c)).join(', ')}</span>
                                </div>
                            `).join('')}
                        </div>
                    </details>
                </div>
            `;
            resultsDiv.insertAdjacentHTML('beforeend', summaryHtml);
        }

        // Helper function to escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function runAnovaStyleTest() {
            const resultsDiv = document.getElementById('tTestResults');
            resultsDiv.innerHTML = '';
            
            // Determine Test Type
            const testTypeEl = document.querySelector('input[name="tTestType"]:checked');
            const testType = testTypeEl ? testTypeEl.value : 'independent_group';

            if (testType === 'independent_columns') {
                // Case 2: Independent Two-Column T-Test
                const var1 = document.getElementById('tTestVar1').value;
                const var2 = document.getElementById('tTestVar2').value;
                
                if (!var1 || !var2) { resultsDiv.innerHTML = `<p class="text-red-600">請選擇兩個變數。</p>`; return; }
                if (var1 === var2) { resultsDiv.innerHTML = `<p class="text-red-600">請選擇不同的變數進行比較。</p>`; return; }

                const data1 = jsonData.map(d => d[var1]).filter(v => typeof v === 'number');
                const data2 = jsonData.map(d => d[var2]).filter(v => typeof v === 'number');

                if (data1.length < 2 || data2.length < 2) { resultsDiv.innerHTML = `<p class="text-red-600">資料不足 (N<2)，無法進行檢定。</p>`; return; }

                const n1 = data1.length, n2 = data2.length;
                const mean1 = ss.mean(data1), mean2 = ss.mean(data2);
                const variance1 = ss.variance(data1), variance2 = ss.variance(data2);

                if (variance1 === 0 || variance2 === 0) { resultsDiv.innerHTML = `<p class="text-red-600">變異數為零，無法計算。</p>`; return; }

                // Welch's t-test
                const tStat = (mean1 - mean2) / Math.sqrt(variance1 / n1 + variance2 / n2);
                const df_num = Math.pow(variance1 / n1 + variance2 / n2, 2);
                const df_den = (Math.pow(variance1 / n1, 2) / (n1 - 1)) + (Math.pow(variance2 / n2, 2) / (n2 - 1));
                const df = df_num / df_den;
                const pValue = jStat.studentt.cdf(-Math.abs(tStat), df) * 2;

                let resultHtml = `<h3 class="text-lg font-semibold mb-2">📊 獨立樣本 T 檢定 (Independent Two-Sample T-Test)</h3>
                    <div class="grid grid-cols-2 gap-4 mb-4 text-sm">
                        <div class="bg-gray-50 p-2 rounded"><strong>${var1}</strong><br>Mean: ${mean1.toFixed(2)}<br>N: ${n1}</div>
                        <div class="bg-gray-50 p-2 rounded"><strong>${var2}</strong><br>Mean: ${mean2.toFixed(2)}<br>N: ${n2}</div>
                    </div>
                    <div class="overflow-x-auto"><table class="min-w-full bg-white"><tbody class="divide-y divide-gray-200">
                    <tr><td class="px-6 py-4 font-medium text-gray-900">T 統計量</td><td class="px-6 py-4 text-gray-700 font-mono text-lg">${tStat.toFixed(4)}</td></tr>
                    <tr><td class="px-6 py-4 font-medium text-gray-900">自由度 (df)</td><td class="px-6 py-4 text-gray-700 font-mono text-lg">${df.toFixed(2)}</td></tr>
                    <tr><td class="px-6 py-4 font-medium text-gray-900">P 值</td><td class="px-6 py-4 text-gray-700 font-mono text-lg">${pValue.toFixed(4)}</td></tr>
                    </tbody></table></div>
                    <div class="mt-4 p-4 bg-blue-50 border-l-4 border-blue-500 rounded-r-lg"><h4 class="font-bold">判讀:</h4><p class="text-gray-700 mt-1">${pValue < 0.05 ? `P < 0.05，拒絕虛無假設。顯示 <strong>${var1}</strong> 與 <strong>${var2}</strong> 的平均值存在顯著差異。` : `P > 0.05，無法拒絕虛無假設。顯示兩者平均值無顯著差異。`}</p></div>`;
                
                resultsDiv.innerHTML = resultHtml;
                
                // Plot
                const plotDiv = document.createElement('div');
                plotDiv.id = 'tTestPlot', plotDiv.className = 'mt-6', resultsDiv.appendChild(plotDiv);
                const trace1 = { y: data1, type: 'box', name: var1 }, trace2 = { y: data2, type: 'box', name: var2 };
                Plotly.newPlot('tTestPlot', [trace1, trace2], { title: '獨立樣本分佈比較', paper_bgcolor: '#f9f9f9', plot_bgcolor: '#f9f9f9' }, { responsive: true });

            } else if (testType === 'paired') {
                // Case 3: Paired T-Test
                const var1 = document.getElementById('tTestVar1').value;
                const var2 = document.getElementById('tTestVar2').value;
                if (!var1 || !var2) { resultsDiv.innerHTML = `<p class="text-red-600">請選擇兩個變數。</p>`; return; }
                
                const diffs = [];
                jsonData.forEach(row => {
                    if (typeof row[var1] === 'number' && typeof row[var2] === 'number') {
                        diffs.push(row[var1] - row[var2]);
                    }
                });

                if (diffs.length < 2) { resultsDiv.innerHTML = `<p class="text-red-600">有效成對樣本不足 (N<2)。</p>`; return; }

                const n = diffs.length;
                const meanD = ss.mean(diffs);
                const varD = ss.variance(diffs);
                
                if (varD === 0) { resultsDiv.innerHTML = `<p class="text-red-600">差異變異數為零，無法計算。</p>`; return; }

                const stdErr = Math.sqrt(varD) / Math.sqrt(n);
                const tStat = meanD / stdErr;
                const df = n - 1;
                const pValue = jStat.studentt.cdf(-Math.abs(tStat), df) * 2;

                let resultHtml = `<h3 class="text-lg font-semibold mb-2">📊 成對樣本 T 檢定 (Paired T-Test)</h3>
                    <div class="bg-gray-50 p-2 rounded mb-4 text-sm"><strong>樣本數 (Pairs):</strong> ${n} <span class="mx-2">|</span> <strong>差異平均值 (Mean Diff):</strong> ${meanD.toFixed(4)}</div>
                    <div class="overflow-x-auto"><table class="min-w-full bg-white"><tbody class="divide-y divide-gray-200">
                    <tr><td class="px-6 py-4 font-medium text-gray-900">T 統計量</td><td class="px-6 py-4 text-gray-700 font-mono text-lg">${tStat.toFixed(4)}</td></tr>
                    <tr><td class="px-6 py-4 font-medium text-gray-900">自由度 (df)</td><td class="px-6 py-4 text-gray-700 font-mono text-lg">${df.toFixed(0)}</td></tr>
                    <tr><td class="px-6 py-4 font-medium text-gray-900">P 值</td><td class="px-6 py-4 text-gray-700 font-mono text-lg">${pValue.toFixed(4)}</td></tr>
                    </tbody></table></div>
                    <div class="mt-4 p-4 bg-blue-50 border-l-4 border-blue-500 rounded-r-lg"><h4 class="font-bold">判讀:</h4><p class="text-gray-700 mt-1">${pValue < 0.05 ? `P < 0.05，拒絕虛無假設。顯示 <strong>${var1}</strong> 與 <strong>${var2}</strong> 之間存在顯著的成對差異。` : `P > 0.05，無法拒絕虛無假設。無顯著差異。`}</p></div>`;
                
                resultsDiv.innerHTML = resultHtml;

                // Plot Diffs
                const plotDiv = document.createElement('div');
                plotDiv.id = 'tTestPlot', plotDiv.className = 'mt-6', resultsDiv.appendChild(plotDiv);
                const trace = { x: diffs, type: 'histogram', name: '差異分佈', marker: { color: 'rgba(100, 149, 237, 0.7)' } };
                Plotly.newPlot('tTestPlot', [trace], { title: '成對差異分佈 (Differences Histogram)', xaxis: { title: 'Difference (Var1 - Var2)' } }, { responsive: true });

            } else if (testType === 'f_test_group') {
                // Case 4: F-Test for Equality of Variances (Grouped Data)
                const catVar = document.getElementById('tTestCategoricalVar').value;
                const numVar = document.getElementById('tTestNumericalVar').value;
                if (!catVar || !numVar) { resultsDiv.innerHTML = `<p class="text-red-600">請選擇分組變數與數值變數。</p>`; return; }

                const groupedData = jsonData.reduce((acc, row) => {
                    const groupKey = row[catVar], numValue = row[numVar];
                    if (groupKey != null && typeof numValue === 'number') {
                        if (!acc[groupKey]) acc[groupKey] = [];
                        acc[groupKey].push(numValue);
                    }
                    return acc;
                }, {});

                const groups = Object.keys(groupedData);
                if (groups.length !== 2) { resultsDiv.innerHTML = `<p class="text-red-600">F 檢定需要剛好兩組資料。目前有 ${groups.length} 組。</p>`; return; }

                const group1 = groups[0], group2 = groups[1];
                const data1 = groupedData[group1], data2 = groupedData[group2];

                if (data1.length < 2 || data2.length < 2) { resultsDiv.innerHTML = `<p class="text-red-600">資料不足 (N<2)。</p>`; return; }

                const variance1 = ss.variance(data1);
                const variance2 = ss.variance(data2);
                
                if (variance1 === 0 || variance2 === 0) { resultsDiv.innerHTML = `<p class="text-red-600">變異數為零，無法計算。</p>`; return; }

                // F-Test Logic (Two-tailed)
                // F = Larger Var / Smaller Var
                const fStat = (variance1 > variance2) ? (variance1 / variance2) : (variance2 / variance1);
                const df1 = (variance1 > variance2) ? (data1.length - 1) : (data2.length - 1);
                const df2 = (variance1 > variance2) ? (data2.length - 1) : (data1.length - 1);
                
                // p-value = 2 * (1 - jStat.centralF.cdf(F, df1, df2)) for F >= 1
                const pValue = 2 * (1 - jStat.centralF.cdf(fStat, df1, df2));

                let resultHtml = `<h3 class="text-lg font-semibold mb-2">📊 F 檢定 (變異數相等檢定 F-Test): ${numVar} by ${catVar}</h3>
                    <div class="grid grid-cols-2 gap-4 mb-4 text-sm">
                        <div class="bg-gray-50 p-2 rounded"><strong>${group1}</strong><br>Var: ${variance1.toFixed(4)}<br>N: ${data1.length}</div>
                        <div class="bg-gray-50 p-2 rounded"><strong>${group2}</strong><br>Var: ${variance2.toFixed(4)}<br>N: ${data2.length}</div>
                    </div>
                    <div class="overflow-x-auto"><table class="min-w-full bg-white"><tbody class="divide-y divide-gray-200">
                    <tr><td class="px-6 py-4 font-medium text-gray-900">F 統計量</td><td class="px-6 py-4 text-gray-700 font-mono text-lg">${fStat.toFixed(4)}</td></tr>
                    <tr><td class="px-6 py-4 font-medium text-gray-900">自由度 (df1, df2)</td><td class="px-6 py-4 text-gray-700 font-mono text-lg">${df1}, ${df2}</td></tr>
                    <tr><td class="px-6 py-4 font-medium text-gray-900">P 值</td><td class="px-6 py-4 text-gray-700 font-mono text-lg">${pValue.toFixed(4)}</td></tr>
                    </tbody></table></div>
                    <div class="mt-4 p-4 bg-purple-50 border-l-4 border-purple-500 rounded-r-lg"><h4 class="font-bold">判讀:</h4><p class="text-gray-700 mt-1">${pValue < 0.05 ? `P < 0.05，拒絕虛無假設。顯示 <strong>${group1}</strong> 與 <strong>${group2}</strong> 的變異數有<strong>顯著差異</strong>。` : `P > 0.05，無法拒絕虛無假設。顯示兩者變異數無顯著差異。`}</p></div>`;
                
                resultsDiv.innerHTML = resultHtml;

                // Box Plot
                const plotDiv = document.createElement('div');
                plotDiv.id = 'tTestPlot', plotDiv.className = 'mt-6', resultsDiv.appendChild(plotDiv);
                const trace1 = { y: data1, type: 'box', name: group1, boxpoints: 'all', jitter: 0.3 }, trace2 = { y: data2, type: 'box', name: group2, boxpoints: 'all', jitter: 0.3 };
                Plotly.newPlot('tTestPlot', [trace1, trace2], { title: '資料離散程度比較 (Box Plot)', yaxis: { title: numVar }, paper_bgcolor: '#f9f9f9', plot_bgcolor: '#f9f9f9' }, { responsive: true });

            } else {
                // Case 1: Independent Grouped (Original Logic)
                const catVar = document.getElementById('tTestCategoricalVar').value;
                const numVar = document.getElementById('tTestNumericalVar').value;
                if (!catVar || !numVar) { resultsDiv.innerHTML = `<p class="text-red-600">請選擇分組變數與數值變數。</p>`; return; }

                const groupedData = jsonData.reduce((acc, row) => {
                    const groupKey = row[catVar], numValue = row[numVar];
                    if (groupKey != null && typeof numValue === 'number') {
                        if (!acc[groupKey]) acc[groupKey] = [];
                        acc[groupKey].push(numValue);
                    }
                    return acc;
                }, {});

                const groups = Object.keys(groupedData);
                if (groups.length < 2) { resultsDiv.innerHTML = `<p class="text-red-600">分組變數至少需要兩個組別。目前有 ${groups.length} 組。</p>`; return; }

                // 自動選擇：2組用 T檢定，3組以上用 ANOVA
                if (groups.length === 2) {
                    // T 檢定
                    const data1 = groupedData[groups[0]], data2 = groupedData[groups[1]];
                    if (data1.length < 2 || data2.length < 2) { resultsDiv.innerHTML = `<p class="text-red-600">組別內沒有足夠的數值資料。</p>`; return; }
    
                    const n1 = data1.length, n2 = data2.length;
                    const mean1 = ss.mean(data1), mean2 = ss.mean(data2);
                    const var1 = ss.variance(data1), var2 = ss.variance(data2);
    
                    if (var1 === 0 || var2 === 0) {
                        resultsDiv.innerHTML = `<p class="text-red-600">錯誤：至少有一個組別的變異數為零，無法計算 T 檢定。</p>`;
                        return;
                    }
    
                    const tStat = (mean1 - mean2) / Math.sqrt(var1 / n1 + var2 / n2);
                    const df_num = Math.pow(var1 / n1 + var2 / n2, 2);
                    const df_den = (Math.pow(var1 / n1, 2) / (n1 - 1)) + (Math.pow(var2 / n2, 2) / (n2 - 1));
                    const df = df_num / df_den;
                    const pValue = jStat.studentt.cdf(-Math.abs(tStat), df) * 2;
    
                    let resultHtml = `<h3 class="text-lg font-semibold mb-2">📊 T 檢定結果 (Independent Grouped): ${numVar} by ${catVar}</h3><div class="overflow-x-auto"><table class="min-w-full bg-white"><tbody class="divide-y divide-gray-200"><tr><td class="px-6 py-4 font-medium text-gray-900">比較組別</td><td class="px-6 py-4 text-gray-700">${groups[0]} vs ${groups[1]}</td></tr><tr><td class="px-6 py-4 font-medium text-gray-900">T 統計量</td><td class="px-6 py-4 text-gray-700 font-mono text-lg">${tStat.toFixed(4)}</td></tr><tr><td class="px-6 py-4 font-medium text-gray-900">P 值</td><td class="px-6 py-4 text-gray-700 font-mono text-lg">${pValue.toFixed(4)}</td></tr></tbody></table></div><div class="mt-4 p-4 bg-blue-50 border-l-4 border-blue-500 rounded-r-lg"><h4 class="font-bold">結果判讀:</h4><p class="text-gray-700 mt-1">${pValue < 0.05 ? `由於 p-value (${pValue.toFixed(4)}) 小於 0.05，兩組在 <strong>${numVar}</strong> 的平均值上存在<strong>顯著差異</strong>。` : `由於 p-value (${pValue.toFixed(4)}) 大於 0.05，兩組在 <strong>${numVar}</strong> 的平均值上<strong>沒有顯著差異</strong>。`}</p></div>`;
                    resultsDiv.innerHTML = resultHtml;
    
                    const plotDiv = document.createElement('div');
                    plotDiv.id = 'tTestPlot', plotDiv.className = 'mt-6', resultsDiv.appendChild(plotDiv);
                    const trace1 = { y: data1, type: 'box', name: groups[0] }, trace2 = { y: data2, type: 'box', name: groups[1] };
                    Plotly.newPlot('tTestPlot', [trace1, trace2], { title: '兩組資料分佈比較', yaxis: { title: numVar }, paper_bgcolor: '#f9f9f9', plot_bgcolor: '#f9f9f9' }, { responsive: true });
                } else {
                    // ANOVA (多組比較)
                    const allData = [];
                    const groupMeans = [];
                    const groupSizes = [];
                    let grandTotal = 0;
                    let totalN = 0;
    
                    groups.forEach(group => {
                        const data = groupedData[group];
                        if (data.length < 2) { resultsDiv.innerHTML = `<p class="text-red-600">組別 "${group}" 沒有足夠的資料。</p>`; return; }
                        allData.push(...data);
                        const mean = ss.mean(data);
                        groupMeans.push(mean);
                        groupSizes.push(data.length);
                        grandTotal += ss.sum(data);
                        totalN += data.length;
                    });
    
                    const grandMean = grandTotal / totalN;
    
                    // 組間變異 (Between-group variation)
                    let ssb = 0;
                    groups.forEach((group, i) => {
                        ssb += groupSizes[i] * Math.pow(groupMeans[i] - grandMean, 2);
                    });
    
                    // 組內變異 (Within-group variation)
                    let ssw = 0;
                    groups.forEach((group, i) => {
                        const data = groupedData[group];
                        const mean = groupMeans[i];
                        data.forEach(val => {
                            ssw += Math.pow(val - mean, 2);
                        });
                    });
    
                    const dfb = groups.length - 1;
                    const dfw = totalN - groups.length;
                    const msb = ssb / dfb;
                    const msw = ssw / dfw;
                    const fStat = msb / msw;
    
                    // F 分佈的 p-value
                    const pValue = 1 - jStat.centralF.cdf(fStat, dfb, dfw);
    
                    // 效果量 Eta-squared (η²)
                    const etaSquared = ssb / (ssb + ssw);
    
                    let resultHtml = `<h3 class="text-lg font-semibold mb-2">📊 ANOVA 變異數分析 (多組比較): ${numVar} by ${catVar}</h3>`;
                    resultHtml += `<div class="overflow-x-auto mb-4"><table class="min-w-full bg-white border"><thead class="bg-gray-100"><tr><th class="px-4 py-2 border">變異來源</th><th class="px-4 py-2 border">SS</th><th class="px-4 py-2 border">df</th><th class="px-4 py-2 border">MS</th><th class="px-4 py-2 border">F</th><th class="px-4 py-2 border">p-value</th></tr></thead><tbody><tr><td class="px-4 py-2 border font-medium">組間 Between</td><td class="px-4 py-2 border">${ssb.toFixed(3)}</td><td class="px-4 py-2 border">${dfb}</td><td class="px-4 py-2 border">${msb.toFixed(3)}</td><td class="px-4 py-2 border font-mono text-lg">${fStat.toFixed(4)}</td><td class="px-4 py-2 border font-mono text-lg">${pValue.toFixed(4)}</td></tr><tr><td class="px-4 py-2 border font-medium">組內 Within</td><td class="px-4 py-2 border">${ssw.toFixed(3)}</td><td class="px-4 py-2 border">${dfw}</td><td class="px-4 py-2 border">${msw.toFixed(3)}</td><td class="px-4 py-2 border">-</td><td class="px-4 py-2 border">-</td></tr><tr><td class="px-4 py-2 border font-medium">總變異 Total</td><td class="px-4 py-2 border">${(ssb + ssw).toFixed(3)}</td><td class="px-4 py-2 border">${totalN - 1}</td><td class="px-4 py-2 border">-</td><td class="px-4 py-2 border">-</td><td class="px-4 py-2 border">-</td></tr></tbody></table></div>`;
                    resultHtml += `<div class="bg-purple-50 p-4 rounded mb-4"><p class="font-semibold">效果量 (Effect Size - η²): <span class="text-lg text-purple-700">${etaSquared.toFixed(4)}</span></p><p class="text-sm text-gray-600 mt-1">解釋：η² = ${(etaSquared * 100).toFixed(1)}% 的變異可由組別差異解釋。</p></div>`;
                    resultHtml += `<div class="mt-4 p-4 bg-green-50 border-l-4 border-green-500 rounded-r-lg"><h4 class="font-bold">結果判讀:</h4><p class="text-gray-700 mt-1">${pValue < 0.05 ? `由於 p-value (${pValue.toFixed(4)}) 小於 0.05，F 統計量 = ${fStat.toFixed(4)}，至少有一組在 <strong>${numVar}</strong> 的平均值上與其他組存在<strong>顯著差異</strong>。` : `由於 p-value (${pValue.toFixed(4)}) 大於 0.05，所有組別在 <strong>${numVar}</strong> 的平均值上<strong>沒有顯著差異</strong>。`}</p></div>`;
    
                    //組別摘要
                    resultHtml += `<h4 class="text-md font-semibold mt-4 mb-2">組別摘要統計:</h4><div class="overflow-x-auto"><table class="min-w-full bg-white border"><thead class="bg-gray-50"><tr><th class="px-4 py-2 border">組別</th><th class="px-4 py-2 border">樣本數</th><th class="px-4 py-2 border">平均值</th><th class="px-4 py-2 border">標準差</th></tr></thead><tbody>`;
                    groups.forEach((group, i) => {
                        const data = groupedData[group];
                        const std = ss.standardDeviation(data);
                        resultHtml += `<tr><td class="px-4 py-2 border font-medium">${group}</td><td class="px-4 py-2 border">${groupSizes[i]}</td><td class="px-4 py-2 border">${groupMeans[i].toFixed(3)}</td><td class="px-4 py-2 border">${std.toFixed(3)}</td></tr>`;
                    });
                    resultHtml += `</tbody></table></div>`;
    
                    resultsDiv.innerHTML = resultHtml;
    
                    const plotDiv = document.createElement('div');
                    plotDiv.id = 'tTestPlot', plotDiv.className = 'mt-6', resultsDiv.appendChild(plotDiv);
                    const traces = [];
                    groups.forEach(g => {
                        traces.push({ y: groupedData[g], type: 'box', name: g });
                    });
                    Plotly.newPlot('tTestPlot', traces, { title: '多組資料分佈比較', yaxis: { title: numVar }, paper_bgcolor: '#f9f9f9', plot_bgcolor: '#f9f9f9' }, { responsive: true });
                }
            }
        }

        function runRegression() {
            const xVar = document.getElementById('regressionX').value;
            const yVar = document.getElementById('regressionY').value;
            const resultsDiv = document.getElementById('regressionResults');
            resultsDiv.innerHTML = '';
            if (!xVar || !yVar) { resultsDiv.innerHTML = `<p class="text-red-600">請選擇自變數 (X) 與應變數 (Y)。</p>`; return; }
            if (xVar === yVar) { resultsDiv.innerHTML = `<p class="text-red-600">自變數與應變數不能相同。</p>`; return; }
            const dataPairs = jsonData.map(row => [row[xVar], row[yVar]]).filter(pair => typeof pair[0] === 'number' && typeof pair[1] === 'number');
            if (dataPairs.length < 3) { resultsDiv.innerHTML = `<p class="text-red-600">沒有足夠的配對數值資料進行迴歸分析。</p>`; return; }

            const linearModel = ss.linearRegression(dataPairs);
            const rSquared = ss.rSquared(dataPairs, ss.linearRegressionLine(linearModel));
            const line = ss.linearRegressionLine(linearModel);

            const xValues = dataPairs.map(p => p[0]), yValues = dataPairs.map(p => p[1]);
            const n = dataPairs.length;

            // 計算殘差和統計推論
            const predictions = xValues.map(x => line(x));
            const residuals = yValues.map((y, i) => y - predictions[i]);
            const sse = residuals.reduce((sum, r) => sum + r * r, 0);
            const mse = sse / (n - 2);
            const syx = Math.sqrt(mse);

            // 調整後 R²
            const adjRSquared = 1 - (1 - rSquared) * (n - 1) / (n - 2);

            // 斜率的標準誤和 t 統計量
            const xMean = ss.mean(xValues);
            const sxx = xValues.reduce((sum, x) => sum + Math.pow(x - xMean, 2), 0);
            const seSlope = syx / Math.sqrt(sxx);
            const tStatSlope = linearModel.m / seSlope;
            const dfResidual = n - 2;
            const pValueSlope = 2 * (1 - jStat.studentt.cdf(Math.abs(tStatSlope), dfResidual));

            // 斜率 95% 信賴區間
            const tCritical = jStat.studentt.inv(0.975, dfResidual);
            const slopeCI_lower = linearModel.m - tCritical * seSlope;
            const slopeCI_upper = linearModel.m + tCritical * seSlope;

            // 截距的標準誤
            const seIntercept = syx * Math.sqrt(1 / n + (xMean * xMean) / sxx);
            const tStatIntercept = linearModel.b / seIntercept;
            const pValueIntercept = 2 * (1 - jStat.studentt.cdf(Math.abs(tStatIntercept), dfResidual));
            const interceptCI_lower = linearModel.b - tCritical * seIntercept;
            const interceptCI_upper = linearModel.b + tCritical * seIntercept;

            let resultHtml = `<h3 class="text-lg font-semibold mb-2">📊 簡單線性迴歸結果 (增強版)</h3>`;
            resultHtml += `<div class="overflow-x-auto mb-4"><table class="min-w-full bg-white border"><tbody class="divide-y divide-gray-200"><tr><td class="px-6 py-3 font-medium text-gray-900">迴歸方程式</td><td class="px-6 py-3 text-gray-700 font-mono text-lg">Y = ${linearModel.m.toFixed(4)} * X + ${linearModel.b.toFixed(4)}</td></tr><tr><td class="px-6 py-3 font-medium text-gray-900">判定係數 R²</td><td class="px-6 py-3 text-gray-700 font-mono text-lg">${rSquared.toFixed(4)}</td></tr><tr><td class="px-6 py-3 font-medium text-gray-900">調整後 R²</td><td class="px-6 py-3 text-gray-700 font-mono text-lg">${adjRSquared.toFixed(4)}</td></tr><tr><td class="px-6 py-3 font-medium text-gray-900">標準誤 (S)</td><td class="px-6 py-3 text-gray-700 font-mono">${syx.toFixed(4)}</td></tr><tr><td class="px-6 py-3 font-medium text-gray-900">樣本數</td><td class="px-6 py-3 text-gray-700">${n}</td></tr></tbody></table></div>`;

            resultHtml += `<h4 class="text-md font-semibold mb-2">係數統計推論:</h4><div class="overflow-x-auto mb-4"><table class="min-w-full bg-white border"><thead class="bg-gray-50"><tr><th class="px-4 py-2 border">係數</th><th class="px-4 py-2 border">估計值</th><th class="px-4 py-2 border">標準誤</th><th class="px-4 py-2 border">t 統計量</th><th class="px-4 py-2 border">p-value</th><th class="px-4 py-2 border">95% CI 下限</th><th class="px-4 py-2 border">95% CI 上限</th></tr></thead><tbody><tr><td class="px-4 py-2 border font-medium">截距 (b0)</td><td class="px-4 py-2 border font-mono">${linearModel.b.toFixed(4)}</td><td class="px-4 py-2 border">${seIntercept.toFixed(4)}</td><td class="px-4 py-2 border">${tStatIntercept.toFixed(3)}</td><td class="px-4 py-2 border font-mono">${pValueIntercept.toFixed(4)}</td><td class="px-4 py-2 border">${interceptCI_lower.toFixed(4)}</td><td class="px-4 py-2 border">${interceptCI_upper.toFixed(4)}</td></tr><tr><td class="px-4 py-2 border font-medium">斜率 (b1)</td><td class="px-4 py-2 border font-mono">${linearModel.m.toFixed(4)}</td><td class="px-4 py-2 border">${seSlope.toFixed(4)}</td><td class="px-4 py-2 border">${tStatSlope.toFixed(3)}</td><td class="px-4 py-2 border font-mono">${pValueSlope.toFixed(4)}</td><td class="px-4 py-2 border">${slopeCI_lower.toFixed(4)}</td><td class="px-4 py-2 border">${slopeCI_upper.toFixed(4)}</td></tr></tbody></table></div>`;

            resultHtml += `<div class="mt-4 p-4 bg-purple-50 border-l-4 border-purple-500 rounded-r-lg"><h4 class="font-bold">結果判讀:</h4><ul class="text-gray-700 mt-1 space-y-1 list-disc list-inside"><li>R² = ${rSquared.toFixed(4)}，表示 <strong>${(rSquared * 100).toFixed(1)}%</strong> 的 Y 變異可由 X 解釋。</li><li>斜率 p-value = ${pValueSlope.toFixed(4)} ${pValueSlope < 0.05 ? '< 0.05，<strong>顯著</strong>' : '≥ 0.05，不顯著'}。</li><li>95% 信賴區間：斜率真值落在 [${slopeCI_lower.toFixed(4)}, ${slopeCI_upper.toFixed(4)}] 之間。</li></ul></div>`;

            resultsDiv.innerHTML = resultHtml;

            // 散佈圖 + 迴歸線
            const xMin = ss.min(xValues), xMax = ss.max(xValues);
            const lineX = [xMin, xMax], lineY = [line(xMin), line(xMax)];
            const plotDiv1 = document.createElement('div');
            plotDiv1.id = 'regressionPlot', plotDiv1.className = 'mt-6', resultsDiv.appendChild(plotDiv1);
            const scatterTrace = { x: xValues, y: yValues, mode: 'markers', type: 'scatter', name: '原始數據', marker: { size: 8 } };
            const lineTrace = { x: lineX, y: lineY, mode: 'lines', type: 'scatter', name: '迴歸線', line: { color: 'rgba(219, 64, 82, 1)', width: 2 } };
            Plotly.newPlot('regressionPlot', [scatterTrace, lineTrace], { title: `${yVar} vs ${xVar} 散佈圖`, xaxis: { title: xVar }, yaxis: { title: yVar }, showlegend: true, paper_bgcolor: '#f9f9f9', plot_bgcolor: '#f9f9f9' }, { responsive: true });

            // 殘差圖
            const plotDiv2 = document.createElement('div');
            plotDiv2.id = 'residualPlot', plotDiv2.className = 'mt-6', resultsDiv.appendChild(plotDiv2);
            const residualTrace = { x: predictions, y: residuals, mode: 'markers', type: 'scatter', name: '殘差', marker: { color: 'rgba(55, 128, 191, 0.7)', size: 8 } };
            const zeroLine = { x: [ss.min(predictions), ss.max(predictions)], y: [0, 0], mode: 'lines', type: 'scatter', name: '零線', line: { color: 'red', dash: 'dash' } };
            Plotly.newPlot('residualPlot', [residualTrace, zeroLine], { title: '殘差圖 (Residual Plot)', xaxis: { title: '預測值' }, yaxis: { title: '殘差' }, showlegend: true, paper_bgcolor: '#f9f9f9', plot_bgcolor: '#f9f9f9' }, { responsive: true });

            // --- 新增：簡單迴歸預測功能 (參照多元迴歸 UI/UX) ---
            window.simpleRegressionModel = { m: linearModel.m, b: linearModel.b, xVar, yVar };

            const predictHtml = `
                <div class="mt-8 border-t pt-6">
                    <h4 class="text-lg font-bold mb-4 flex items-center gap-2">
                        <svg class="w-5 h-5 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
                        進行預測
                    </h4>
                    <div class="flex items-end gap-4 bg-gray-50 p-4 rounded-lg border border-gray-200">
                        <div class="flex-1">
                            <label class="block text-sm font-medium text-gray-700 mb-1">${xVar}</label>
                            <input type="number" id="simplePredInput" class="w-full rounded-md border-gray-300 shadow-sm focus:border-purple-500 focus:ring-purple-500" placeholder="輸入 ${xVar} 數值">
                        </div>
                        <button onclick="predictSimpleRegression()" class="bg-purple-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-purple-700 shadow-md transition-colors flex items-center gap-2">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 7h6m0 10v-3m-3 3h.01M9 17h.01M9 14h.01M12 14h.01M15 11h.01M12 11h.01M9 11h.01M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z"></path></svg>
                            計算預測值
                        </button>
                    </div>
                    <div id="simplePredResult" class="mt-4 hidden">
                        <!-- Result will be shown here -->
                    </div>
                </div>
            `;
            resultsDiv.insertAdjacentHTML('beforeend', predictHtml);
        }

        window.predictSimpleRegression = function () {
            const model = window.simpleRegressionModel;
            if (!model) {
                alert('請先執行簡單迴歸分析');
                return;
            }

            const inputElem = document.getElementById('simplePredInput');
            if (!inputElem) return;

            const inputVal = parseFloat(inputElem.value);
            if (isNaN(inputVal)) {
                alert(`請輸入有效的 ${model.xVar} 數值`);
                return;
            }

            const predictedY = model.m * inputVal + model.b;

            const resultDiv = document.getElementById('simplePredResult');
            resultDiv.innerHTML = `
                <div class="p-4 bg-white border border-purple-200 rounded-lg shadow-sm">
                    <div class="flex items-center justify-between mb-4">
                        <div>
                            <p class="text-gray-600 text-sm">當 <span class="font-medium text-gray-800">${model.xVar} = ${inputVal}</span> 時</p>
                            <p class="text-lg font-bold text-gray-800 mt-1">預測 ${model.yVar}</p>
                        </div>
                        <div class="text-2xl font-bold text-purple-600">
                            ${predictedY.toFixed(4)}
                        </div>
                    </div>
                    
                    <!-- Prediction Profiler Graph -->
                    <div class="mt-4 pt-4 border-t border-gray-200">
                        <h4 class="text-md font-bold text-gray-800 mb-3">📈 Prediction Profiler (預測分析圖)</h4>
                        <div id="simpleRegressionProfiler" style="height: 300px;"></div>
                    </div>
                </div>
            `;
            resultDiv.classList.remove('hidden');

            // Generate Profiler Graph
            try {
                // Get range from original data
                const colValues = jsonData.map(d => parseFloat(d[model.xVar])).filter(v => !isNaN(v));
                let minX = Math.min(...colValues);
                let maxX = Math.max(...colValues);
                
                // Ensure prediction point is included in range
                minX = Math.min(minX, inputVal);
                maxX = Math.max(maxX, inputVal);

                // Extend range slightly
                const range = maxX - minX;
                const plotMin = minX - (range * 0.1 || 1); // Handle single point case
                const plotMax = maxX + (range * 0.1 || 1);
                
                // Line points (Linear: 2 points enough)
                const xPlot = [plotMin, plotMax];
                const yPlot = xPlot.map(x => model.m * x + model.b);

                const traceLine = {
                    x: xPlot,
                    y: yPlot,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Regression Line',
                    line: { color: '#374151', width: 2 }
                };

                const tracePoint = {
                    x: [inputVal],
                    y: [predictedY],
                    type: 'scatter',
                    mode: 'markers',
                    name: 'Current Prediction',
                    marker: { color: '#9333ea', size: 10, symbol: 'cross' }
                };

                const layout = {
                    title: { text: `${model.yVar} vs ${model.xVar}`, font: { size: 14 } },
                    margin: { l: 40, r: 20, t: 30, b: 30 },
                    xaxis: { title: model.xVar, range: [plotMin, plotMax] },
                    yaxis: { title: model.yVar },
                    showlegend: false,
                    shapes: [
                        // Vertical Line at current X
                        {
                            type: 'line',
                            x0: inputVal, x1: inputVal,
                            y0: Math.min(...yPlot, predictedY), y1: Math.max(...yPlot, predictedY),
                            yref: 'y',
                            line: { color: '#9333ea', width: 1, dash: 'dash' }
                        },
                        // Horizontal Line at current Y
                        {
                            type: 'line',
                            x0: plotMin, x1: plotMax,
                            y0: predictedY, y1: predictedY,
                            line: { color: '#9333ea', width: 1, dash: 'dash' }
                        }
                    ]
                };

                Plotly.newPlot('simpleRegressionProfiler', [traceLine, tracePoint], layout, { responsive: true, displayModeBar: false });

            } catch (e) {
                console.error("Profiler Plot Error:", e);
            }
        };

        // ========================
        // Holt-Winters Auto Parameter Optimization & Season Detection
        // ========================


        function toggleAutoParams() {
            const autoChecked = document.getElementById('forecastAutoParams').checked;
            const container = document.getElementById('manualParamsContainer');
            
            if (autoChecked) {
                container.classList.add('hidden');
            } else {
                container.classList.remove('hidden');
                document.getElementById('autoParamsResult').classList.add('hidden');
            }
        }

        // Compute Auto-Correlation Function (ACF)
        function computeACF(series, maxLag) {
            const n = series.length;
            const mean = series.reduce((a, b) => a + b, 0) / n;
            const variance = series.reduce((sum, x) => sum + Math.pow(x - mean, 2), 0);
            
            if (variance === 0) return new Array(maxLag + 1).fill(1); // constant series
            
            const acf = [];
            for (let lag = 0; lag <= maxLag; lag++) {
                let sum = 0;
                for (let i = 0; i < n - lag; i++) {
                    sum += (series[i] - mean) * (series[i + lag] - mean);
                }
                acf.push(sum / variance);
            }
            return acf;
        }

        // Detect seasonal period from ACF peaks
        function detectSeasonalPeriod(series) {
            const maxLag = Math.min(Math.floor(series.length / 2), 52);
            if (maxLag < 3) return null; // not enough data
            
            const acf = computeACF(series, maxLag);
            
            // Find first significant local maximum (skip lag=0 and lag=1)
            let bestPeriod = null;
            let bestScore = 0.1; // minimum threshold for significance
            
            for (let i = 2; i < acf.length - 1; i++) {
                // Check if local maximum
                if (acf[i] > acf[i - 1] && acf[i] > acf[i + 1] && acf[i] > bestScore) {
                    bestPeriod = i;
                    bestScore = acf[i];
                    break; // return first significant peak
                }
            }
            
            return bestPeriod;
        }

        // Auto detect period button handler
        function autoDetectPeriod() {
            const valueVar = document.getElementById('forecastValueVar').value;
            const hintElem = document.getElementById('periodDetectHint');
            
            if (!valueVar) {
                alert('請先選擇數值欄位 (Y)');
                return;
            }
            
            const values = jsonData.map(row => row[valueVar]).filter(v => typeof v === 'number');
            if (values.length < 6) {
                hintElem.textContent = '⚠️ 數據不足，無法偵測季節性';
                hintElem.className = 'text-xs text-orange-600 mt-1';
                hintElem.classList.remove('hidden');
                return;
            }
            
            const detectedPeriod = detectSeasonalPeriod(values);
            
            if (detectedPeriod) {
                document.getElementById('forecastPeriod').value = detectedPeriod;
                hintElem.textContent = `✅ 偵測到季節長度: ${detectedPeriod} (已自動填入)`;
                hintElem.className = 'text-xs text-green-600 mt-1';
            } else {
                hintElem.textContent = '⚠️ 未偵測到明顯季節性，建議手動設定 Period';
                hintElem.className = 'text-xs text-orange-600 mt-1';
            }
            hintElem.classList.remove('hidden');
        }

        // Compute Mean Absolute Error
        function computeMAE(actual, predicted) {
            const n = Math.min(actual.length, predicted.length);
            if (n === 0) return Infinity;
            let sum = 0;
            for (let i = 0; i < n; i++) {
                sum += Math.abs(actual[i] - predicted[i]);
            }
            return sum / n;
        }

        // Grid search for optimal Holt-Winters parameters
        function autoOptimizeHoltWinters(series, period) {
            // Need at least period*2 for Holt-Winters + some validation data
            const minTrainSize = period * 2;
            const trainSize = Math.max(minTrainSize, Math.floor(series.length * 0.8));
            
            if (trainSize >= series.length) {
                // Not enough data for validation split - return default
                return { bestParams: { alpha: 0.5, beta: 0.3, gamma: 0.3 }, bestMAE: NaN, message: '數據不足以進行優化' };
            }
            
            const trainData = series.slice(0, trainSize);
            const valData = series.slice(trainSize);
            
            let bestMAE = Infinity;
            let bestParams = { alpha: 0.5, beta: 0.3, gamma: 0.3 };
            let testCount = 0;
            
            // Grid search: 0.1 to 0.9, step 0.1 (9 values each, 729 combinations)
            for (let a = 0.1; a <= 0.9; a += 0.1) {
                for (let b = 0.1; b <= 0.9; b += 0.1) {
                    for (let g = 0.1; g <= 0.9; g += 0.1) {
                        try {
                            const { forecasts } = holtWinters(trainData, a, b, g, period, valData.length);
                            const mae = computeMAE(valData, forecasts);
                            testCount++;
                            
                            if (mae < bestMAE) {
                                bestMAE = mae;
                                bestParams = { 
                                    alpha: Math.round(a * 10) / 10, 
                                    beta: Math.round(b * 10) / 10, 
                                    gamma: Math.round(g * 10) / 10 
                                };
                            }
                        } catch (e) {
                            // Skip invalid combinations
                        }
                    }
                }
            }
            
            return { bestParams, bestMAE, testCount };
        }

        function holtWinters(series, alpha, beta, gamma, period, m) {
            if (series.length < period * 2) throw new Error("需要至少兩個週期的數據來初始化 Holt-Winters 模型。");

            // 🔧 修復：計算數據範圍，用於後續保護
            const seriesMin = Math.min(...series);
            const seriesMax = Math.max(...series);
            const seriesRange = seriesMax - seriesMin;

            let level = 0, trend = 0;
            const seasons = new Array(period).fill(0);
            let initialLevelSum = 0;
            for (let i = 0; i < period; i++) initialLevelSum += series[i];
            level = initialLevelSum / period;

            let initialTrendSum = 0;
            for (let i = 0; i < period; i++) initialTrendSum += (series[i + period] - series[i]);
            trend = initialTrendSum / (period * period);

            // 🔧 修復：保護初始seasons，避免除以零或負值
            for (let i = 0; i < period; i++) {
                seasons[i] = Math.max(0.1, series[i] / level);
            }

            const smoothed = [], fitted = [], forecasts = [];
            
            // Track old seasonal factors for one-step-ahead forecasting
            const old_seasons = [...seasons];
            
            for (let i = 0; i < series.length; i++) {
                const last_level = level, season_idx = i % period;

                // Save the OLD seasonal factor for next period BEFORE any updates
                const next_season_idx = (i + 1) % period;
                const old_next_season = old_seasons[next_season_idx];

                // 🔧 修復：保護season因子，避免除以零
                const safe_season = Math.max(0.01, old_seasons[season_idx]);

                level = alpha * (series[i] / safe_season) + (1 - alpha) * (level + trend);
                trend = beta * (level - last_level) + (1 - beta) * trend;

                // 🔧 修復：更新season時確保不會變成負值或過小
                const new_season = gamma * (series[i] / level) + (1 - gamma) * old_seasons[season_idx];
                seasons[season_idx] = Math.max(0.1, Math.min(5.0, new_season));
                old_seasons[season_idx] = seasons[season_idx]; // Update tracked value

                // Store fitted value (current period's fit)
                smoothed.push(level * seasons[season_idx]);
                
                // One-Step-Ahead Forecast for NEXT period using OLD seasonal factor
                fitted.push((level + trend) * old_next_season);
            }

            // 🔧 修復：預測時加入負值保護和趨勢約束
            for (let i = 0; i < m; i++) {
                const season_idx = (series.length + i) % period;

                // 基礎預測值
                let forecast = (level + (i + 1) * trend) * seasons[season_idx];

                forecasts.push(forecast);
            }
            return { smoothed, forecasts, fitted };
        }

        function runForecast() {
            const timeVar = document.getElementById('forecastTimeVar').value;
            const valueVar = document.getElementById('forecastValueVar').value;
            const period = parseInt(document.getElementById('forecastPeriod').value);
            const steps = parseInt(document.getElementById('forecastSteps').value);
            const resultsDiv = document.getElementById('forecastResults');
            const autoParamsResult = document.getElementById('autoParamsResult');
            resultsDiv.innerHTML = '';

            if (!timeVar || !valueVar || !period || !steps) { resultsDiv.innerHTML = `<p class="text-red-600">請選擇時間、數值欄位，並填寫季節長度與預測期數。</p>`; return; }
            if (period <= 1) { resultsDiv.innerHTML = `<p class="text-red-600">季節長度 (Period) 必須大於 1。</p>`; return; }

            const seriesData = jsonData.map(row => ({ time: row[timeVar], value: row[valueVar] })).filter(d => d.time != null && typeof d.value === 'number');
            seriesData.sort((a, b) => a.time < b.time ? -1 : 1);
            const yValues = seriesData.map(d => d.value);

            if (yValues.length < period * 2) { resultsDiv.innerHTML = `<p class="text-red-600">數據不足。Holt-Winters 需要至少兩倍季節長度的數據 (需要 ${period * 2} 筆，現有 ${yValues.length} 筆)。</p>`; return; }

            // Check if Auto mode is enabled
            const autoEnabled = document.getElementById('forecastAutoParams').checked;
            let alpha, beta, gamma;
            
            if (autoEnabled) {
                // Run auto optimization
                resultsDiv.innerHTML = `<p class="text-blue-600">🔍 正在進行參數優化 (Grid Search 729 組合)...</p>`;
                
                // Use setTimeout to allow UI to update before heavy computation
                setTimeout(() => {
                    const { bestParams, bestMAE, testCount, message } = autoOptimizeHoltWinters(yValues, period);
                    
                    alpha = bestParams.alpha;
                    beta = bestParams.beta;
                    gamma = bestParams.gamma;
                    
                    // Update UI with best values
                    document.getElementById('forecastAlpha').value = alpha;
                    document.getElementById('forecastBeta').value = beta;
                    document.getElementById('forecastGamma').value = gamma;
                    
                    // Show optimization result
                    if (message) {
                        autoParamsResult.innerHTML = `⚠️ ${message}，使用預設參數：α=${alpha}, β=${beta}, γ=${gamma}`;
                        autoParamsResult.className = 'text-sm text-orange-600 mb-3';
                    } else {
                        autoParamsResult.innerHTML = `✅ 最佳參數 (驗證集 MAE=${bestMAE.toFixed(2)}): α=${alpha}, β=${beta}, γ=${gamma}`;
                        autoParamsResult.className = 'text-sm text-green-600 mb-3';
                    }
                    autoParamsResult.classList.remove('hidden');
                    
                    // Continue with forecast
                    runForecastWithParams(yValues, seriesData, alpha, beta, gamma, period, steps, timeVar, valueVar, resultsDiv);
                }, 50);
                return; // Exit and wait for setTimeout
            } else {
                // Use manual values
                alpha = parseFloat(document.getElementById('forecastAlpha').value);
                beta = parseFloat(document.getElementById('forecastBeta').value);
                gamma = parseFloat(document.getElementById('forecastGamma').value);
                autoParamsResult.classList.add('hidden');
            }

            runForecastWithParams(yValues, seriesData, alpha, beta, gamma, period, steps, timeVar, valueVar, resultsDiv);
        }

        function runForecastWithParams(yValues, seriesData, alpha, beta, gamma, period, steps, timeVar, valueVar, resultsDiv) {
            try {
                const { smoothed, forecasts, fitted } = holtWinters(yValues, alpha, beta, gamma, period, steps);

                // Calculate MAPE using one-step-ahead fitted values
                // fitted[i] = forecast for y[i+1] made at time i
                // So y[i] is predicted by fitted[i-1]
                // Exclude first 'period' points (initialization period)
                let absPercentErrors = [];
                for (let i = period; i < yValues.length; i++) {
                    const pred = fitted[i - 1]; // Forecast made at i-1 for y[i]
                    if (yValues[i] !== 0 && pred !== undefined) {
                        absPercentErrors.push(Math.abs((yValues[i] - pred) / yValues[i]));
                    }
                }
                const mape = absPercentErrors.length > 0 ? ss.mean(absPercentErrors) * 100 : 0;

                const plotDiv = document.createElement('div');
                plotDiv.id = 'forecastPlot';
                resultsDiv.appendChild(plotDiv);

                const originalX = seriesData.map(d => d.time instanceof Date ? d.time.toLocaleDateString() : d.time);
                const futureX = [];
                const lastTime = seriesData[seriesData.length - 1].time;
                if (lastTime instanceof Date) {
                    for (let i = 1; i <= steps; i++) {
                        const nextDate = new Date(lastTime);
                        nextDate.setMonth(nextDate.getMonth() + i);
                        futureX.push(nextDate.toLocaleDateString());
                    }
                } else if (!isNaN(lastTime)) {
                    for (let i = 1; i <= steps; i++) futureX.push(lastTime + i);
                } else {
                    for (let i = 1; i <= steps; i++) futureX.push(`預測 ${i}`);
                }

                const trace1 = { x: originalX, y: yValues, mode: 'lines+markers', name: '原始數據' };
                // Use fitted values (one-step-ahead forecast) for visualization
                const trace2 = { x: originalX, y: fitted, mode: 'lines', name: '一步預測 (Lagged)', line: { dash: 'dot', color: 'orange' } };
                const trace3 = { x: futureX, y: forecasts, mode: 'lines+markers', name: '預測值', line: { color: 'red' } };
                const layout = { title: `${valueVar} Holt-Winters 預測`, xaxis: { title: timeVar, type: 'category' }, yaxis: { title: valueVar }, showlegend: true, paper_bgcolor: '#f9f9f9', plot_bgcolor: '#f9f9f9' };
                Plotly.newPlot('forecastPlot', [trace1, trace2, trace3], layout, { responsive: true });

                let tableHtml = `<div class="mt-4 p-4 bg-sky-50 border-l-4 border-sky-500 rounded-r-lg"><h4 class="font-bold">模型準確度</h4><p class="text-gray-700 mt-1">平均絕對百分比誤差 (MAPE): <strong>${mape.toFixed(2)}%</strong> (越低越好)</p></div><h3 class="text-lg font-semibold mt-6 mb-2">預測值</h3><div class="overflow-x-auto"><table class="min-w-full divide-y divide-gray-200"><thead class="bg-gray-50"><tr><th class="p-2 text-left text-xs font-medium text-gray-500 uppercase">未來期數</th><th class="p-2 text-left text-xs font-medium text-gray-500 uppercase">預測值</th></tr></thead><tbody class="bg-white divide-y divide-gray-200">`;
                forecasts.forEach((val, i) => {
                    tableHtml += `<tr><td class="p-2 whitespace-nowrap text-sm font-medium text-gray-900">${futureX[i]}</td><td class="p-2 text-sm text-gray-500">${val.toFixed(3)}</td></tr>`;
                });
                tableHtml += `</tbody></table></div>`;
                resultsDiv.innerHTML += tableHtml;

            } catch (error) {
                resultsDiv.innerHTML = `<p class="text-red-600">預測時發生錯誤: ${error.message}</p>`;
            }
        }



        // --- Classical Decomposition (Additive) ---
        // Returns: { trend, seasonal, residual, fitted, forecasts, trendStrength, seasonalStrength, decomposition: { ... } }
        function classicalDecomposition(series, period, steps) {
            const n = series.length;
            
            // 1. Trend Extraction: Centered Moving Average (CMA)
            // If period is even, use 2xPeriod MA. If odd, use Period MA.
            let trend = new Array(n).fill(null);
            const halfP = Math.floor(period / 2);
            
            if (period % 2 === 0) {
                // Even period: 2xPeriod MA (centered)
                for (let i = halfP; i < n - halfP; i++) {
                    let sum1 = 0;
                    for (let j = -halfP; j < halfP; j++) sum1 += series[i + j];
                    let sum2 = 0;
                    for (let j = -halfP + 1; j <= halfP; j++) sum2 += series[i + j];
                    trend[i] = (sum1 + sum2) / (2 * period);
                }
            } else {
                // Odd period: Period MA (centered)
                for (let i = halfP; i < n - halfP; i++) {
                    let sum = 0;
                    for (let j = -halfP; j <= halfP; j++) sum += series[i + j];
                    trend[i] = sum / period;
                }
            }

            // Fill edges of Trend using Linear Regression on the available CMA points (or whole series if minimal)
            // To keep it robust, we'll use Global Linear Regression to fill nulls, shifted to match the nearest valid trend point.
            // Simplified: Just use Global Linear Regression for edges to ensure continuity is "okay".
            const validTrendIndices = trend.map((v, i) => v !== null ? i : -1).filter(i => i !== -1);
            
            // If very short series, fall back to global linear regression for everything
            let useGlobalTrend = false;
            if (validTrendIndices.length < 2) {
                useGlobalTrend = true;
            } else {
                 // Fill Start
                const firstValid = validTrendIndices[0];
                const firstVal = trend[firstValid];
                const lastValid = validTrendIndices[validTrendIndices.length - 1];
                const lastVal = trend[lastValid];
                
                // Calculate slope from first/last valid points (simple interpolation/extrapolation)
                // Or better: fit LR to the valid trend part.
                const validPoints = validTrendIndices.map(i => [i, trend[i]]);
                const trendLR = ss.linearRegression(validPoints);
                const trendLine = ss.linearRegressionLine(trendLR);

                for (let i = 0; i < n; i++) {
                    if (trend[i] === null) {
                        trend[i] = trendLine(i);
                    }
                }
            }
            
            if (useGlobalTrend) {
                const points = series.map((v, i) => [i, v]);
                const lr = ss.linearRegression(points);
                const line = ss.linearRegressionLine(lr);
                trend = series.map((_, i) => line(i));
            }

            // 2. Detrend
            const detrended = series.map((v, i) => v - trend[i]);

            // 3. Seasonal Extraction
            const seasonalComponent = new Array(period).fill(0);
            const seasonalCounts = new Array(period).fill(0);
            
            for (let i = 0; i < n; i++) {
                const idx = i % period;
                seasonalComponent[idx] += detrended[i];
                seasonalCounts[idx]++;
            }
            
            // Average
            for (let i = 0; i < period; i++) {
                if (seasonalCounts[i] > 0) seasonalComponent[i] /= seasonalCounts[i];
            }
            
            // Normalize Seasonal (Sum to 0)
            const seasonMean = seasonalComponent.reduce((a, b) => a + b, 0) / period;
            for (let i = 0; i < period; i++) {
                seasonalComponent[i] -= seasonMean;
            }
            
            // Expand Seasonal to full length
            const seasonal = series.map((_, i) => seasonalComponent[i % period]);

            // 4. Residuals
            const residuals = series.map((v, i) => v - trend[i] - seasonal[i]);
            const fitted = series.map((_, i) => trend[i] + seasonal[i]);

            // 5. Forecast
            // Trend Forecast: Extend the Trend Line (Linear Regression on the Trend Component)
            const trendPoints = trend.map((v, i) => [i, v]);
            const forecastLR = ss.linearRegression(trendPoints); // Fit LR to the extracted trend
            const forecastLine = ss.linearRegressionLine(forecastLR);
            
            const forecasts = [];
            for (let i = 0; i < steps; i++) {
                const idx = n + i;
                const futureTrend = forecastLine(idx);
                const futureSeasonal = seasonalComponent[idx % period];
                forecasts.push(futureTrend + futureSeasonal);
            }

            // 6. Metrics (Strength)
            // Var(Remainder)
            const variance = (arr) => {
                const m = ss.mean(arr);
                return ss.sum(arr.map(x => Math.pow(x - m, 2))) / (arr.length - 1);
            };
            
            // Avoid division by zero
            const varResid = variance(residuals) || 0.000001;
            
            // Trend Strength: 1 - Var(Resid) / Var(Trend + Resid)
            const trendPlusResid = trend.map((t, i) => t + residuals[i]);
            const varTrendResid = variance(trendPlusResid);
            const trendStrength = Math.max(0, 1 - (varResid / varTrendResid));

            // Seasonal Strength: 1 - Var(Resid) / Var(Season + Resid)
            const seasonPlusResid = seasonal.map((s, i) => s + residuals[i]);
            const varSeasonResid = variance(seasonPlusResid);
            const seasonalStrength = Math.max(0, 1 - (varResid / varSeasonResid));

            return {
                trend,
                seasonal,
                residual: residuals,
                fitted,
                forecasts,
                trendStrength,
                seasonalStrength,
                seasonalIndices: seasonalComponent
            };
        }

        function runProphetForecast() {
            const timeVar = document.getElementById('prophetTimeVar').value;
            const valueVar = document.getElementById('prophetValueVar').value;
            const period = parseInt(document.getElementById('prophetPeriod').value);
            const steps = parseInt(document.getElementById('prophetSteps').value);
            const resultsDiv = document.getElementById('prophetResults');
            resultsDiv.innerHTML = '';

            if (!timeVar || !valueVar || !period || !steps) {
                resultsDiv.innerHTML = `<p class="text-red-600">請選擇時間、數值欄位，並填寫季節長度與預測期數。</p>`;
                return;
            }
            if (period <= 1) {
                resultsDiv.innerHTML = `<p class="text-red-600">季節長度 (Period) 必須大於 1。</p>`;
                return;
            }

            const seriesData = jsonData
                .map(row => ({ time: row[timeVar], value: row[valueVar] }))
                .filter(d => d.time != null && typeof d.value === 'number');

            if (seriesData.length === 0) {
                resultsDiv.innerHTML = `<p class="text-red-600">找不到有效的時間序列資料，請確認欄位內容。</p>`;
                return;
            }

            // 依時間排序
            seriesData.sort((a, b) => a.time < b.time ? -1 : 1);
            const yValues = seriesData.map(d => d.value);

            if (yValues.length < period * 2) {
                resultsDiv.innerHTML =
                    `<p class="text-red-600">數據不足。分解模型建議至少有兩倍季節長度的數據 (需要 ${period * 2} 筆，現有 ${yValues.length} 筆)。</p>`;
                return;
            }

            try {
                // 執行 Classical Decomposition
                const result = classicalDecomposition(yValues, period, steps);
                const { trend, seasonal, residual, fitted, forecasts, trendStrength, seasonalStrength } = result;

                // MAPE
                let absPercentErrors = [];
                for (let i = 0; i < yValues.length; i++) {
                    if (yValues[i] !== 0) {
                        absPercentErrors.push(Math.abs((yValues[i] - fitted[i]) / yValues[i]));
                    }
                }
                const mape = absPercentErrors.length > 0 ? ss.mean(absPercentErrors) * 100 : 0;

                // X 軸
                const originalX = seriesData.map(d =>
                    d.time instanceof Date ? d.time.toLocaleDateString() : d.time
                );
                const futureX = [];
                const lastTime = seriesData[seriesData.length - 1].time;
                if (lastTime instanceof Date) {
                    for (let i = 1; i <= steps; i++) {
                        const nextDate = new Date(lastTime);
                        nextDate.setMonth(nextDate.getMonth() + i);
                        futureX.push(nextDate.toLocaleDateString());
                    }
                } else if (!isNaN(lastTime)) {
                    for (let i = 1; i <= steps; i++) futureX.push(lastTime + i);
                } else {
                    for (let i = 1; i <= steps; i++) futureX.push(`預測 ${i}`);
                }

                // 準備下載資料
                const downloadData = [];
                for(let i=0; i<originalX.length; i++) {
                    downloadData.push({
                        time: originalX[i],
                        actual: yValues[i],
                        trend: trend[i],
                        seasonal: seasonal[i],
                        residual: residual[i],
                        type: 'Historical'
                    });
                }
                for(let i=0; i<futureX.length; i++) {
                    downloadData.push({
                        time: futureX[i],
                        actual: null,
                        trend: null, // Could extrapolate trend component if needed for download
                        seasonal: null,
                        residual: null,
                        forecast: forecasts[i],
                        type: 'Forecast'
                    });
                }
                const jsonString = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(downloadData, null, 2));


                // --- 繪圖 (4 Subplots) ---
                const plotDiv = document.createElement('div');
                plotDiv.id = 'prophetForecastPlot';
                plotDiv.style.height = '800px'; // 增加高度以容納 4 張圖
                resultsDiv.appendChild(plotDiv);

                // 1. Data & Forecast (Top subplot)
                const traceActual = { 
                    x: originalX, y: yValues, mode: 'lines', name: 'Original',
                    hoverinfo: 'x+y+name'
                };
                const traceForecast = { 
                    x: futureX, y: forecasts, mode: 'lines+markers', name: 'Forecast', 
                    line: { color: 'red' },
                    hoverinfo: 'x+y+name'
                };
                
                // 2. Trend Component (2nd subplot)
                const traceTrend = { 
                    x: originalX, y: trend, mode: 'lines', name: 'Trend Component', 
                    line:{color:'blue'}, xaxis: 'x2', yaxis: 'y2',
                    hoverinfo: 'x+y+name'
                };
                
                // 3. Seasonal Component (3rd subplot)
                const traceSeasonal = { 
                    x: originalX, y: seasonal, mode: 'lines', name: 'Seasonal Component', 
                    line:{color:'green'}, xaxis: 'x3', yaxis: 'y3',
                    hoverinfo: 'x+y+name'
                };
                
                // 4. Residual Component (4th subplot)
                const traceResid = { 
                    x: originalX, y: residual, type: 'bar', name: 'Residuals', 
                    marker:{color:'gray'}, xaxis: 'x4', yaxis: 'y4',
                    hoverinfo: 'x+y+name'
                };

                // Calculate appropriate tick interval based on data length
                // Aim for approximately 10-15 ticks on the axis
                const dataLength = originalX.length + futureX.length;
                const niceIntervals = [1, 2, 5, 10, 20, 25, 50, 100, 200, 250, 500, 1000];
                let tickInterval = 10; // default
                for (const interval of niceIntervals) {
                    if (dataLength / interval <= 15 && dataLength / interval >= 5) {
                        tickInterval = interval;
                        break;
                    }
                }
                // Fallback: if data is very large, pick larger interval
                if (dataLength / tickInterval > 20) {
                    tickInterval = Math.ceil(dataLength / 10 / 10) * 10; // Round up to nearest 10
                }
                const minorTickInterval = tickInterval / 2;

                const layout = {
                    title: `Classical Decomposition (Additive): ${valueVar}`,
                    
                    // Top subplot (Data/Forecast)
                    xaxis: { 
                        domain: [0, 1], anchor: 'y', showticklabels: true,
                        dtick: tickInterval, tickmode: 'linear', tick0: 0,
                        showgrid: true, gridcolor: '#e5e5e5',
                        minor: { dtick: minorTickInterval, showgrid: true, gridcolor: '#f0f0f0' }
                    },
                    yaxis: { title: 'Data / Forecast', domain: [0.77, 1], anchor: 'x' },
                    
                    // 2nd subplot (Trend)
                    xaxis2: { 
                        domain: [0, 1], anchor: 'y2', showticklabels: true,
                        dtick: tickInterval, tickmode: 'linear', tick0: 0,
                        showgrid: true, gridcolor: '#e5e5e5',
                        minor: { dtick: minorTickInterval, showgrid: true, gridcolor: '#f0f0f0' }
                    },
                    yaxis2: { title: 'Trend', domain: [0.52, 0.74], anchor: 'x2' },
                    
                    // 3rd subplot (Seasonal)
                    xaxis3: { 
                        domain: [0, 1], anchor: 'y3', showticklabels: true,
                        dtick: tickInterval, tickmode: 'linear', tick0: 0,
                        showgrid: true, gridcolor: '#e5e5e5',
                        minor: { dtick: minorTickInterval, showgrid: true, gridcolor: '#f0f0f0' }
                    },
                    yaxis3: { title: 'Seasonal', domain: [0.27, 0.49], anchor: 'x3' },
                    
                    // 4th subplot (Residual)
                    xaxis4: { 
                        domain: [0, 1], anchor: 'y4', showticklabels: true,
                        dtick: tickInterval, tickmode: 'linear', tick0: 0,
                        showgrid: true, gridcolor: '#e5e5e5',
                        minor: { dtick: minorTickInterval, showgrid: true, gridcolor: '#f0f0f0' }
                    },
                    yaxis4: { title: 'Residual', domain: [0, 0.24], anchor: 'x4' },
                    
                    hovermode: 'closest',
                    showlegend: true,
                    height: 800,
                    margin: { t: 50, b: 50, l: 60, r: 20 }
                };
                
                Plotly.newPlot('prophetForecastPlot', [traceActual, traceForecast, traceTrend, traceSeasonal, traceResid], layout, { responsive: true });

                // --- 顯示 Metrics ---
                let html = `
                <div class="mt-6 grid md:grid-cols-2 gap-4">
                    <div class="p-4 bg-blue-50 border border-blue-200 rounded-lg">
                        <h4 class="font-bold text-blue-800">趨勢強度 (Trend Strength)</h4>
                        <p class="text-2xl font-bold text-blue-600">${(trendStrength * 100).toFixed(1)}%</p>
                        <p class="text-xs text-gray-500">反映趨勢在序列中的解釋力</p>
                    </div>
                    <div class="p-4 bg-green-50 border border-green-200 rounded-lg">
                        <h4 class="font-bold text-green-800">季節強度 (Seasonal Strength)</h4>
                        <p class="text-2xl font-bold text-green-600">${(seasonalStrength * 100).toFixed(1)}%</p>
                        <p class="text-xs text-gray-500">反映季節性循環的明顯程度</p>
                    </div>
                </div>
                
                <div class="mt-4 p-4 bg-amber-50 border-l-4 border-amber-500 rounded-r-lg">
                    <p class="text-gray-700">
                        平均絕對百分比誤差 (MAPE): <strong>${mape.toFixed(2)}%</strong>
                    </p>
                </div>
                `;
                
                resultsDiv.innerHTML += html;

            } catch (error) {
                console.error(error);
                resultsDiv.innerHTML = `<p class="text-red-600">分解預測時發生錯誤: ${error.message}</p>`;
            }
        }


        // --- ARIMA(p, d, q)：Hannan–Rissanen 兩階段估計（純 JS / OLS） ---
        function differenceSeries(series, d) {
            let result = series.slice();
            for (let k = 0; k < d; k++) {
                const diff = [];
                for (let i = 1; i < result.length; i++) {
                    diff.push(result[i] - result[i - 1]);
                }
                result = diff;
            }
            return result;
        }

        // 簡單 AR(p) OLS（給 q = 0 或 Hannan–Rissanen 第一步使用）
        function fitAR(series, p) {
            const n = series.length;
            if (p < 1) throw new Error('p 必須 >= 1');
            if (n <= p + 1) throw new Error('資料筆數需大於 p + 1 (目前 ' + n + ' 筆)');

            const X = [];
            const y = [];
            for (let t = p; t < n; t++) {
                const row = [1];
                for (let j = 1; j <= p; j++) {
                    row.push(series[t - j]);
                }
                X.push(row);
                y.push([series[t]]);
            }
            const XT = _T(X);
            const XTX = _mul(XT, X);
            const XTX_inv = _invGauss(XTX);
            const XTy = _mul(XT, y);
            const coefMat = _mul(XTX_inv, XTy);
            const coefs = coefMat.map(r => r[0]);

            const fitted = new Array(n).fill(null);
            for (let t = p; t < n; t++) {
                let pred = coefs[0];
                for (let j = 1; j <= p; j++) {
                    pred += coefs[j] * series[t - j];
                }
                fitted[t] = pred;
            }

            return { coefs, fitted };
        }

        // Hannan–Rissanen：估計 ARIMA 的 AR、MA 係數（在差分後的 ARMA 尺度上）
        function estimateARIMA_HR(series, p, q) {
            const n = series.length;

            if (p < 0 || q < 0) {
                throw new Error('p, q 必須 >= 0');
            }
            if (p === 0 && q === 0) {
                throw new Error('至少需有一個 AR 或 MA 階數 > 0');
            }
            if (n <= p + q + 2) {
                throw new Error(`資料筆數需大於 p + q + 2 (目前 ${n} 筆)`);
            }

            // 若 q = 0，退化為純 AR(p)
            if (q === 0) {
                const pEffective = p > 0 ? p : 1;
                const { coefs, fitted } = fitAR(series, pEffective);
                const residuals = new Array(n).fill(null);
                for (let t = pEffective; t < n; t++) {
                    residuals[t] = series[t] - fitted[t];
                }
                return {
                    constant: coefs[0],
                    ar: coefs.slice(1),
                    ma: [],
                    fitted,
                    residuals,
                    startIndex: pEffective
                };
            }

            // === 第一步：高階 AR(m) 估計，取得殘差 ===
            let m = Math.max(p + q + 1, 10);
            if (m >= n) m = n - 1;
            if (m <= 0) {
                throw new Error('資料筆數不足以進行 Hannan–Rissanen 估計。');
            }

            const X1 = [];
            const y1 = [];
            for (let t = m; t < n; t++) {
                const row = [1];
                for (let j = 1; j <= m; j++) {
                    row.push(series[t - j]);
                }
                X1.push(row);
                y1.push([series[t]]);
            }

            const XT1 = _T(X1);
            const XTX1 = _mul(XT1, X1);
            const XTX1_inv = _invGauss(XTX1);
            const XTy1 = _mul(XT1, y1);
            const coef1Mat = _mul(XTX1_inv, XTy1);
            const a = coef1Mat.map(r => r[0]);

            const residualsStep1 = new Array(n).fill(null);
            for (let t = m; t < n; t++) {
                let pred = a[0];
                for (let j = 1; j <= m; j++) {
                    pred += a[j] * series[t - j];
                }
                residualsStep1[t] = series[t] - pred;
            }

            // === 第二步：AR(p) + MA(q)（殘差當解釋變數）做 OLS ===
            const start = Math.max(m + 1, p, q + 1);
            if (start >= n) {
                throw new Error('資料筆數不足以建立 ARMA 模型，請降低 (p, q) 或縮短 m。');
            }

            const X2 = [];
            const y2 = [];
            for (let t = start; t < n; t++) {
                const row = [1];
                for (let j = 1; j <= p; j++) {
                    row.push(series[t - j]);
                }
                for (let k = 1; k <= q; k++) {
                    const eLag = residualsStep1[t - k] != null ? residualsStep1[t - k] : 0;
                    row.push(eLag);
                }
                X2.push(row);
                y2.push([series[t]]);
            }

            const XT2 = _T(X2);
            const XTX2 = _mul(XT2, X2);
            const XTX2_inv = _invGauss(XTX2);
            const XTy2 = _mul(XT2, y2);
            const betaMat = _mul(XTX2_inv, XTy2);
            const beta = betaMat.map(r => r[0]);

            const constant = beta[0];
            const ar = [];
            for (let j = 0; j < p; j++) {
                ar.push(beta[1 + j]);
            }
            const ma = [];
            for (let k = 0; k < q; k++) {
                ma.push(beta[1 + p + k]);
            }

            const fitted = new Array(n).fill(null);
            const residuals = new Array(n).fill(null);
            for (let t = start; t < n; t++) {
                let pred = constant;
                for (let j = 1; j <= p; j++) {
                    pred += ar[j - 1] * series[t - j];
                }
                for (let k = 1; k <= q; k++) {
                    const eLag = residualsStep1[t - k] != null ? residualsStep1[t - k] : 0;
                    pred += ma[k - 1] * eLag;
                }
                fitted[t] = pred;
                residuals[t] = series[t] - pred;
            }

            return { constant, ar, ma, fitted, residuals, startIndex: start };
        }

        // 使用估計好的 ARIMA 模型進行未來 steps 期預測（在差分後的 ARMA 尺度）
        function forecastARIMA_HR(series, params, steps) {
            const { constant, ar, ma, residuals } = params;
            const p = ar.length;
            const q = ma.length;

            const yHistory = series.slice();
            const eHistory = residuals.slice();
            const forecasts = [];

            for (let h = 0; h < steps; h++) {
                const t = yHistory.length;
                let pred = constant;

                for (let j = 1; j <= p; j++) {
                    const yLag = yHistory[t - j];
                    if (typeof yLag === 'number') {
                        pred += ar[j - 1] * yLag;
                    }
                }

                for (let k = 1; k <= q; k++) {
                    const eLag = eHistory[eHistory.length - k];
                    if (typeof eLag === 'number') {
                        pred += ma[k - 1] * eLag;
                    }
                }

                forecasts.push(pred);
                yHistory.push(pred);
                eHistory.push(0);
            }

            return forecasts;
        }

        // ========================
        // ARIMA Auto Parameter Optimization (p, d, q)
        // ========================

        // Toggle ARIMA Auto Params UI state
        function toggleArimaAutoParams() {
            const autoChecked = document.getElementById('arimaAutoParams').checked;
            const container = document.getElementById('arimaManualParamsContainer');
            
            if (autoChecked) {
                container.classList.add('hidden');
            } else {
                container.classList.remove('hidden');
                document.getElementById('arimaAutoResult').classList.add('hidden');
            }
        }

        // Grid search for optimal ARIMA (p, d, q) parameters
        function autoOptimizeARIMA(yValues) {
            // Need at least some data for validation
            const trainSize = Math.floor(yValues.length * 0.8);
            if (trainSize < 5) {
                return { bestParams: { p: 1, d: 0, q: 0 }, bestMAE: NaN, message: '數據不足以進行優化' };
            }
            
            const trainData = yValues.slice(0, trainSize);
            const valData = yValues.slice(trainSize);
            
            let bestMAE = Infinity;
            let bestParams = { p: 1, d: 0, q: 0 };
            let testCount = 0;
            
            // Grid search: p ∈ [0,3], d ∈ [0,2], q ∈ [0,3]
            // Skip p=0 && q=0 (invalid ARIMA)
            for (let p = 0; p <= 3; p++) {
                for (let d = 0; d <= 2; d++) {
                    for (let q = 0; q <= 3; q++) {
                        if (p === 0 && q === 0) continue; // Invalid ARIMA
                        
                        try {
                            // Apply differencing if needed
                            let trainSeries = trainData.slice();
                            if (d === 1) {
                                if (trainData.length < 3) continue;
                                trainSeries = differenceSeries(trainData, 1);
                            } else if (d === 2) {
                                if (trainData.length < 4) continue;
                                trainSeries = differenceSeries(differenceSeries(trainData, 1), 1);
                            }
                            
                            // Check if enough data for this order
                            if (trainSeries.length <= p + q + 2) continue;
                            
                            // Fit model
                            const params = estimateARIMA_HR(trainSeries, p, q);
                            
                            // Forecast for validation period
                            const forecasts = forecastARIMA_HR(trainSeries, params, valData.length);
                            
                            // Invert differencing for forecasts
                            let finalForecasts = forecasts;
                            if (d === 1) {
                                finalForecasts = invertDifference(trainData, forecasts);
                            } else if (d === 2) {
                                // First invert d=1, then d=1 again
                                const temp = invertDifference(differenceSeries(trainData, 1), forecasts);
                                finalForecasts = invertDifference(trainData, temp);
                            }
                            
                            // Compute MAE
                            const mae = computeMAE(valData, finalForecasts);
                            testCount++;
                            
                            if (mae < bestMAE && !isNaN(mae)) {
                                bestMAE = mae;
                                bestParams = { p, d, q };
                            }
                        } catch (e) {
                            // Skip invalid combinations
                        }
                    }
                }
            }
            
            return { bestParams, bestMAE, testCount };
        }

        // Helper: Invert differencing for forecasts
        function invertDifference(originalSeries, forecastDiffs) {
            const result = [];
            let lastValue = originalSeries[originalSeries.length - 1];
            for (let i = 0; i < forecastDiffs.length; i++) {
                lastValue = lastValue + forecastDiffs[i];
                result.push(lastValue);
            }
            return result;
        }

        function runArimaForecast() {
            const timeVar = document.getElementById('arimaTimeVar').value;
            const valueVar = document.getElementById('arimaValueVar').value;
            const steps = parseInt(document.getElementById('arimaSteps').value);
            const resultsDiv = document.getElementById('arimaResults');
            const autoResultDiv = document.getElementById('arimaAutoResult');
            resultsDiv.innerHTML = '';

            if (!timeVar || !valueVar || isNaN(steps)) {
                resultsDiv.innerHTML = `<p class="text-red-600">請選擇時間、數值欄位，並設定預測期數。</p>`;
                return;
            }

            const seriesData = jsonData
                .map(row => ({ time: row[timeVar], value: row[valueVar] }))
                .filter(d0 => d0.time != null && typeof d0.value === 'number');

            if (seriesData.length === 0) {
                resultsDiv.innerHTML = `<p class="text-red-600">找不到有效的時間序列資料，請確認欄位內容。</p>`;
                return;
            }

            seriesData.sort((a, b) => a.time < b.time ? -1 : 1);
            const yValues = seriesData.map(d0 => d0.value);

            // Check if Auto mode is enabled
            const autoEnabled = document.getElementById('arimaAutoParams').checked;
            let p, d, q;
            
            if (autoEnabled) {
                // Run auto optimization
                resultsDiv.innerHTML = `<p class="text-orange-600">🔍 正在進行參數優化 (Grid Search p,d,q ∈ 0~3)...</p>`;
                
                setTimeout(() => {
                    const { bestParams, bestMAE, testCount, message } = autoOptimizeARIMA(yValues);
                    
                    p = bestParams.p;
                    d = bestParams.d;
                    q = bestParams.q;
                    
                    // Update UI with best values
                    document.getElementById('arimaP').value = p;
                    document.getElementById('arimaD').value = d;
                    document.getElementById('arimaQ').value = q;
                    
                    // Show optimization result
                    if (message) {
                        autoResultDiv.innerHTML = `⚠️ ${message}，使用預設參數：ARIMA(${p},${d},${q})`;
                        autoResultDiv.className = 'text-sm text-orange-600 mb-3';
                    } else {
                        autoResultDiv.innerHTML = `✅ 最佳參數 (驗證集 MAE=${bestMAE.toFixed(2)}): ARIMA(${p},${d},${q})`;
                        autoResultDiv.className = 'text-sm text-green-600 mb-3';
                    }
                    autoResultDiv.classList.remove('hidden');
                    
                    // Continue with forecast
                    runArimaForecastWithParams(yValues, seriesData, p, d, q, steps, timeVar, valueVar, resultsDiv);
                }, 50);
                return;
            } else {
                // Use manual values
                p = parseInt(document.getElementById('arimaP').value);
                d = parseInt(document.getElementById('arimaD').value);
                q = parseInt(document.getElementById('arimaQ').value);
                autoResultDiv.classList.add('hidden');
                
                if (isNaN(p) || isNaN(d) || isNaN(q)) {
                    resultsDiv.innerHTML = `<p class="text-red-600">請設定有效的 p、d、q 值。</p>`;
                    return;
                }
                if (p === 0 && q === 0) {
                    resultsDiv.innerHTML = `<p class="text-red-600">至少需有一個階數 > 0（p 或 q 必須大於 0）。</p>`;
                    return;
                }
            }

            runArimaForecastWithParams(yValues, seriesData, p, d, q, steps, timeVar, valueVar, resultsDiv);
        }

        function runArimaForecastWithParams(yValues, seriesData, p, d, q, steps, timeVar, valueVar, resultsDiv) {
            if (d < 0) d = 0;
            if (d > 2) d = 2;

            let modelSeries = yValues.slice();
            if (d === 1) {
                if (yValues.length < 3) {
                    resultsDiv.innerHTML = `<p class="text-red-600">資料筆數過少，無法進行一階差分後的 ARIMA 建模。</p>`;
                    return;
                }
                modelSeries = differenceSeries(yValues, 1);
            } else if (d === 2) {
                if (yValues.length < 4) {
                    resultsDiv.innerHTML = `<p class="text-red-600">資料筆數過少，無法進行二階差分後的 ARIMA 建模。</p>`;
                    return;
                }
                modelSeries = differenceSeries(differenceSeries(yValues, 1), 1);
            }

            if (modelSeries.length <= p + q + 2) {
                resultsDiv.innerHTML = `<p class="text-red-600">資料筆數不足以支援 ARIMA(${p},${d},${q}) 建模（模型序列僅 ${modelSeries.length} 筆）。</p>`;
                return;
            }

            try {
                const params = estimateARIMA_HR(modelSeries, p, q);
                const { fitted, startIndex } = params;

                const modelForecasts = forecastARIMA_HR(modelSeries, params, steps);

                let levelForecasts = [];
                let levelFitted = []; // Fitted values in original scale for MAPE calculation
                
                if (d === 0) {
                    levelForecasts = modelForecasts.slice();
                    levelFitted = fitted.slice();
                } else if (d === 1) {
                    // Invert fitted values for MAPE calculation
                    for (let t = 1; t < yValues.length; t++) {
                        if (fitted[t - 1] != null) {
                            levelFitted[t] = yValues[t - 1] + fitted[t - 1];
                        }
                    }
                    // Invert forecasts
                    const levelHistory = yValues.slice();
                    modelForecasts.forEach(df => {
                        const next = levelHistory[levelHistory.length - 1] + df;
                        levelHistory.push(next);
                        levelForecasts.push(next);
                    });
                } else if (d === 2) {
                    // For d=2, calculate on original scale
                    const diff1Series = differenceSeries(yValues, 1);
                    // Invert fitted from d=2 to d=1
                    const fittedD1 = [];
                    for (let t = 1; t < diff1Series.length; t++) {
                        if (fitted[t - 1] != null) {
                            fittedD1[t] = diff1Series[t - 1] + fitted[t - 1];
                        }
                    }
                    // Invert from d=1 to d=0
                    for (let t = 2; t < yValues.length; t++) {
                        if (fittedD1[t - 1] != null) {
                            levelFitted[t] = yValues[t - 1] + fittedD1[t - 1];
                        }
                    }
                    // Invert forecasts
                    const diff1History = diff1Series.slice();
                    modelForecasts.forEach(df => {
                        const next = diff1History[diff1History.length - 1] + df;
                        diff1History.push(next);
                    });
                    const forecastDiff1 = diff1History.slice(diff1Series.length);
                    const levelHistory = yValues.slice();
                    forecastDiff1.forEach(df => {
                        const next = levelHistory[levelHistory.length - 1] + df;
                        levelHistory.push(next);
                        levelForecasts.push(next);
                    });
                }

                // Calculate MAPE on original scale
                let absPercentErrors = [];
                for (let t = 0; t < yValues.length; t++) {
                    const actual = yValues[t];
                    const pred = levelFitted[t];
                    if (actual !== 0 && pred != null && !isNaN(pred)) {
                        absPercentErrors.push(Math.abs((actual - pred) / actual));
                    }
                }
                const mape = absPercentErrors.length > 0 ? ss.mean(absPercentErrors) * 100 : 0;

                const originalX = seriesData.map(d0 =>
                    d0.time instanceof Date ? d0.time.toLocaleDateString() : d0.time
                );
                const futureX = [];
                const lastTime = seriesData[seriesData.length - 1].time;
                if (lastTime instanceof Date) {
                    for (let i = 1; i <= steps; i++) {
                        const nextDate = new Date(lastTime);
                        nextDate.setMonth(nextDate.getMonth() + i);
                        futureX.push(nextDate.toLocaleDateString());
                    }
                } else if (!isNaN(lastTime)) {
                    for (let i = 1; i <= steps; i++) futureX.push(lastTime + i);
                } else {
                    for (let i = 1; i <= steps; i++) futureX.push(`預測 ${i}`);
                }

                const plotDiv = document.createElement('div');
                plotDiv.id = 'arimaForecastPlot';
                resultsDiv.appendChild(plotDiv);

                const traces = [];
                traces.push({
                    x: originalX,
                    y: yValues,
                    mode: 'lines+markers',
                    name: '原始數據'
                });

                if (d === 0) {
                    const fittedLevel = new Array(yValues.length).fill(null);
                    for (let t = startIndex; t < yValues.length; t++) {
                        fittedLevel[t] = fitted[t];
                    }
                    traces.push({
                        x: originalX,
                        y: fittedLevel,
                        mode: 'lines',
                        name: 'ARIMA 擬合值',
                        line: { dash: 'dot' }
                    });
                }

                traces.push({
                    x: futureX,
                    y: levelForecasts,
                    mode: 'lines+markers',
                    name: `ARIMA(${p},${d},${q}) 預測`
                });

                const layout = {
                    title: `${valueVar} ARIMA(${p},${d},${q}) 預測`,
                    xaxis: { title: timeVar, type: 'category' },
                    yaxis: { title: valueVar },
                    showlegend: true,
                    paper_bgcolor: '#f9f9f9',
                    plot_bgcolor: '#f9f9f9'
                };
                Plotly.newPlot('arimaForecastPlot', traces, layout, { responsive: true });

                let noteText = d === 0
                    ? 'MAPE 以原始序列（未差分）建模後的殘差計算。'
                    : 'MAPE 係以差分後序列為基準，適合作為模型相對比較指標。';

                let resultHtml = `
                <div class="mt-4 p-4 bg-orange-50 border-l-4 border-orange-500 rounded-r-lg">
                    <h4 class="font-bold">ARIMA 模型摘要</h4>
                    <p class="text-gray-700 mt-1">
                        選用模型：<strong>ARIMA(${p}, ${d}, ${q})</strong>
                    </p>
                    <p class="text-gray-700 mt-1">
                        平均絕對百分比誤差 (MAPE): <strong>${mape.toFixed(2)}%</strong>（${noteText}）
                    </p>
                    <p class="text-xs text-gray-500 mt-1">
                        本工具實作為教學用 ARIMA(p, d, q)：在純 JavaScript 環境下，
                        以 Hannan–Rissanen 兩階段 OLS 近似估計 AR(φ) 與 MA(θ) 係數，並透過差分處理趨勢。
                    </p>
                </div>
                <h3 class="text-lg font-semibold mt-6 mb-2">預測值</h3>
                <div class="overflow-x-auto">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-50">
                            <tr>
                                <th class="p-2 text-left text-xs font-medium text-gray-500 uppercase">未來期數</th>
                                <th class="p-2 text-left text-xs font-medium text-gray-500 uppercase">預測值</th>
                            </tr>
                        </thead>
                        <tbody class="bg-white divide-y divide-gray-200">
            `;
                levelForecasts.forEach((val, i) => {
                    resultHtml += `
                    <tr>
                        <td class="p-2 whitespace-nowrap text-sm font-medium text-gray-900">${futureX[i]}</td>
                        <td class="p-2 text-sm text-gray-500">${val.toFixed(3)}</td>
                    </tr>
                `;
                });
                resultHtml += `</tbody></table></div>`;
                resultsDiv.innerHTML += resultHtml;

            } catch (error) {
                resultsDiv.innerHTML = `<p class="text-red-600">ARIMA 預測時發生錯誤: ${error.message}</p>`;
            }
        }



        // --- Croston Helpers ---
        function toggleCrostonAutoParams() {
            const auto = document.getElementById('crostonAutoParams').checked;
            const manual = document.getElementById('crostonManualParamsContainer');
            const result = document.getElementById('crostonAutoResult');
            if (auto) {
                manual.classList.add('hidden');
                result.classList.remove('hidden');
            } else {
                manual.classList.remove('hidden');
                result.classList.add('hidden');
            }
        }

        function autoOptimizeCroston(series) {
            let bestAlpha = 0.1;
            let bestBeta = 0.1;
            let minMAE = Infinity;
            
            // Simple Grid Search (0.05 to 0.95)
            // Can be refined, but sufficient for basic tuning
            for(let a = 0.05; a <= 0.95; a += 0.05) {
                for(let b = 0.05; b <= 0.95; b += 0.05) {
                    let mae = 0;
                    let count = 0;
                    
                    // Init logic
                    let firstNonZero = -1;
                    for(let i=0; i<series.length; i++) {
                        if(series[i]>0) { firstNonZero=i; break; }
                    }
                    if(firstNonZero === -1) continue;

                    let z = series[firstNonZero];
                    let p = 1;
                    let lastDemandIndex = firstNonZero;

                    // Evaluate Error
                    for(let t = firstNonZero + 1; t < series.length; t++) {
                        const forecast = z / p;
                        mae += Math.abs(series[t] - forecast);
                        count++;

                        if(series[t] > 0) {
                            const y = series[t];
                            const interval = t - lastDemandIndex;
                            lastDemandIndex = t;
                            z = a * y + (1 - a) * z;
                            p = b * interval + (1 - b) * p;
                        }
                    }
                    if(count > 0) {
                        mae /= count;
                        if(mae < minMAE) {
                            minMAE = mae;
                            bestAlpha = a;
                            bestBeta = b;
                        }
                    }
                }
            }
            return { alpha: bestAlpha, beta: bestBeta, mae: minMAE };
        }

        // --- Croston 間歇性需求預測（專業版：α 控制需求大小，β 控制到達間隔，並回報 MAPE） ---
        function crostonForecast(series, alpha, beta) {
            // series 為非負需求量，允許出現許多 0（間歇性需求）
            const n = series.length;
            let firstNonZeroIndex = -1;
            for (let i = 0; i < n; i++) {
                if (series[i] > 0) {
                    firstNonZeroIndex = i;
                    break;
                }
            }
            if (firstNonZeroIndex === -1) {
                throw new Error('資料中完全沒有正需求，無法套用 Croston 方法。');
            }

            // 初始化：第一個正需求大小與平均間隔
            let z = series[firstNonZeroIndex]; // 需求大小平滑值
            let p = 1;                         // 間隔平滑值
            let lastDemandIndex = firstNonZeroIndex;

            let totalDemand = z;
            let demandCount = 1;
            const intervals = [];

            // 逐期更新
            for (let t = firstNonZeroIndex + 1; t < n; t++) {
                const y = series[t];
                if (y > 0) {
                    const interval = t - lastDemandIndex;
                    lastDemandIndex = t;
                    intervals.push(interval);

                    // 需求大小平滑（α）
                    z = alpha * y + (1 - alpha) * z;
                    // 間隔平滑（β）
                    p = beta * interval + (1 - beta) * p;

                    totalDemand += y;
                    demandCount += 1;
                }
                // 若為 0 需求則維持 z、p 不變
            }

            if (p === 0) {
                // throw new Error('間隔平滑值為 0，請檢查資料是否適合 Croston 方法。');
                p = 1; // Fallback to avoid crash
            }

            const levelForecast = z / p;
            const demandDensity = demandCount / n;
            const avgDemand = totalDemand / demandCount;
            const avgInterval = intervals.length > 0 ? ss.mean(intervals) : null;

            return { levelForecast, demandCount, demandDensity, avgDemand, avgInterval };
        }

        function runCrostonForecast() {
            const timeVar = document.getElementById('crostonTimeVar').value;
            const valueVar = document.getElementById('crostonValueVar').value;
            const steps = parseInt(document.getElementById('crostonSteps').value);
            const autoParams = document.getElementById('crostonAutoParams').checked;
            const resultsDiv = document.getElementById('crostonResults');
            resultsDiv.innerHTML = '';

            if (!timeVar || !valueVar || !steps) {
                resultsDiv.innerHTML = `<p class="text-red-600">請選擇時間欄位、需求量欄位，並設定預測期數。</p>`;
                return;
            }

            const seriesData = jsonData
                .map(row => ({ time: row[timeVar], value: row[valueVar] }))
                .filter(d0 => d0.time != null && typeof d0.value === 'number');

            if (seriesData.length === 0) {
                resultsDiv.innerHTML = `<p class="text-red-600">找不到有效的時間序列資料，請確認欄位內容。</p>`;
                return;
            }

            // 依時間排序
            seriesData.sort((a, b) => a.time < b.time ? -1 : 1);
            const yValues = seriesData.map(d0 => d0.value);

            let alpha = 0.3;
            let beta = 0.3;

            if (autoParams) {
                // Auto Optimize
                try {
                    const best = autoOptimizeCroston(yValues);
                    alpha = best.alpha;
                    beta = best.beta;
                    // Update UI
                    document.getElementById('crostonAlpha').value = alpha.toFixed(2);
                    document.getElementById('crostonBeta').value = beta.toFixed(2);
                    const resultText = document.getElementById('crostonAutoResult');
                    resultText.innerText = `Optimized: α=${alpha.toFixed(2)}, β=${beta.toFixed(2)} (MAE: ${best.mae.toFixed(3)})`;
                    resultText.classList.remove('hidden');
                } catch(e) {
                    console.error("Optimization failed", e);
                }
            } else {
                // Manual
                alpha = parseFloat(document.getElementById('crostonAlpha').value);
                beta = parseFloat(document.getElementById('crostonBeta').value);
                if (isNaN(alpha) || alpha <= 0 || alpha > 1) alpha = 0.3;
                if (isNaN(beta) || beta <= 0 || beta > 1) beta = 0.3;
            }

            try {
                const stats = crostonForecast(yValues, alpha, beta);
                const levelForecast = stats.levelForecast;

                // 只針對非零需求期計算 MAPE
                const positiveDemands = yValues.filter(v => v > 0);
                let absPercentErrors = [];
                positiveDemands.forEach(v => {
                    if (v !== 0) {
                        absPercentErrors.push(Math.abs((v - levelForecast) / v));
                    }
                });
                const mape = absPercentErrors.length > 0 ? ss.mean(absPercentErrors) * 100 : NaN;
                const demandDensityPercent = stats.demandDensity * 100;

                // 建立未來 X 軸標籤
                const originalX = seriesData.map(d0 =>
                    d0.time instanceof Date ? d0.time.toLocaleDateString() : d0.time
                );
                const futureX = [];
                const lastTime = seriesData[seriesData.length - 1].time;
                if (lastTime instanceof Date) {
                    for (let i = 1; i <= steps; i++) {
                        const nextDate = new Date(lastTime);
                        nextDate.setMonth(nextDate.getMonth() + i);
                        futureX.push(nextDate.toLocaleDateString());
                    }
                } else if (!isNaN(lastTime)) {
                    for (let i = 1; i <= steps; i++) futureX.push(lastTime + i);
                } else {
                    for (let i = 1; i <= steps; i++) futureX.push(`預測 ${i}`);
                }

                // Croston 的預測值在未來每一期皆相同
                const forecastSeries = new Array(steps).fill(levelForecast);

                const plotDiv = document.createElement('div');
                plotDiv.id = 'crostonForecastPlot';
                resultsDiv.appendChild(plotDiv);

                const traces = [
                    {
                        x: originalX,
                        y: yValues,
                        mode: 'lines+markers',
                        name: '原始需求'
                    },
                    {
                        x: futureX,
                        y: forecastSeries,
                        mode: 'lines+markers',
                        name: 'Croston 預測需求水準'
                    }
                ];

                const layout = {
                    title: `${valueVar} Croston 間歇需求預測`,
                    xaxis: { title: timeVar, type: 'category' },
                    yaxis: { title: valueVar },
                    showlegend: true,
                    paper_bgcolor: '#f9f9f9',
                    plot_bgcolor: '#f9f9f9'
                };
                Plotly.newPlot('crostonForecastPlot', traces, layout, { responsive: true });

                const mapeText = isNaN(mape)
                    ? '—'
                    : `${mape.toFixed(2)}%`;

                const avgDemandText = stats.avgDemand != null && !isNaN(stats.avgDemand)
                    ? stats.avgDemand.toFixed(3)
                    : '—';

                const avgIntervalText = stats.avgInterval != null && !isNaN(stats.avgInterval)
                    ? stats.avgInterval.toFixed(2)
                    : '—';

                let resultHtml = `
                <div class="mt-4 p-4 bg-lime-50 border-l-4 border-lime-500 rounded-r-lg">
                    <h4 class="font-bold">Croston 模型摘要（專業版）</h4>
                    <p class="text-gray-700 mt-1">
                        估計之平均需求水準：<strong>${levelForecast.toFixed(3)}</strong>
                    </p>
                    <p class="text-gray-700 mt-1">
                        需求密度：<strong>${demandDensityPercent.toFixed(1)}%</strong>（有需求期數 / 總期數）
                    </p>
                    <p class="text-gray-700 mt-1">
                        平均每次需求量：<strong>${avgDemandText}</strong>；平均到達間隔：<strong>${avgIntervalText}</strong> 期
                    </p>
                    <p class="text-gray-700 mt-1">
                        MAPE（僅針對非零需求期）：<strong>${mapeText}</strong>
                    </p>
                    <p class="text-xs text-gray-500 mt-1">
                        α 控制「每次需求大小」的平滑速度，β 控制「需求到達間隔」的平滑速度；本實作適合用於備品、慢料等間歇性需求模型的教學與比較。
                    </p>
                </div>
                <h3 class="text-lg font-semibold mt-6 mb-2">預測值</h3>
                <div class="overflow-x-auto">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-50">
                            <tr>
                                <th class="p-2 text-left text-xs font-medium text-gray-500 uppercase">未來期數</th>
                                <th class="p-2 text-left text-xs font-medium text-gray-500 uppercase">預測需求</th>
                            </tr>
                        </thead>
                        <tbody class="bg-white divide-y divide-gray-200">
            `;
                forecastSeries.forEach((val, i) => {
                    resultHtml += `
                    <tr>
                        <td class="p-2 whitespace-nowrap text-sm font-medium text-gray-900">${futureX[i]}</td>
                        <td class="p-2 text-sm text-gray-500">${val.toFixed(3)}</td>
                    </tr>
                `;
                });
                resultHtml += `</tbody></table></div>`;
                resultsDiv.innerHTML += resultHtml;

            } catch (error) {
                resultsDiv.innerHTML = `<p class="text-red-600">Croston 預測時發生錯誤: ${error.message}</p>`;
            }
        }

        // --- Lightweight matrix utilities (avoid jStat shape pitfalls) ---
        function _eye(n) { return Array.from({ length: n }, (_, i) => Array.from({ length: n }, (_, j) => i === j ? 1 : 0)); }
        function _T(A) {
            const m = A.length, n = A[0].length; const AT = Array.from({ length: n }, () => Array(m).fill(0));
            for (let i = 0; i < m; i++) { for (let j = 0; j < n; j++) { AT[j][i] = A[i][j]; } } return AT;
        }
        function _mul(A, B) { // (m×n)*(n×p) -> (m×p)
            const m = A.length, n = A[0].length, p = B[0].length; const C = Array.from({ length: m }, () => Array(p).fill(0));
            for (let i = 0; i < m; i++) {
                for (let k = 0; k < n; k++) {
                    const aik = A[i][k];
                    for (let j = 0; j < p; j++) { C[i][j] += aik * B[k][j]; }
                }
            } return C;
        }
        function _add(A, B) { return A.map((r, i) => r.map((v, j) => v + B[i][j])); }
        function _scale(A, c) { return A.map(r => r.map(v => v * c)); }
        function _invGauss(M) {
            const n = M.length; const A = M.map(r => r.slice()); const I = _eye(n);
            for (let i = 0; i < n; i++) {
                let piv = i; for (let r = i + 1; r < n; r++) if (Math.abs(A[r][i]) > Math.abs(A[piv][i])) piv = r;
                if (Math.abs(A[piv][i]) < 1e-12) throw new Error('矩陣不可逆（可能共線）');
                if (piv !== i) { [A[i], A[piv]] = [A[piv], A[i]];[I[i], I[piv]] = [I[piv], I[i]]; }
                const d = A[i][i]; for (let j = 0; j < n; j++) { A[i][j] /= d; I[i][j] /= d; }
                for (let r = 0; r < n; r++) if (r !== i) {
                    const f = A[r][i];
                    for (let j = 0; j < n; j++) { A[r][j] -= f * A[i][j]; I[r][j] -= f * I[i][j]; }
                }
            }
            return I;
        }

        // --- Logistic Regression with robust IRLS + Ridge ---
        function runLogistic() {
            const yVar = document.getElementById('logisticY').value;
            let xVars = Array.from(document.getElementById('logisticX').selectedOptions).map(opt => opt.value);
            const resultsDiv = document.getElementById('logisticResults');
            resultsDiv.innerHTML = '';
            logisticModel = null; // Reset the model

            if (!yVar || xVars.length === 0) {
                resultsDiv.innerHTML = `<p class="text-red-600">請選擇應變數 (Y) 和至少一個自變數 (X)。</p>`; return;
            }

            // Check for Y in X and filter it out
            if (xVars.includes(yVar)) {
                xVars = xVars.filter(v => v !== yVar);
                if (xVars.length === 0) {
                    resultsDiv.innerHTML = '<p class="text-red-600">錯誤：目標變數 (Y) 不能同時作為特徵變數 (X)。請選擇其他特徵變數。</p>';
                    return;
                }
                resultsDiv.innerHTML = `<p class="text-orange-600 mb-2">⚠️ 已自動移除 X 中與 Y 重複的變數「${yVar}」</p>`;
            }

            const uniqueY = [...new Set(jsonData.map(row => row[yVar]).filter(v => v != null))].sort();
            if (uniqueY.length !== 2) {
                resultsDiv.innerHTML = `<p class="text-red-600">應變數必須為二元類別 (只有兩種值)。</p>`; return;
            }

            const Xraw = [], y = [];
            for (const row of jsonData) {
                if (row[yVar] == null) continue;
                const feat = [];
                let ok = true;
                for (const k of xVars) {
                    const v = Number(row[k]);
                    if (!Number.isFinite(v)) { ok = false; break; }
                    feat.push(v);
                }
                if (!ok) continue;
                Xraw.push(feat);
                y.push(row[yVar] === uniqueY[1] ? 1 : 0);
            }

            if (Xraw.length < xVars.length + 2) {
                resultsDiv.innerHTML = `<p class="text-red-600">有效的數值資料列不足 (${Xraw.length} 筆)，至少需要 ${xVars.length + 2} 筆。</p>`; return;
            }

            const n = Xraw.length, p0 = xVars.length;
            const means = Array(p0).fill(0), sds = Array(p0).fill(1);
            for (let j = 0; j < p0; j++) {
                const col = Xraw.map(r => r[j]);
                const m = jStat.mean(col); let sd = jStat.stdev(col, true); if (sd === 0) sd = 1;
                means[j] = m; sds[j] = sd;
                for (let i = 0; i < n; i++) Xraw[i][j] = (Xraw[i][j] - m) / sd;
            }

            const X = Xraw.map(r => [1, ...r]);
            const p = X[0].length;
            const lambda = 1e-4, maxIter = 50, tol = 1e-6;
            let beta = Array(p).fill(0).map(v => [v]);

            try {
                for (let it = 0; it < maxIter; it++) {
                    const eta = _mul(X, beta);
                    const pHat = eta.map(e => 1 / (1 + Math.exp(-e[0])));
                    const Wdiag = pHat.map(pi => Math.max(pi * (1 - pi), 1e-6));
                    const z = eta.map((e, i) => [e[0] + (y[i] - pHat[i]) / Wdiag[i]]);
                    const WX = X.map((row, i) => row.map(v => v * Wdiag[i]));
                    let XTWX = _mul(_T(X), WX);
                    const reg = _eye(p); reg[0][0] = 0;
                    XTWX = _add(XTWX, _scale(reg, lambda));
                    const XTWz = _mul(_T(WX), z);
                    const inv = _invGauss(XTWX);
                    const betaNew = _mul(inv, XTWz);
                    let diff = 0;
                    for (let j = 0; j < p; j++) { const d = betaNew[j][0] - beta[j][0]; diff += d * d; }
                    beta = betaNew;
                    if (Math.sqrt(diff) < tol) break;
                }

                const etaF = _mul(X, beta).map(v => v[0]);
                const Wf = etaF.map(e => { const pi = 1 / (1 + Math.exp(-e)); return Math.max(pi * (1 - pi), 1e-6); });
                const WXf = X.map((row, i) => row.map(v => v * Wf[i]));
                let XTWXf = _mul(_T(X), WXf);
                const reg_final = _eye(p); reg_final[0][0] = 0;
                XTWXf = _add(XTWXf, _scale(reg_final, lambda));
                const cov = _invGauss(XTWXf);
                const se = cov.map((row, i) => Math.sqrt(Math.max(row[i], 0)));
                const betaVec = beta.map(b => b[0]);
                const zScores = betaVec.map((b, i) => se[i] === 0 ? 0 : b / se[i]);
                const pVals = zScores.map(z => 2 * (1 - jStat.normal.cdf(Math.abs(z), 0, 1)));
                const OR = betaVec.map(b => Math.exp(b));

                // Store model for prediction
                logisticModel = { beta: betaVec, xVars, uniqueY, means, sds };

                let html = `<h3 class="text-lg font-semibold mb-2">邏輯斯迴歸模型結果（IRLS + Ridge）</h3>
          <p class="text-sm text-gray-600 mb-4">Y 編碼：${uniqueY[1]} = 1，${uniqueY[0]} = 0</p>
          <div class="overflow-x-auto"><table class="min-w-full divide-y divide-gray-200">
          <thead class="bg-gray-50"><tr>
            <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">變數</th>
            <th class="px-4 py-2 text-right text-xs font-medium text-gray-500 uppercase">β</th>
            <th class="px-4 py-2 text-right text-xs font-medium text-gray-500 uppercase">SE</th>
            <th class="px-4 py-2 text-right text-xs font-medium text-gray-500 uppercase">z</th>
            <th class="px-4 py-2 text-right text-xs font-medium text-gray-500 uppercase">p</th>
            <th class="px-4 py-2 text-right text-xs font-medium text-gray-500 uppercase">OR</th>
          </thead><tbody class="bg-white divide-y divide-gray-200">`;
                const names = ['截距 (Intercept)', ...xVars];
                for (let j = 0; j < p; j++) {
                    html += `<tr>
            <td class="px-4 py-2 text-sm">${names[j]}</td>
            <td class="px-4 py-2 text-sm text-right">${betaVec[j].toFixed(6)}</td>
            <td class="px-4 py-2 text-sm text-right">${se[j].toFixed(6)}</td>
            <td class="px-4 py-2 text-sm text-right">${zScores[j].toFixed(3)}</td>
            <td class="px-4 py-2 text-sm text-right">${pVals[j] < 1e-6 ? '&lt;1e-6' : pVals[j].toFixed(6)}</td>
            <td class="px-4 py-2 text-sm text-right">${OR[j].toFixed(4)}</td>
          </tr>`;
                }
                html += `</tbody></table></div>
          <div class="mt-3 p-3 bg-blue-50 border rounded text-xs">
            解讀：OR>1 表示變數增加，事件（=1）勝算提高；OR<1 表示降低。若遇到分離或高度共線，請減少特徵或增大 Ridge λ。
          </div>`;

                // === 計算分類指標 (Confusion Matrix & Metrics) ===
                const predictions = etaF.map(e => {
                    const prob = 1 / (1 + Math.exp(-e));
                    return prob >= 0.5 ? 1 : 0;
                });

                // Build confusion matrix
                let TP = 0, TN = 0, FP = 0, FN = 0;
                for (let i = 0; i < y.length; i++) {
                    if (y[i] === 1 && predictions[i] === 1) TP++;
                    else if (y[i] === 0 && predictions[i] === 0) TN++;
                    else if (y[i] === 0 && predictions[i] === 1) FP++;
                    else if (y[i] === 1 && predictions[i] === 0) FN++;
                }

                // Calculate metrics
                const accuracy = (TP + TN) / (TP + TN + FP + FN);
                const precision = TP + FP > 0 ? TP / (TP + FP) : 0;
                const recall = TP + FN > 0 ? TP / (TP + FN) : 0;
                const f1Score = precision + recall > 0 ? 2 * (precision * recall) / (precision + recall) : 0;

                // Add metrics display
                html += `
          <div class="mt-6 border-t pt-6">
            <h4 class="text-lg font-semibold mb-4 flex items-center gap-2">
              <svg class="w-5 h-5 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
              </svg>
              模型分類指標 (Classification Metrics)
            </h4>
            
            <!-- Metrics Cards Grid -->
            <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
              <div class="bg-gradient-to-br from-green-50 to-emerald-50 p-4 rounded-lg border border-green-200 shadow-sm">
                <div class="text-xs font-medium text-green-700 mb-1">Accuracy 準確率</div>
                <div class="text-2xl font-bold text-green-600">${(accuracy * 100).toFixed(2)}%</div>
              </div>
              <div class="bg-gradient-to-br from-blue-50 to-indigo-50 p-4 rounded-lg border border-blue-200 shadow-sm">
                <div class="text-xs font-medium text-blue-700 mb-1">Precision 精確率</div>
                <div class="text-2xl font-bold text-blue-600">${(precision * 100).toFixed(2)}%</div>
              </div>
              <div class="bg-gradient-to-br from-purple-50 to-violet-50 p-4 rounded-lg border border-purple-200 shadow-sm">
                <div class="text-xs font-medium text-purple-700 mb-1">Recall 召回率</div>
                <div class="text-2xl font-bold text-purple-600">${(recall * 100).toFixed(2)}%</div>
              </div>
              <div class="bg-gradient-to-br from-orange-50 to-amber-50 p-4 rounded-lg border border-orange-200 shadow-sm">
                <div class="text-xs font-medium text-orange-700 mb-1">F1-Score</div>
                <div class="text-2xl font-bold text-orange-600">${(f1Score * 100).toFixed(2)}%</div>
              </div>
            </div>

            <!-- Confusion Matrix -->
            <div class="bg-gray-50 p-4 rounded-lg border border-gray-200 mb-4">
              <h5 class="font-semibold text-gray-700 mb-3">混淆矩陣 (Confusion Matrix)</h5>
              <div class="flex justify-center items-center gap-3">
                <div class="font-semibold text-gray-700 text-sm" style="writing-mode: vertical-lr; transform: rotate(180deg); letter-spacing: 0.1em;">Actual</div>
                <table class="text-sm" style="border-collapse: separate; border-spacing: 0;">
                  <thead>
                    <tr>
                      <th class="px-3 py-2"></th>
                      <th colspan="2" class="px-4 py-2 text-center font-semibold text-gray-700 border-b-2 border-gray-400">Predicted</th>
                    </tr>
                    <tr>
                      <th class="px-3 py-2"></th>
                      <th class="px-6 py-2 text-center font-medium bg-blue-50 border border-gray-300">${uniqueY[1]}</th>
                      <th class="px-6 py-2 text-center font-medium bg-blue-50 border border-gray-300">${uniqueY[0]}</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <th class="px-4 py-3 text-center font-medium bg-blue-50 border border-gray-300">${uniqueY[1]}</th>
                      <td class="px-6 py-3 text-center font-bold text-green-700 bg-green-100 border border-gray-300" style="min-width: 60px;">${TP}</td>
                      <td class="px-6 py-3 text-center font-bold text-red-700 bg-red-100 border border-gray-300" style="min-width: 60px;">${FN}</td>
                    </tr>
                    <tr>
                      <th class="px-4 py-3 text-center font-medium bg-blue-50 border border-gray-300">${uniqueY[0]}</th>
                      <td class="px-6 py-3 text-center font-bold text-red-700 bg-red-100 border border-gray-300">${FP}</td>
                      <td class="px-6 py-3 text-center font-bold text-green-700 bg-green-100 border border-gray-300">${TN}</td>
                    </tr>
                  </tbody>
                </table>
              </div>
              <div class="mt-3 text-xs text-gray-600">
                <div class="grid grid-cols-2 gap-2">
                  <div><strong>TP (True Positive)</strong>: ${TP} - 正確預測為陽性</div>
                  <div><strong>TN (True Negative)</strong>: ${TN} - 正確預測為陰性</div>
                  <div><strong>FP (False Positive)</strong>: ${FP} - 誤判為陽性</div>
                  <div><strong>FN (False Negative)</strong>: ${FN} - 誤判為陰性</div>
                </div>
              </div>
            </div>

            <!-- Metrics Explanation -->
            <div class="bg-indigo-50 p-4 rounded-lg border border-indigo-200">
              <h5 class="font-semibold text-indigo-900 mb-2">📊 指標說明</h5>
              <div class="text-xs text-indigo-800 space-y-2">
                <div><strong>Accuracy (準確率)</strong>: 所有預測中正確的比例 = (TP + TN) / 總數。適合平衡資料集。</div>
                <div><strong>Precision (精確率)</strong>: 預測為陽性中真正為陽性的比例 = TP / (TP + FP)。關注「預測的準確性」。</div>
                <div><strong>Recall (召回率)</strong>: 實際為陽性中被正確預測的比例 = TP / (TP + FN)。關注「找出所有陽性樣本」。</div>
                <div><strong>F1-Score</strong>: Precision 和 Recall 的調和平均數，平衡兩者。適合不平衡資料集。</div>
              </div>
            </div>
          </div>`;

                resultsDiv.innerHTML = html;

                // Add prediction interface - v2.2 增強版：使用DOM元素創建以確保正確性
                const predictionContainer = document.createElement('div');
                predictionContainer.id = 'logisticPredictionInterface';
                predictionContainer.className = 'mt-8 pt-6 border-t';

                const title = document.createElement('h3');
                title.className = 'text-lg font-semibold mb-4';
                title.textContent = '進行預測';
                predictionContainer.appendChild(title);

                const inputGrid = document.createElement('div');
                inputGrid.className = 'grid grid-cols-1 md:grid-cols-2 gap-4';

                xVars.forEach((varName, idx) => {
                    // v2.5.1 修復: 使用索引ID避免中文變數名衝突
                    const inputId = `pred_in_${idx}`;

                    const inputDiv = document.createElement('div');

                    const label = document.createElement('label');
                    label.htmlFor = inputId;
                    label.className = 'block text-sm font-medium text-gray-700';
                    label.textContent = varName;  // 直接設定textContent確保正確
                    label.setAttribute('data-var-name', varName);  // 額外保存
                    label.setAttribute('data-var-index', idx);

                    const input = document.createElement('input');
                    input.type = 'number';
                    input.id = inputId;
                    input.className = 'mt-1 block w-full rounded-md border-gray-300 shadow-sm';
                    input.placeholder = `請輸入${varName}`;
                    input.setAttribute('data-var-name', varName);
                    input.setAttribute('data-var-index', idx);
                    input.step = 'any';

                    inputDiv.appendChild(label);
                    inputDiv.appendChild(input);
                    inputGrid.appendChild(inputDiv);

                    console.log(`✅ 創建輸入欄位 [${idx}]: "${varName}" -> ID: ${inputId}`);
                });

                predictionContainer.appendChild(inputGrid);

                // Use HTML string for button to ensure onclick works reliably
                const btnContainer = document.createElement('div');
                btnContainer.innerHTML = `
                    <button id="runPredictionBtn" onclick="predictLogistic()" class="mt-4 bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition-colors shadow-md flex items-center gap-2">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 7h6m0 10v-3m-3 3h.01M9 17h.01M9 14h.01M12 14h.01M15 11h.01M12 11h.01M9 11h.01M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z"></path></svg>
                        計算機率
                    </button>
                `;
                predictionContainer.appendChild(btnContainer);

                const resultDiv = document.createElement('div');
                resultDiv.id = 'predictionResult';
                resultDiv.className = 'mt-4 text-lg font-semibold hidden'; // Default hidden
                predictionContainer.appendChild(resultDiv);

                resultsDiv.appendChild(predictionContainer);
                console.log('✅ 預測介面已創建 (使用 onclick)');

            } catch (err) {
                resultsDiv.innerHTML = `<p class="text-red-600">建立模型時發生錯誤：${err.message}</p>`;
            }
        }

        // ===== v2.5 革命性修復: 使用 Modal 彈窗顯示預測結果 =====
        // Explicitly attach to window to ensure global scope access
        window.predictLogistic = function () {
            try {
                console.log('🔵 predictLogistic 被調用了！');
                if (!logisticModel) {
                    alert('❌ 錯誤：模型不存在，請先執行邏輯斯迴歸。');
                    return;
                }

                const { beta, xVars, uniqueY, means, sds } = logisticModel;

                // 讀取輸入值
                let inputValues = [];
                for (let idx = 0; idx < xVars.length; idx++) {
                    const inputId = `pred_in_${idx}`;
                    const elem = document.getElementById(inputId);
                    if (!elem) throw new Error(`找不到輸入欄位: ${xVars[idx]}`);
                    const val = parseFloat(elem.value);
                    if (isNaN(val)) {
                        alert(`請輸入有效的數值：${xVars[idx]}`);
                        return;
                    }
                    inputValues.push(val);
                }

                // Standardize input
                const standardizedInputs = inputValues.map((val, i) => (val - means[i]) / sds[i]);

                // Add intercept and calculate eta
                const x_pred = [1, ...standardizedInputs];
                let eta = 0;
                for (let i = 0; i < x_pred.length; i++) {
                    eta += x_pred[i] * beta[i];
                }
                const probability = 1 / (1 + Math.exp(-eta));
                const prob_y1 = probability;
                const prob_y0 = 1 - probability;

                // Display results inline (consistent with other predictions)
                const resultDiv = document.getElementById('predictionResult');
                if (!resultDiv) {
                    alert('❌ 錯誤：找不到結果顯示區域');
                    return;
                }

                // Create inline result HTML
                const resultHtml = `
                    <div class="p-4 bg-white border border-indigo-200 rounded-lg shadow-sm">
                        <div class="mb-4 pb-3 border-b border-gray-200">
                            <p class="text-sm text-gray-600 mb-2">輸入資料：</p>
                            <div class="grid grid-cols-2 gap-2 text-sm">
                                ${xVars.map((v, idx) => `
                                    <div class="text-gray-700">
                                        <span class="font-medium">${v}:</span> 
                                        <span class="text-gray-900">${inputValues[idx]}</span>
                                    </div>
                                `).join('')}
                            </div>
                        </div>

                        <div class="space-y-4">
                            <div>
                                <div class="flex justify-between items-end mb-1">
                                    <span class="text-lg font-bold text-gray-800">結果為 ${uniqueY[1]} 的機率 :</span>
                                    <span class="text-2xl font-bold text-indigo-600">${(prob_y1 * 100).toFixed(2)}%</span>
                                </div>
                                <div class="w-full bg-gray-200 rounded-full h-2.5">
                                    <div class="bg-indigo-600 h-2.5 rounded-full" style="width: ${prob_y1 * 100}%"></div>
                                </div>
                            </div>
                            
                            <div>
                                <div class="flex justify-between items-end mb-1">
                                    <span class="text-sm font-medium text-gray-600">結果為 ${uniqueY[0]} 的機率 :</span>
                                    <span class="text-lg font-bold text-gray-500">${(prob_y0 * 100).toFixed(2)}%</span>
                                </div>
                                <div class="w-full bg-gray-200 rounded-full h-1.5">
                                    <div class="bg-gray-400 h-1.5 rounded-full" style="width: ${prob_y0 * 100}%"></div>
                                </div>
                            </div>
                        </div>

                        <!-- Prediction Profiler Graphs -->
                        <div class="mt-6 pt-4 border-t border-gray-200">
                            <h4 class="text-md font-bold text-gray-800 mb-3">📈 Prediction Profiler (預測分析圖)</h4>
                            <div id="logisticProfilers" class="grid grid-cols-1 md:grid-cols-2 gap-4"></div>
                        </div>
                    </div>
                `;

                resultDiv.innerHTML = resultHtml;

                // Generate Profiler Graphs
                const profilerContainer = document.getElementById('logisticProfilers');
                
                // For each X variable, plot P(Y=1) vs X_i, holding other Xs constant
                xVars.forEach((xName, xIdx) => {
                    const plotDiv = document.createElement('div');
                    plotDiv.style.height = '250px';
                    profilerContainer.appendChild(plotDiv);

                    // 1. Get Range for this X from original data
                    const colValues = jsonData.map(d => parseFloat(d[xName])).filter(v => !isNaN(v));
                    const minX = Math.min(...colValues);
                    const maxX = Math.max(...colValues);
                    // Extend range slightly for better visual
                    const range = maxX - minX;
                    const plotMin = minX - range * 0.05;
                    const plotMax = maxX + range * 0.05;

                    // 2. Generate curve points
                    const steps = 50;
                    const xPlot = [];
                    const yPlot = [];
                    
                    // Fixed contribution from OTHER variables
                    // eta = beta0 + beta_i * std(X_i) + sum(beta_k * std(X_k))
                    // Let calculate 'base eta' removing the current variable's contribution
                    // current standardized input for this var
                    const stdValCurrent = standardizedInputs[xIdx]; 
                    const termCurrent = beta[xIdx + 1] * stdValCurrent; // beta uses 1-based index for Xs (0 is intercept)
                    const baseEta = eta - termCurrent; 

                    for (let i = 0; i <= steps; i++) {
                        const val = plotMin + (plotMax - plotMin) * (i / steps);
                        xPlot.push(val);
                        
                        // Standardize temporary X value
                        const stdVal = (val - means[xIdx]) / sds[xIdx];
                        // Calculate new eta
                        const newEta = baseEta + beta[xIdx + 1] * stdVal;
                        // Calculate probability
                        const prob = 1 / (1 + Math.exp(-newEta));
                        yPlot.push(prob);
                    }

                    // 3. Plot S-Curve
                    const traceLine = {
                        x: xPlot,
                        y: yPlot,
                        type: 'scatter',
                        mode: 'lines',
                        name: 'Probability Curve',
                        line: { color: '#374151', width: 2 }
                    };

                    // 4. Plot Current Prediction Point
                    const tracePoint = {
                        x: [inputValues[xIdx]],
                        y: [prob_y1],
                        type: 'scatter',
                        mode: 'markers',
                        name: 'Current Prediction',
                        marker: { color: '#dc2626', size: 10, symbol: 'cross' }
                    };
                    
                    // 5. Reference Lines (Current X and Y)
                    // We can add shapes for crosshairs
                    
                    const layout = {
                        title: { text: xName, font: { size: 14 } },
                        margin: { l: 40, r: 20, t: 30, b: 30 },
                        xaxis: { title: xName, range: [plotMin, plotMax] },
                        yaxis: { title: `P(${uniqueY[1]})`, range: [-0.05, 1.05] },
                        showlegend: false,
                        shapes: [
                            // Vertical Line at current X
                            {
                                type: 'line',
                                x0: inputValues[xIdx], x1: inputValues[xIdx],
                                y0: 0, y1: 1,
                                line: { color: '#dc2626', width: 1, dash: 'dash' }
                            },
                            // Horizontal Line at current Y
                            {
                                type: 'line',
                                x0: plotMin, x1: plotMax,
                                y0: prob_y1, y1: prob_y1,
                                line: { color: '#dc2626', width: 1, dash: 'dash' }
                            }
                        ]
                    };

                    Plotly.newPlot(plotDiv, [traceLine, tracePoint], layout, { responsive: true, displayModeBar: false });
                });


                resultDiv.classList.remove('hidden');
                console.log('✅ 預測結果已顯示（內聯方式）');

            } catch (e) {
                console.error(e);
                alert(`預測時發生錯誤: ${e.message}`);
            }
        };

        // 確保 closeModal 全域可見
        // 確保 closeModal 全域可見
        window.closeModal = function () {
            const modal = document.getElementById('predictionModal');
            if (modal) {
                modal.classList.remove('show');
                console.log('🚪 Modal 已關閉');
            } else {
                console.error('❌ 找不到 predictionModal 元素');
            }
        };


        /**
         * Robust feature importance from ml.js Decision Tree JSON.
         * Directly accumulates the library-provided 'gain' at each split node.
         * Supports multiple JSON shapes and field names across ml.js versions.
         * @param {object} treeJson - regressor.toJSON() (or its .root)
         * @param {number} numFeatures - number of X variables used in training
         * @returns {number[]} normalized importance for each feature index (length = numFeatures)
         */
        function calculateDtImportance(treeJson, numFeatures) {
            const importances = new Array(numFeatures).fill(0);
            const root = (treeJson && typeof treeJson === 'object' && treeJson.root) ? treeJson.root : treeJson;

            function childKeys(node) {
                const keys = [];
                if (!node || typeof node !== 'object') return keys;
                if (node.left) keys.push('left');
                if (node.right) keys.push('right');
                if (node.trueBranch) keys.push('trueBranch');
                if (node.falseBranch) keys.push('falseBranch');
                if (Array.isArray(node.children)) return ['children'];
                return keys;
            }
            function featureIndex(node) {
                const cand = ['splitColumn', 'column', 'attribute', 'feature', 'index'];
                for (const k of cand) {
                    if (node[k] !== undefined && node[k] !== null && Number.isFinite(+node[k])) return +node[k];
                }
                return null;
            }
            function nodeGain(node) {
                const cand = ['gain', 'gainRatio', 'impurityReduction', 'varianceReduction'];
                for (const k of cand) {
                    if (node[k] !== undefined && node[k] !== null && Number.isFinite(+node[k])) return +node[k];
                }
                return 0;
            }
            function traverse(node) {
                if (!node || typeof node !== 'object') return;
                const fi = featureIndex(node);
                const g = nodeGain(node);
                if (fi !== null && g > 0 && fi >= 0 && fi < importances.length) importances[fi] += g;
                const cks = childKeys(node);
                if (cks.includes('children')) {
                    for (const child of node.children) traverse(child);
                } else {
                    if (node.left) traverse(node.left);
                    if (node.right) traverse(node.right);
                    if (node.trueBranch) traverse(node.trueBranch);
                    if (node.falseBranch) traverse(node.falseBranch);
                }
            }
            traverse(root);
            const total = importances.reduce((a, b) => a + b, 0);
            if (total > 0) for (let i = 0; i < importances.length; i++) importances[i] /= total;
            return importances;
        }

        function runDecisionTree() {
            const yVar = document.getElementById('dtY').value;
            let xVars = Array.from(document.getElementById('dtX').selectedOptions).map(opt => opt.value);
            const maxDepth = parseInt(document.getElementById('dtMaxDepth').value);
            const minSamplesLeaf = parseInt(document.getElementById('dtMinSamplesLeaf').value);
            const resultsDiv = document.getElementById('dtResults');
            resultsDiv.innerHTML = '';

            if (!yVar || xVars.length === 0) {
                resultsDiv.innerHTML = `<p class="text-red-600">請選擇應變數 (Y) 和至少一個自變數 (X)。</p>`;
                return;
            }

            // Check for Y in X and filter it out
            if (xVars.includes(yVar)) {
                xVars = xVars.filter(v => v !== yVar);
                if (xVars.length === 0) {
                    resultsDiv.innerHTML = '<p class="text-red-600">錯誤：目標變數 (Y) 不能同時作為特徵變數 (X)。請選擇其他特徵變數。</p>';
                    return;
                }
                resultsDiv.innerHTML = `<p class="text-orange-600 mb-2">⚠️ 已自動移除 X 中與 Y 重複的變數「${yVar}」</p>`;
            }

            const encoders = {};
            xVars.forEach(header => {
                if (categoricalHeaders.includes(header)) {
                    const uniqueValues = [...new Set(jsonData.map(row => row[header]).filter(v => v != null))];
                    encoders[header] = {};
                    uniqueValues.forEach((val, i) => { encoders[header][val] = i; });
                }
            });

            const X = [], y = [];
            for (const row of jsonData) {
                let isValidRow = true;
                const featureRow = [];
                for (const xVar of xVars) {
                    const val = row[xVar];
                    if (val == null) { isValidRow = false; break; }
                    featureRow.push(categoricalHeaders.includes(xVar) ? encoders[xVar][val] : val);
                }
                const yVal = row[yVar];
                if (yVal == null || typeof yVal !== 'number') isValidRow = false;

                if (isValidRow) {
                    X.push(featureRow);
                    y.push(yVal);
                }
            }

            if (X.length < 5) {
                resultsDiv.innerHTML = `<p class="text-red-600">有效的資料列不足 (${X.length} 筆)，無法建立決策樹模型。</p>`;
                return;
            }

            try {
                const options = { maxDepth: maxDepth, minNumSamples: minSamplesLeaf };
                const regressor = new ML.DecisionTreeRegression(options);
                regressor.train(X, y);

                const modelJSON = regressor.toJSON();
                const importancesArray = calculateDtImportance(modelJSON, xVars.length);
                const importances = importancesArray.map((imp, index) => ({
                    featureIndex: index,
                    importance: imp
                })).sort((a, b) => b.importance - a.importance);

                let html = `<h3 class="text-lg font-semibold mb-2">迴歸決策樹模型結果</h3>
                        <p class="text-sm text-gray-600 mb-4">模型已成功建立。以下為各個自變數對預測結果的貢獻度排序。</p>`;
                html += `<div id="dtImportancePlot"></div>`;
                html += `<h4 class="text-md font-semibold mt-6 mb-2">特徵貢獻度 (Variance Reduction)</h4>
                     <div class="overflow-x-auto"><table class="min-w-full divide-y divide-gray-200">
                     <thead class="bg-gray-50"><tr>
                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">變數</th>
                        <th class="px-4 py-2 text-right text-xs font-medium text-gray-500 uppercase">貢獻度</th>
                     </tr></thead><tbody class="bg-white divide-y divide-gray-200">`;
                importances.forEach(imp => {
                    html += `<tr>
                            <td class="px-4 py-2 text-sm font-medium text-gray-900">${xVars[imp.featureIndex]}</td>
                            <td class="px-4 py-2 text-sm text-right text-gray-500">${imp.importance.toFixed(4)}</td>
                         </tr>`;
                });
                html += `</tbody></table></div>
                     <div class="mt-3 p-3 bg-amber-50 border rounded text-xs">
                        解讀：貢獻度越高，表示該變數在預測數值結果時，提供了越多的資訊，是越重要的因子。
                     </div>`;
                resultsDiv.innerHTML = html;

                const plotLabels = importances.map(imp => xVars[imp.featureIndex]);
                const plotValues = importances.map(imp => imp.importance);
                const plotTrace = {
                    x: plotValues.reverse(),
                    y: plotLabels.reverse(),
                    type: 'bar',
                    orientation: 'h',
                    marker: { color: 'rgb(217, 119, 6)' }
                };
                const plotLayout = {
                    title: '特徵貢獻度排序',
                    xaxis: { title: '貢獻度 (基於變異數減少量)' },
                    margin: { l: 150 }
                };
                Plotly.newPlot('dtImportancePlot', [plotTrace], plotLayout, { responsive: true });

            } catch (err) {
                resultsDiv.innerHTML = `<p class="text-red-600">建立模型時發生錯誤：${err.message}</p>`;
            }
        }

        function runCorrelationMatrix() {
            const resultsDiv = document.getElementById('correlationMatrixResults');
            resultsDiv.innerHTML = '';

            // Get selected variables, or use all numeric headers if none selected
            const varSelect = document.getElementById('correlationVarSelect');
            let selectedVars = [];
            if (varSelect && varSelect.selectedOptions.length > 0) {
                selectedVars = Array.from(varSelect.selectedOptions).map(o => o.value);
            }
            const varsToUse = selectedVars.length >= 2 ? selectedVars : numericHeaders;

            if (varsToUse.length < 2) {
                resultsDiv.innerHTML = `<p class="text-red-600">需要至少兩個數值欄位才能計算相關係數矩陣。</p>`;
                return;
            }

            const correlationMatrix = [];
            const numVars = varsToUse.length;

            for (let i = 0; i < numVars; i++) {
                correlationMatrix[i] = [];
                for (let j = 0; j < numVars; j++) {
                    if (i === j) {
                        correlationMatrix[i][j] = 1;
                        continue;
                    }
                    if (j < i) { // Matrix is symmetric, copy value
                        correlationMatrix[i][j] = correlationMatrix[j][i];
                        continue;
                    }

                    // Pairwise deletion for correlation calculation
                    const pairs = [];
                    for (let k = 0; k < jsonData.length; k++) {
                        const val1 = jsonData[k][varsToUse[i]];
                        const val2 = jsonData[k][varsToUse[j]];
                        if (typeof val1 === 'number' && !isNaN(val1) && typeof val2 === 'number' && !isNaN(val2)) {
                            pairs.push([val1, val2]);
                        }
                    }

                    if (pairs.length < 2) {
                        correlationMatrix[i][j] = NaN; // Not enough data
                        continue;
                    }

                    const seriesX = pairs.map(p => p[0]);
                    const seriesY = pairs.map(p => p[1]);

                    const corr = ss.sampleCorrelation(seriesX, seriesY);
                    correlationMatrix[i][j] = isNaN(corr) ? 0 : corr; // Handle potential NaN from ss
                }
            }

            const plotDiv = document.createElement('div');
            plotDiv.id = 'correlationHeatmap';
            resultsDiv.appendChild(plotDiv);

            const data = [{
                z: correlationMatrix,
                x: varsToUse,
                y: varsToUse,
                type: 'heatmap',
                colorscale: 'RdBu',
                zmin: -1,
                zmax: 1,
                hoverongaps: false
            }];

            const layout = {
                title: '數值變數相關係數矩陣',
                xaxis: { ticks: '', side: 'top', automargin: true },
                yaxis: { ticks: '', automargin: true },
                annotations: correlationMatrix.map((row, i) =>
                    row.map((val, j) => ({
                        x: varsToUse[j],
                        y: varsToUse[i],
                        text: isNaN(val) ? 'N/A' : val.toFixed(2),
                        showarrow: false,
                        font: {
                            color: Math.abs(val) > 0.5 ? 'white' : 'black',
                            size: 10
                        }
                    }))
                ).flat()
            };

            Plotly.newPlot(plotDiv, data, layout, { responsive: true });
        }

        function runScatterPlotMatrix() {
            const resultsDiv = document.getElementById('scatterPlotResults');
            resultsDiv.innerHTML = '';

            // Get selected variables, or use all numeric headers if none selected
            const varSelect = document.getElementById('correlationVarSelect');
            let selectedVars = [];
            if (varSelect && varSelect.selectedOptions.length > 0) {
                selectedVars = Array.from(varSelect.selectedOptions).map(o => o.value);
            }
            const varsToUse = selectedVars.length >= 2 ? selectedVars : numericHeaders;

            if (varsToUse.length < 2) {
                resultsDiv.innerHTML = `<p class="text-red-600">需要至少兩個數值欄位才能產生散佈圖。</p>`;
                return;
            }

            // Limit to first 10 variables to avoid overwhelming the display
            const limitedVars = varsToUse.slice(0, 10);
            if (varsToUse.length > 10) {
                resultsDiv.innerHTML = `<p class="text-yellow-600 mb-4">⚠️ 為確保圖表清晰，僅顯示前 10 個變數的散佈圖。</p>`;
            }

            const numVars = limitedVars.length;
            const plotsContainer = document.createElement('div');
            plotsContainer.className = 'grid gap-4';
            
            // Determine grid columns based on number of pairs
            const numPairs = (numVars * (numVars - 1)) / 2;
            if (numPairs <= 3) {
                plotsContainer.className += ' grid-cols-1 md:grid-cols-3';
            } else if (numPairs <= 6) {
                plotsContainer.className += ' grid-cols-1 md:grid-cols-2 lg:grid-cols-3';
            } else {
                plotsContainer.className += ' grid-cols-1 md:grid-cols-2 lg:grid-cols-3';
            }
            
            resultsDiv.appendChild(plotsContainer);

            // Generate scatter plots for each pair
            let plotIndex = 0;
            for (let i = 0; i < numVars; i++) {
                for (let j = i + 1; j < numVars; j++) {
                    const varX = limitedVars[i];
                    const varY = limitedVars[j];
                    
                    // Extract valid pairs
                    const xData = [];
                    const yData = [];
                    for (let k = 0; k < jsonData.length; k++) {
                        const valX = jsonData[k][varX];
                        const valY = jsonData[k][varY];
                        if (typeof valX === 'number' && !isNaN(valX) && typeof valY === 'number' && !isNaN(valY)) {
                            xData.push(valX);
                            yData.push(valY);
                        }
                    }

                    if (xData.length < 2) continue;

                    // Calculate correlation
                    const corr = ss.sampleCorrelation(xData, yData);
                    const corrDisplay = isNaN(corr) ? 'N/A' : corr.toFixed(3);

                    // Calculate linear regression for trend line
                    const regression = ss.linearRegression(xData.map((x, idx) => [x, yData[idx]]));
                    const regressionLine = ss.linearRegressionLine(regression);
                    const xMin = Math.min(...xData);
                    const xMax = Math.max(...xData);
                    const trendX = [xMin, xMax];
                    const trendY = [regressionLine(xMin), regressionLine(xMax)];

                    // Determine color based on correlation strength
                    let pointColor = '#3b82f6'; // blue default
                    if (Math.abs(corr) >= 0.7) {
                        pointColor = corr > 0 ? '#ef4444' : '#3b82f6'; // red for strong positive, blue for strong negative
                    } else if (Math.abs(corr) >= 0.4) {
                        pointColor = corr > 0 ? '#f97316' : '#8b5cf6'; // orange for moderate positive, purple for moderate negative
                    } else {
                        pointColor = '#6b7280'; // gray for weak
                    }

                    // Create plot container
                    const plotWrapper = document.createElement('div');
                    plotWrapper.className = 'bg-white border rounded-lg p-3';
                    
                    const plotDiv = document.createElement('div');
                    plotDiv.id = `scatterPlot_${plotIndex}`;
                    plotDiv.style.height = '280px';
                    plotWrapper.appendChild(plotDiv);
                    plotsContainer.appendChild(plotWrapper);

                    // Scatter trace
                    const scatterTrace = {
                        x: xData,
                        y: yData,
                        mode: 'markers',
                        type: 'scatter',
                        name: '資料點',
                        marker: {
                            color: pointColor,
                            size: 6,
                            opacity: 0.7
                        },
                        hovertemplate: `${varX}: %{x}<br>${varY}: %{y}<extra></extra>`
                    };

                    // Trend line trace
                    const trendTrace = {
                        x: trendX,
                        y: trendY,
                        mode: 'lines',
                        type: 'scatter',
                        name: '趨勢線',
                        line: {
                            color: '#10b981',
                            width: 2,
                            dash: 'dash'
                        }
                    };

                    const layout = {
                        title: {
                            text: `${varX} vs ${varY}<br><span style="font-size:12px;color:#666">r = ${corrDisplay}</span>`,
                            font: { size: 13 }
                        },
                        xaxis: {
                            title: { text: varX, font: { size: 10 } },
                            tickfont: { size: 9 },
                            gridcolor: '#e5e7eb'
                        },
                        yaxis: {
                            title: { text: varY, font: { size: 10 } },
                            tickfont: { size: 9 },
                            gridcolor: '#e5e7eb'
                        },
                        showlegend: false,
                        margin: { t: 50, b: 50, l: 60, r: 20 },
                        plot_bgcolor: '#fafafa',
                        paper_bgcolor: '#ffffff',
                        hovermode: 'closest'
                    };

                    Plotly.newPlot(plotDiv, [scatterTrace, trendTrace], layout, { 
                        responsive: true,
                        displayModeBar: false
                    });

                    plotIndex++;
                }
            }

            // Add summary section
            const summaryHtml = `
                <div class="mt-6 bg-gray-50 p-4 rounded-lg">
                    <h4 class="font-semibold mb-2">📊 散佈圖說明</h4>
                    <div class="text-sm text-gray-600 space-y-1">
                        <p>• <span class="text-red-500 font-medium">紅色</span>：強正相關 (r ≥ 0.7)</p>
                        <p>• <span class="text-orange-500 font-medium">橘色</span>：中等正相關 (0.4 ≤ r < 0.7)</p>
                        <p>• <span class="text-blue-500 font-medium">藍色</span>：強負相關 (r ≤ -0.7)</p>
                        <p>• <span class="text-purple-500 font-medium">紫色</span>：中等負相關 (-0.7 < r ≤ -0.4)</p>
                        <p>• <span class="text-gray-500 font-medium">灰色</span>：弱相關 (|r| < 0.4)</p>
                        <p>• <span class="text-green-500 font-medium">綠色虛線</span>：線性趨勢線</p>
                    </div>
                </div>
            `;
            resultsDiv.insertAdjacentHTML('beforeend', summaryHtml);
        }

        // --- Matrix Helper Functions ---
        function solveLinearSystem(A, b) {
            // 使用高斯消去法求解 Ax = b
            const n = A.length;
            const augmented = A.map((row, i) => [...row, b[i]]);

            // 前向消去
            for (let i = 0; i < n; i++) {
                // 找到主元素
                let maxRow = i;
                for (let k = i + 1; k < n; k++) {
                    if (Math.abs(augmented[k][i]) > Math.abs(augmented[maxRow][i])) {
                        maxRow = k;
                    }
                }

                // 交換行
                [augmented[i], augmented[maxRow]] = [augmented[maxRow], augmented[i]];

                // 檢查是否為零
                if (Math.abs(augmented[i][i]) < 1e-10) {
                    throw new Error('矩陣奇異或接近奇異');
                }

                // 消去
                for (let k = i + 1; k < n; k++) {
                    const factor = augmented[k][i] / augmented[i][i];
                    for (let j = i; j <= n; j++) {
                        augmented[k][j] -= factor * augmented[i][j];
                    }
                }
            }

            // 回代
            const x = new Array(n);
            for (let i = n - 1; i >= 0; i--) {
                x[i] = augmented[i][n];
                for (let j = i + 1; j < n; j++) {
                    x[i] -= augmented[i][j] * x[j];
                }
                x[i] /= augmented[i][i];
            }

            return x;
        }

        function invertMatrix(A) {
            // 使用高斯-約當消去法求矩陣逆
            const n = A.length;
            const augmented = A.map((row, i) => {
                const identityRow = new Array(n).fill(0);
                identityRow[i] = 1;
                return [...row, ...identityRow];
            });

            // 前向消去
            for (let i = 0; i < n; i++) {
                // 找到主元素
                let maxRow = i;
                for (let k = i + 1; k < n; k++) {
                    if (Math.abs(augmented[k][i]) > Math.abs(augmented[maxRow][i])) {
                        maxRow = k;
                    }
                }

                [augmented[i], augmented[maxRow]] = [augmented[maxRow], augmented[i]];

                if (Math.abs(augmented[i][i]) < 1e-10) {
                    throw new Error('矩陣不可逆');
                }

                // 正規化當前行
                const pivot = augmented[i][i];
                for (let j = 0; j < 2 * n; j++) {
                    augmented[i][j] /= pivot;
                }

                // 消去其他行
                for (let k = 0; k < n; k++) {
                    if (k !== i) {
                        const factor = augmented[k][i];
                        for (let j = 0; j < 2 * n; j++) {
                            augmented[k][j] -= factor * augmented[i][j];
                        }
                    }
                }
            }

            // 提取逆矩陣
            const inverse = augmented.map(row => row.slice(n));
            return inverse;
        }

        // --- Eigenvalue Decomposition Functions ---
        function eigenDecomposition(A, maxIterations = 100) {
            // 使用 Power Iteration + Deflation 求特徵值和特徵向量
            const n = A.length;
            const eigenvalues = [];
            const eigenvectors = [];

            let A_deflated = A.map(row => [...row]);

            for (let k = 0; k < n; k++) {
                // Power Iteration
                let v = new Array(n).fill(1).map(() => Math.random());
                let lambda = 0;

                for (let iter = 0; iter < maxIterations; iter++) {
                    // v_new = A * v
                    const v_new = new Array(n);
                    for (let i = 0; i < n; i++) {
                        v_new[i] = 0;
                        for (let j = 0; j < n; j++) {
                            v_new[i] += A_deflated[i][j] * v[j];
                        }
                    }

                    // 正規化
                    let norm = Math.sqrt(v_new.reduce((sum, val) => sum + val * val, 0));
                    if (norm < 1e-10) break;

                    for (let i = 0; i < n; i++) {
                        v_new[i] /= norm;
                    }

                    // 計算特徵值
                    lambda = 0;
                    for (let i = 0; i < n; i++) {
                        for (let j = 0; j < n; j++) {
                            lambda += v_new[i] * A_deflated[i][j] * v_new[j];
                        }
                    }

                    // 檢查收斂
                    let diff = 0;
                    for (let i = 0; i < n; i++) {
                        diff += Math.abs(v_new[i] - v[i]);
                    }

                    v = v_new;

                    if (diff < 1e-6) break;
                }

                eigenvalues.push(lambda);
                eigenvectors.push(v);

                // Deflation: A = A - λ * v * v'
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        A_deflated[i][j] -= lambda * v[i] * v[j];
                    }
                }
            }

            return { eigenvalues, eigenvectors };
        }

        function correlationMatrix(data) {
            // 計算相關矩陣
            const n = data.length;
            const p = data[0].length;

            // 標準化數據
            const means = [];
            const stds = [];
            for (let j = 0; j < p; j++) {
                const col = data.map(row => row[j]);
                means[j] = ss.mean(col);
                stds[j] = ss.standardDeviation(col);
            }

            const standardized = data.map(row =>
                row.map((val, j) => (val - means[j]) / (stds[j] || 1))
            );

            // 計算相關矩陣
            const corr = [];
            for (let i = 0; i < p; i++) {
                corr[i] = [];
                for (let j = 0; j < p; j++) {
                    let sum = 0;
                    for (let k = 0; k < n; k++) {
                        sum += standardized[k][i] * standardized[k][j];
                    }
                    corr[i][j] = sum / (n - 1);
                }
            }

            return corr;
        }

        function varimax(loadings, maxIterations = 100) {
            // Varimax 旋轉
            const p = loadings.length;
            const k = loadings[0].length;

            if (k === 1) return loadings; // 單一因子不需旋轉

            let rotated = loadings.map(row => [...row]);

            for (let iter = 0; iter < maxIterations; iter++) {
                let changed = false;

                // 對每對因子進行旋轉
                for (let i = 0; i < k - 1; i++) {
                    for (let j = i + 1; j < k; j++) {
                        // 計算旋轉角度
                        let a = 0, b = 0, c = 0, d = 0;

                        for (let m = 0; m < p; m++) {
                            const x = rotated[m][i];
                            const y = rotated[m][j];
                            const u = x * x - y * y;
                            const v = 2 * x * y;
                            a += u;
                            b += v;
                            c += x * x + y * y;
                            d += u * u - v * v;
                        }

                        const num = 2 * p * b - 2 * a * c / p;
                        const den = p * d - (a * a - b * b);

                        if (Math.abs(den) < 1e-10) continue;

                        const tanAngle = num / den;
                        const angle = Math.atan(tanAngle) / 4;

                        if (Math.abs(angle) < 1e-6) continue;

                        changed = true;

                        // 應用旋轉
                        const cos = Math.cos(angle);
                        const sin = Math.sin(angle);

                        for (let m = 0; m < p; m++) {
                            const xi = rotated[m][i];
                            const xj = rotated[m][j];
                            rotated[m][i] = xi * cos - xj * sin;
                            rotated[m][j] = xi * sin + xj * cos;
                        }
                    }
                }

                if (!changed) break;
            }

            return rotated;
        }

        // --- Statistical Helper Functions ---
        function calculateSkewness(values) {
            // 計算偏態係數 (Skewness)
            const n = values.length;
            const mean = ss.mean(values);
            const std = ss.standardDeviation(values);
            if (std === 0) return 0;
            const sum = values.reduce((acc, val) => acc + Math.pow((val - mean) / std, 3), 0);
            return (n / ((n - 1) * (n - 2))) * sum;
        }

        function calculateKurtosis(values) {
            // 計算峨態係數 (Kurtosis) - Excess Kurtosis
            const n = values.length;
            const mean = ss.mean(values);
            const std = ss.standardDeviation(values);
            if (std === 0) return 0;
            const sum4 = values.reduce((acc, val) => acc + Math.pow((val - mean) / std, 4), 0);
            const kurtosis = (n * (n + 1) * sum4) / ((n - 1) * (n - 2) * (n - 3)) - (3 * Math.pow(n - 1, 2)) / ((n - 2) * (n - 3));
            return kurtosis;
        }

        // --- Regression Type Switching ---
        function switchRegressionType(type) {
            const simplePanel = document.getElementById('simpleRegressionPanel');
            const multiplePanel = document.getElementById('multipleRegressionPanel');
            const simpleTab = document.getElementById('simpleRegTab');
            const multipleTab = document.getElementById('multipleRegTab');

            if (type === 'simple') {
                simplePanel.style.display = 'block';
                multiplePanel.style.display = 'none';
                simpleTab.className = 'px-4 py-2 font-semibold border-b-2 border-purple-500 text-purple-600';
                multipleTab.className = 'px-4 py-2 font-semibold text-gray-500 hover:text-purple-600';
            } else {
                simplePanel.style.display = 'none';
                multiplePanel.style.display = 'block';
                simpleTab.className = 'px-4 py-2 font-semibold text-gray-500 hover:text-purple-600';
                multipleTab.className = 'px-4 py-2 font-semibold border-b-2 border-purple-500 text-purple-600';
            }
        }

        // --- Multiple Regression ---
        function runMultipleRegression() {
            const xSelects = document.getElementById('multipleRegressionX');
            const yVar = document.getElementById('multipleRegressionY').value;
            const resultsDiv = document.getElementById('regressionResults');
            resultsDiv.innerHTML = '';

            const xVars = Array.from(xSelects.selectedOptions).map(opt => opt.value);

            if (xVars.length === 0 || !yVar) {
                resultsDiv.innerHTML = `<p class="text-red-600">請選擇至少一個自變數 (X) 與一個應變數 (Y)。</p>`;
                return;
            }

            if (xVars.includes(yVar)) {
                resultsDiv.innerHTML = `<p class="text-red-600">自變數與應變數不能重複。</p>`;
                return;
            }

            // 準備數據
            const rows = jsonData.filter(row => {
                return xVars.every(xVar => typeof row[xVar] === 'number') && typeof row[yVar] === 'number';
            });

            if (rows.length < xVars.length + 2) {
                resultsDiv.innerHTML = `<p class="text-red-600">沒有足夠的完整數據進行多元迴歸分析。需要至少 ${xVars.length + 2} 筆。</p>`;
                return;
            }

            const n = rows.length;
            const k = xVars.length;

            // X 矩陣 (加上截距項)
            const X = rows.map(row => [1, ...xVars.map(xVar => row[xVar])]);
            const Y = rows.map(row => row[yVar]);

            // 手動矩陣運算
            // 計算 X'X
            const p = k + 1; // 包含截距
            const XtX = [];
            for (let i = 0; i < p; i++) {
                XtX[i] = [];
                for (let j = 0; j < p; j++) {
                    let sum = 0;
                    for (let r = 0; r < n; r++) {
                        sum += X[r][i] * X[r][j];
                    }
                    XtX[i][j] = sum;
                }
            }

            // 計算 X'Y
            const XtY = [];
            for (let i = 0; i < p; i++) {
                let sum = 0;
                for (let r = 0; r < n; r++) {
                    sum += X[r][i] * Y[r];
                }
                XtY[i] = sum;
            }

            // 使用高斯消去法求解 (X'X)β = X'Y
            let coefficients;
            try {
                coefficients = solveLinearSystem(XtX, XtY);
            } catch (e) {
                resultsDiv.innerHTML = `<p class="text-red-600">無法計算迴歸係數，可能是自變數之間存在完全共線性。錯誤：${e.message}</p>`;
                return;
            }

            // 預測值和殘差
            const predictions = X.map(row => row.reduce((sum, val, i) => sum + val * coefficients[i], 0));
            const residuals = Y.map((y, i) => y - predictions[i]);

            // SST, SSE, SSR
            const yMean = ss.mean(Y);
            const SST = Y.reduce((sum, y) => sum + Math.pow(y - yMean, 2), 0);
            const SSE = residuals.reduce((sum, r) => sum + r * r, 0);
            const SSR = SST - SSE;

            // R² 和調整後 R²
            const rSquared = SSR / SST;
            const adjRSquared = 1 - (SSE / (n - k - 1)) / (SST / (n - 1));

            // F 統計量
            const MSR = SSR / k;
            const MSE = SSE / (n - k - 1);
            const fStat = MSR / MSE;
            const pValueF = 1 - jStat.centralF.cdf(fStat, k, n - k - 1);

            // 係數的標準誤和 t 統計量
            const syx = Math.sqrt(MSE);

            // 計算 (X'X)^(-1)
            let XtX_inv;
            try {
                XtX_inv = invertMatrix(XtX);
            } catch (e) {
                resultsDiv.innerHTML = `<p class="text-red-600">無法計算標準誤，矩陣不可逆。</p>`;
                return;
            }

            // 計算標準誤
            const seCoeffs = [];
            for (let i = 0; i < p; i++) {
                seCoeffs[i] = Math.sqrt(XtX_inv[i][i] * MSE);
            }

            const tStats = coefficients.map((coef, i) => coef / seCoeffs[i]);
            const pValues = tStats.map(t => 2 * (1 - jStat.studentt.cdf(Math.abs(t), n - k - 1)));

            // 95% 信賴區間
            const tCritical = jStat.studentt.inv(0.975, n - k - 1);
            const CIs = coefficients.map((coef, i) => [coef - tCritical * seCoeffs[i], coef + tCritical * seCoeffs[i]]);

            // 輸出結果
            let resultHtml = `<h3 class="text-lg font-semibold mb-2">📊 多元線性迴歸結果</h3>`;

            // 模型摘要
            resultHtml += `<div class="overflow-x-auto mb-4"><table class="min-w-full bg-white border"><tbody class="divide-y divide-gray-200"><tr><td class="px-6 py-3 font-medium text-gray-900">應變數 (Y)</td><td class="px-6 py-3 text-gray-700">${yVar}</td></tr><tr><td class="px-6 py-3 font-medium text-gray-900">自變數 (X)</td><td class="px-6 py-3 text-gray-700">${xVars.join(', ')}</td></tr><tr><td class="px-6 py-3 font-medium text-gray-900">樣本數</td><td class="px-6 py-3 text-gray-700">${n}</td></tr><tr><td class="px-6 py-3 font-medium text-gray-900">R²</td><td class="px-6 py-3 text-gray-700 font-mono text-lg">${rSquared.toFixed(4)}</td></tr><tr><td class="px-6 py-3 font-medium text-gray-900">調整後 R²</td><td class="px-6 py-3 text-gray-700 font-mono text-lg">${adjRSquared.toFixed(4)}</td></tr><tr><td class="px-6 py-3 font-medium text-gray-900">標準誤 (S)</td><td class="px-6 py-3 text-gray-700 font-mono">${syx.toFixed(4)}</td></tr></tbody></table></div>`;

            // ANOVA 表
            resultHtml += `<h4 class="text-md font-semibold mb-2">ANOVA 表:</h4><div class="overflow-x-auto mb-4"><table class="min-w-full bg-white border"><thead class="bg-gray-50"><tr><th class="px-4 py-2 border">來源</th><th class="px-4 py-2 border">SS</th><th class="px-4 py-2 border">df</th><th class="px-4 py-2 border">MS</th><th class="px-4 py-2 border">F</th><th class="px-4 py-2 border">p-value</th></tr></thead><tbody><tr><td class="px-4 py-2 border font-medium">迴歸 Regression</td><td class="px-4 py-2 border">${SSR.toFixed(3)}</td><td class="px-4 py-2 border">${k}</td><td class="px-4 py-2 border">${MSR.toFixed(3)}</td><td class="px-4 py-2 border font-mono text-lg">${fStat.toFixed(4)}</td><td class="px-4 py-2 border font-mono text-lg">${pValueF.toFixed(4)}</td></tr><tr><td class="px-4 py-2 border font-medium">殘差 Residual</td><td class="px-4 py-2 border">${SSE.toFixed(3)}</td><td class="px-4 py-2 border">${n - k - 1}</td><td class="px-4 py-2 border">${MSE.toFixed(3)}</td><td class="px-4 py-2 border">-</td><td class="px-4 py-2 border">-</td></tr><tr><td class="px-4 py-2 border font-medium">總變異 Total</td><td class="px-4 py-2 border">${SST.toFixed(3)}</td><td class="px-4 py-2 border">${n - 1}</td><td class="px-4 py-2 border">-</td><td class="px-4 py-2 border">-</td><td class="px-4 py-2 border">-</td></tr></tbody></table></div>`;

            // 係數表
            resultHtml += `<h4 class="text-md font-semibold mb-2">係數表:</h4><div class="overflow-x-auto mb-4"><table class="min-w-full bg-white border"><thead class="bg-gray-50"><tr><th class="px-4 py-2 border">變數</th><th class="px-4 py-2 border">係數</th><th class="px-4 py-2 border">標準誤</th><th class="px-4 py-2 border">t 統計量</th><th class="px-4 py-2 border">p-value</th><th class="px-4 py-2 border">95% CI 下限</th><th class="px-4 py-2 border">95% CI 上限</th></tr></thead><tbody>`;
            resultHtml += `<tr><td class="px-4 py-2 border font-medium">截距 (Intercept)</td><td class="px-4 py-2 border font-mono">${coefficients[0].toFixed(4)}</td><td class="px-4 py-2 border">${seCoeffs[0].toFixed(4)}</td><td class="px-4 py-2 border">${tStats[0].toFixed(3)}</td><td class="px-4 py-2 border font-mono">${pValues[0].toFixed(4)}</td><td class="px-4 py-2 border">${CIs[0][0].toFixed(4)}</td><td class="px-4 py-2 border">${CIs[0][1].toFixed(4)}</td></tr>`;
            xVars.forEach((xVar, i) => {
                const idx = i + 1;
                resultHtml += `<tr><td class="px-4 py-2 border font-medium">${xVar}</td><td class="px-4 py-2 border font-mono">${coefficients[idx].toFixed(4)}</td><td class="px-4 py-2 border">${seCoeffs[idx].toFixed(4)}</td><td class="px-4 py-2 border">${tStats[idx].toFixed(3)}</td><td class="px-4 py-2 border font-mono">${pValues[idx].toFixed(4)}</td><td class="px-4 py-2 border">${CIs[idx][0].toFixed(4)}</td><td class="px-4 py-2 border">${CIs[idx][1].toFixed(4)}</td></tr>`;
            });
            resultHtml += `</tbody></table></div>`;

            // 結果判讀
            resultHtml += `<div class="mt-4 p-4 bg-purple-50 border-l-4 border-purple-500 rounded-r-lg"><h4 class="font-bold">結果判讀:</h4><ul class="text-gray-700 mt-1 space-y-1 list-disc list-inside"><li>調整後 R² = ${adjRSquared.toFixed(4)}，<strong>${(adjRSquared * 100).toFixed(1)}%</strong> 的 Y 變異可由 X 變數解釋。</li><li>模型整體顯著性：F(${k}, ${n - k - 1}) = ${fStat.toFixed(2)}, p = ${pValueF.toFixed(4)} ${pValueF < 0.05 ? '< 0.05 (<strong>顯著</strong>)' : '≥ 0.05 (不顯著)'}。</li></ul></div>`;

            resultsDiv.innerHTML = resultHtml;

            // 顯示預測區塊 (移至結果下方)
            const predictHtml = `
                <div id="multipleRegressionPredictSection" class="mt-8 border-t pt-6">
                    <h4 class="text-lg font-bold mb-4 flex items-center gap-2">
                        <svg class="w-5 h-5 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
                        多元迴歸預測
                    </h4>
                    <div class="bg-gray-50 p-4 rounded-lg border border-gray-200">
                        <div id="predictionInputs" class="grid md:grid-cols-3 gap-4 mb-4">
                            ${xVars.map((xVar, idx) => `
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-1">${xVar}</label>
                                    <input type="number" id="pred_mr_${idx}" step="any" class="w-full rounded-md border-gray-300 shadow-sm focus:border-purple-500 focus:ring-purple-500" placeholder="輸入數值">
                                </div>
                            `).join('')}
                        </div>
                        <button onclick="predictMultipleRegression()" class="bg-purple-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-purple-700 shadow-md transition-colors flex items-center gap-2">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 7h6m0 10v-3m-3 3h.01M9 17h.01M9 14h.01M12 14h.01M15 11h.01M12 11h.01M9 11h.01M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z"></path></svg>
                            計算預測值
                        </button>
                        <div id="predictionResult" class="mt-4 hidden"></div>
                    </div>
                </div>
            `;
            resultsDiv.insertAdjacentHTML('beforeend', predictHtml);

            // 儲存係數供預測使用
            window.multipleRegressionCoeffs = coefficients;
            window.multipleRegressionXVars = xVars;
            window.multipleRegressionYVar = yVar;
        }

        function predictMultipleRegression() {
            const xVars = window.multipleRegressionXVars;
            const coeffs = window.multipleRegressionCoeffs;
            const yVar = window.multipleRegressionYVar;

            if (!xVars || !coeffs) {
                alert('請先執行多元迴歸分析');
                return;
            }

            // 讀取輸入值
            const inputValues = [1]; // 截距項
            let hasError = false;
            xVars.forEach((xVar, idx) => {
                const val = parseFloat(document.getElementById(`pred_mr_${idx}`).value);
                if (isNaN(val)) {
                    hasError = true;
                } else {
                    inputValues.push(val);
                }
            });

            if (hasError) {
                document.getElementById('predictionResult').innerHTML = '<p class="text-red-600">請輸入所有自變數的有效數值。</p>';
                return;
            }

            // 計算預測值
            const prediction = inputValues.reduce((sum, val, i) => sum + val * coeffs[i], 0);

            const resultDiv = document.getElementById('predictionResult');
            resultDiv.innerHTML = `
                <div class="p-4 bg-white border border-purple-200 rounded-lg shadow-sm">
                    <div class="flex items-center justify-between">
                        <div>
                            <p class="text-gray-600 text-sm">根據輸入的自變數</p>
                            <p class="text-lg font-bold text-gray-800 mt-1">預測 ${yVar}</p>
                        </div>
                        <div class="text-2xl font-bold text-purple-600">
                            ${prediction.toFixed(4)}
                        </div>
                    </div>
                </div>
            `;
            resultDiv.classList.remove('hidden');
        }

        // --- PCA (Principal Component Analysis) ---
        function runPCA() {
            const selectEl = document.getElementById('pcaVariables');
            const resultsDiv = document.getElementById('pcaResults');
            resultsDiv.innerHTML = '';

            const selectedVars = Array.from(selectEl.selectedOptions).map(opt => opt.value);

            if (selectedVars.length < 2) {
                resultsDiv.innerHTML = '<p class="text-red-600">請選擇至少2個變數。</p>';
                return;
            }

            // 準備數據
            const data = jsonData.filter(row =>
                selectedVars.every(v => typeof row[v] === 'number')
            ).map(row => selectedVars.map(v => row[v]));

            if (data.length < selectedVars.length + 1) {
                resultsDiv.innerHTML = '<p class="text-red-600">數據不足，需要至少 ' + (selectedVars.length + 1) + ' 筆完整數據。</p>';
                return;
            }

            const n = data.length;
            const p = selectedVars.length;
            const standardize = document.getElementById('pcaStandardize').checked;

            // 計算相關矩陣或共變異數矩陣
            let corrMatrix;
            if (standardize) {
                corrMatrix = correlationMatrix(data);
            } else {
                // 共變異數矩陣
                const means = [];
                for (let j = 0; j < p; j++) {
                    means[j] = ss.mean(data.map(row => row[j]));
                }

                corrMatrix = [];
                for (let i = 0; i < p; i++) {
                    corrMatrix[i] = [];
                    for (let j = 0; j < p; j++) {
                        let sum = 0;
                        for (let k = 0; k < n; k++) {
                            sum += (data[k][i] - means[i]) * (data[k][j] - means[j]);
                        }
                        corrMatrix[i][j] = sum / (n - 1);
                    }
                }
            }

            // 特徵值分解
            const eigen = eigenDecomposition(corrMatrix);

            // 排序（降序）
            const indices = eigen.eigenvalues.map((val, idx) => idx)
                .sort((a, b) => eigen.eigenvalues[b] - eigen.eigenvalues[a]);

            const sortedEigenvalues = indices.map(i => eigen.eigenvalues[i]);
            const sortedEigenvectors = indices.map(i => eigen.eigenvectors[i]);

            // 決定主成分數量
            const numComponentsInput = document.getElementById('pcaNumComponents').value;
            let numComponents = numComponentsInput ? parseInt(numComponentsInput) : 0;

            if (numComponents === 0) {
                // Kaiser 準則：特徵值 > 1
                numComponents = sortedEigenvalues.filter(v => v > 1).length;
                if (numComponents === 0) numComponents = 1;
            }

            numComponents = Math.min(numComponents, p);

            // 計算解釋變異比例
            const totalVariance = sortedEigenvalues.reduce((sum, v) => sum + v, 0);
            const explainedVariance = sortedEigenvalues.slice(0, numComponents)
                .map(v => (v / totalVariance) * 100);
            const cumulativeVariance = [];
            let cumSum = 0;
            for (let i = 0; i < numComponents; i++) {
                cumSum += explainedVariance[i];
                cumulativeVariance.push(cumSum);
            }

            // 載荷矩陣
            const loadings = [];
            for (let i = 0; i < p; i++) {
                loadings[i] = [];
                for (let j = 0; j < numComponents; j++) {
                    loadings[i][j] = sortedEigenvectors[j][i] * Math.sqrt(sortedEigenvalues[j]);
                }
            }

            // 輸出結果
            let html = '<h3 class="text-lg font-semibold mb-2">📊 主成分分析結果</h3>';

            // 摘要
            html += '<div class="bg-indigo-50 p-4 rounded mb-4"><h4 class="font-semibold mb-2">分析摘要</h4><ul class="text-sm space-y-1"><li>變數數量：' + p + '</li><li>樣本數：' + n + '</li><li>提取主成分數：' + numComponents + '</li><li>累積解釋變異：<strong>' + cumulativeVariance[numComponents - 1].toFixed(2) + '%</strong></li></ul></div>';

            // 特徵值表
            html += '<h4 class="text-md font-semibold mb-2">主成分特徵值與解釋變異:</h4><div class="overflow-x-auto mb-4"><table class="min-w-full bg-white border"><thead class="bg-gray-50"><tr><th class="px-4 py-2 border">主成分</th><th class="px-4 py-2 border">特徵值</th><th class="px-4 py-2 border">解釋變異 %</th><th class="px-4 py-2 border">累積 %</th></tr></thead><tbody>';
            for (let i = 0; i < numComponents; i++) {
                html += '<tr><td class="px-4 py-2 border font-medium">PC' + (i + 1) + '</td><td class="px-4 py-2 border">' + sortedEigenvalues[i].toFixed(3) + '</td><td class="px-4 py-2 border">' + explainedVariance[i].toFixed(2) + '%</td><td class="px-4 py-2 border font-semibold">' + cumulativeVariance[i].toFixed(2) + '%</td></tr>';
            }
            html += '</tbody></table></div>';

            // 載荷矩陣
            html += '<h4 class="text-md font-semibold mb-2">主成分載荷矩陣:</h4><div class="overflow-x-auto mb-4"><table class="min-w-full bg-white border"><thead class="bg-gray-50"><tr><th class="px-4 py-2 border">變數</th>';
            for (let i = 0; i < numComponents; i++) {
                html += '<th class="px-4 py-2 border">PC' + (i + 1) + '</th>';
            }
            html += '</tr></thead><tbody>';
            for (let i = 0; i < p; i++) {
                html += '<tr><td class="px-4 py-2 border font-medium">' + selectedVars[i] + '</td>';
                for (let j = 0; j < numComponents; j++) {
                    const val = loadings[i][j];
                    const color = Math.abs(val) > 0.5 ? 'font-bold text-indigo-700' : '';
                    html += '<td class="px-4 py-2 border ' + color + '">' + val.toFixed(3) + '</td>';
                }
                html += '</tr>';
            }
            html += '</tbody></table></div>';

            // 判讀說明
            html += '<div class="bg-blue-50 p-4 rounded border-l-4 border-blue-500"><h4 class="font-bold">結果判讀:</h4><ul class="text-sm mt-2 space-y-1 list-disc list-inside"><li>提取的 ' + numComponents + ' 個主成分解釋了 <strong>' + cumulativeVariance[numComponents - 1].toFixed(1) + '%</strong> 的總變異。</li><li>載荷值絕對值 > 0.5 表示該變數在該主成分上有重要貢獻。</li><li>使用主成分可減少變數數量，同時保留大部分資訊。</li></ul></div>';

            resultsDiv.innerHTML = html;

            // 磎石圖
            const screePlotDiv = document.createElement('div');
            screePlotDiv.id = 'screePlot';
            screePlotDiv.className = 'mt-6';
            resultsDiv.appendChild(screePlotDiv);

            const pcLabels = sortedEigenvalues.map((_, i) => 'PC' + (i + 1));
            const trace = {
                x: pcLabels,
                y: sortedEigenvalues,
                type: 'scatter',
                mode: 'lines+markers',
                name: '特徵值',
                line: { color: 'rgb(99, 102, 241)', width: 2 },
                marker: { size: 8, color: 'rgb(99, 102, 241)' }
            };

            const kaiser = {
                x: [pcLabels[0], pcLabels[pcLabels.length - 1]],
                y: [1, 1],
                type: 'scatter',
                mode: 'lines',
                name: 'Kaiser 準則 (λ=1)',
                line: { color: 'red', dash: 'dash' }
            };

            Plotly.newPlot('screePlot', [trace, kaiser], {
                title: '磎石圖 (Scree Plot)',
                xaxis: { title: '主成分' },
                yaxis: { title: '特徵值' },
                showlegend: true
            }, { responsive: true });
        }

        // --- Factor Analysis ---
        function runFactorAnalysis() {
            const selectEl = document.getElementById('faVariables');
            const resultsDiv = document.getElementById('faResults');
            resultsDiv.innerHTML = '';

            const selectedVars = Array.from(selectEl.selectedOptions).map(opt => opt.value);

            if (selectedVars.length < 3) {
                resultsDiv.innerHTML = '<p class="text-red-600">請選擇至少3個變數。</p>';
                return;
            }

            // 準備數據
            const data = jsonData.filter(row =>
                selectedVars.every(v => typeof row[v] === 'number')
            ).map(row => selectedVars.map(v => row[v]));

            if (data.length < selectedVars.length + 1) {
                resultsDiv.innerHTML = '<p class="text-red-600">數據不足。</p>';
                return;
            }

            const n = data.length;
            const p = selectedVars.length;

            // 計算相關矩陣
            const corrMatrix = correlationMatrix(data);

            // 特徵值分解
            const eigen = eigenDecomposition(corrMatrix);

            // 排序
            const indices = eigen.eigenvalues.map((val, idx) => idx)
                .sort((a, b) => eigen.eigenvalues[b] - eigen.eigenvalues[a]);

            const sortedEigenvalues = indices.map(i => eigen.eigenvalues[i]);
            const sortedEigenvectors = indices.map(i => eigen.eigenvectors[i]);

            // 決定因子數量
            const numFactorsInput = document.getElementById('faNumFactors').value;
            let numFactors = numFactorsInput ? parseInt(numFactorsInput) : 0;

            if (numFactors === 0) {
                numFactors = sortedEigenvalues.filter(v => v > 1).length;
                if (numFactors === 0) numFactors = 1;
            }

            numFactors = Math.min(numFactors, p - 1);

            // 初始載荷矩陣
            let loadings = [];
            for (let i = 0; i < p; i++) {
                loadings[i] = [];
                for (let j = 0; j < numFactors; j++) {
                    loadings[i][j] = sortedEigenvectors[j][i] * Math.sqrt(Math.max(0, sortedEigenvalues[j]));
                }
            }

            // Varimax 旋轉
            const doRotation = document.getElementById('faRotation').checked;
            if (doRotation && numFactors > 1) {
                loadings = varimax(loadings);
            }

            // 計算共同性
            const communalities = [];
            for (let i = 0; i < p; i++) {
                let h2 = 0;
                for (let j = 0; j < numFactors; j++) {
                    h2 += loadings[i][j] * loadings[i][j];
                }
                communalities.push(h2);
            }

            // 計算因子解釋變異
            const factorVariances = [];
            for (let j = 0; j < numFactors; j++) {
                let sum = 0;
                for (let i = 0; i < p; i++) {
                    sum += loadings[i][j] * loadings[i][j];
                }
                factorVariances.push(sum);
            }

            const totalVariance = factorVariances.reduce((a, b) => a + b, 0);
            const explainedVariance = factorVariances.map(v => (v / p) * 100);

            // 輸出結果
            let html = '<h3 class="text-lg font-semibold mb-2">📊 因素分析結果</h3>';

            // 摘要
            html += '<div class="bg-pink-50 p-4 rounded mb-4"><h4 class="font-semibold mb-2">分析摘要</h4><ul class="text-sm space-y-1"><li>變數數量：' + p + '</li><li>樣本數：' + n + '</li><li>提取因子數：' + numFactors + '</li><li>旋轉方法：' + (doRotation ? 'Varimax' : '無') + '</li><li>總解釋變異：<strong>' + explainedVariance.reduce((a, b) => a + b, 0).toFixed(2) + '%</strong></li></ul></div>';

            // 因子載荷矩陣
            html += '<h4 class="text-md font-semibold mb-2">因子載荷矩陣' + (doRotation ? ' (Varimax 旋轉後)' : '') + ':</h4><div class="overflow-x-auto mb-4"><table class="min-w-full bg-white border"><thead class="bg-gray-50"><tr><th class="px-4 py-2 border">變數</th>';
            for (let i = 0; i < numFactors; i++) {
                html += '<th class="px-4 py-2 border">因子' + (i + 1) + '</th>';
            }
            html += '<th class="px-4 py-2 border">共同性 h²</th></tr></thead><tbody>';
            for (let i = 0; i < p; i++) {
                html += '<tr><td class="px-4 py-2 border font-medium">' + selectedVars[i] + '</td>';
                for (let j = 0; j < numFactors; j++) {
                    const val = loadings[i][j];
                    const color = Math.abs(val) > 0.5 ? 'font-bold text-pink-700' : '';
                    html += '<td class="px-4 py-2 border ' + color + '">' + val.toFixed(3) + '</td>';
                }
                html += '<td class="px-4 py-2 border font-semibold">' + communalities[i].toFixed(3) + '</td></tr>';
            }
            html += '</tbody></table></div>';

            // 因子解釋變異
            html += '<h4 class="text-md font-semibold mb-2">因子解釋變異:</h4><div class="overflow-x-auto mb-4"><table class="min-w-full bg-white border"><thead class="bg-gray-50"><tr><th class="px-4 py-2 border">因子</th><th class="px-4 py-2 border">平方和載荷 (SS)</th><th class="px-4 py-2 border">解釋變異 %</th></tr></thead><tbody>';
            for (let i = 0; i < numFactors; i++) {
                html += '<tr><td class="px-4 py-2 border font-medium">因子' + (i + 1) + '</td><td class="px-4 py-2 border">' + factorVariances[i].toFixed(3) + '</td><td class="px-4 py-2 border">' + explainedVariance[i].toFixed(2) + '%</td></tr>';
            }
            html += '</tbody></table></div>';

            // 判讀說明
            html += '<div class="bg-purple-50 p-4 rounded border-l-4 border-purple-500"><h4 class="font-bold">結果判讀:</h4><ul class="text-sm mt-2 space-y-1 list-disc list-inside"><li>共同性 (h²) 表示變數被因子解釋的比例，h² > 0.5 較佳。</li><li>載荷值絕對值 > 0.5 表示該變數在該因子上有重要貢獻。</li><li>Varimax 旋轉使因子更容易解釋（每個變數傾向在單一因子上有高載荷）。</li></ul></div>';

            resultsDiv.innerHTML = html;
        }


        // ==============================================
        // 卡方檢定 (Chi-Square Test) Function
        // ==============================================
        function runChiSquareTest() {
            const var1 = document.getElementById('chiSquareVar1').value;
            const var2 = document.getElementById('chiSquareVar2').value;
            const resultsDiv = document.getElementById('chiSquareResults');

            if (!var1 || !var2) {
                resultsDiv.innerHTML = '<p class="text-red-600">請選擇兩個類別變數。</p>';
                return;
            }

            if (var1 === var2) {
                resultsDiv.innerHTML = '<p class="text-red-600">請選擇兩個不同的變數。</p>';
                return;
            }

            resultsDiv.innerHTML = '<div class="loader"></div><p class="text-center text-gray-600 mt-2">正在計算卡方檢定...</p>';

            try {
                // 建立列聯表 (Contingency Table)
                const contingencyTable = {};
                const var1Values = [...new Set(jsonData.map(row => row[var1]).filter(v => v != null))];
                const var2Values = [...new Set(jsonData.map(row => row[var2]).filter(v => v != null))];

                // 初始化列聯表
                var1Values.forEach(v1 => {
                    contingencyTable[v1] = {};
                    var2Values.forEach(v2 => {
                        contingencyTable[v1][v2] = 0;
                    });
                });

                // 填充觀察值
                jsonData.forEach(row => {
                    const v1 = row[var1];
                    const v2 = row[var2];
                    if (v1 != null && v2 != null && contingencyTable[v1] && contingencyTable[v1][v2] !== undefined) {
                        contingencyTable[v1][v2]++;
                    }
                });

                // 計算卡方統計量
                const n = jsonData.length;
                const rowTotals = {};
                const colTotals = {};

                var1Values.forEach(v1 => {
                    rowTotals[v1] = var2Values.reduce((sum, v2) => sum + contingencyTable[v1][v2], 0);
                });

                var2Values.forEach(v2 => {
                    colTotals[v2] = var1Values.reduce((sum, v1) => sum + contingencyTable[v1][v2], 0);
                });

                let chiSquare = 0;
                const expectedTable = {};

                var1Values.forEach(v1 => {
                    expectedTable[v1] = {};
                    var2Values.forEach(v2 => {
                        const expected = (rowTotals[v1] * colTotals[v2]) / n;
                        expectedTable[v1][v2] = expected;
                        const observed = contingencyTable[v1][v2];
                        chiSquare += Math.pow(observed - expected, 2) / expected;
                    });
                });

                // 計算自由度
                const df = (var1Values.length - 1) * (var2Values.length - 1);

                // 計算 p-value (使用 jStat)
                const pValue = 1 - jStat.chisquare.cdf(chiSquare, df);

                // 計算 Cramér's V (效果量)
                const minDim = Math.min(var1Values.length, var2Values.length);
                const cramersV = Math.sqrt(chiSquare / (n * (minDim - 1)));

                // 顯示結果
                let html = '<div class="bg-white rounded-lg shadow-md p-6">';
                html += '<h3 class="text-xl font-bold mb-4 text-orange-700">📊 卡方檢定結果</h3>';

                // 統計摘要
                html += '<div class="bg-orange-50 p-4 rounded-lg mb-4">';
                html += '<h4 class="font-semibold mb-2">統計量摘要</h4>';
                html += '<div class="grid md:grid-cols-2 gap-4">';
                html += `<div><span class="font-medium">卡方值 (χ²):</span> <span class="text-lg font-bold text-orange-600">${chiSquare.toFixed(4)}</span></div>`;
                html += `<div><span class="font-medium">自由度 (df):</span> ${df}</div>`;
                html += `<div><span class="font-medium">p-value:</span> <span class="text-lg font-bold ${pValue < 0.05 ? 'text-red-600' : 'text-green-600'}">${pValue.toFixed(6)}</span></div>`;
                html += `<div><span class="font-medium">Cramér's V:</span> ${cramersV.toFixed(4)}</div>`;
                html += '</div></div>';

                // 解釋
                html += '<div class="bg-blue-50 p-4 rounded-lg mb-4">';
                html += '<h4 class="font-semibold mb-2">🎯 結果解釋</h4>';
                if (pValue < 0.05) {
                    html += `<p class="text-green-700 font-semibold">✅ 拒絕虛無假設 (p < 0.05)</p>`;
                    html += `<p class="text-gray-700 mt-2"><strong>${var1}</strong> 與 <strong>${var2}</strong> 之間<span class="text-red-600 font-semibold">存在顯著關聯</span>。</p>`;
                } else {
                    html += `<p class="text-red-700 font-semibold">❌ 無法拒絕虛無假設 (p ≥ 0.05)</p>`;
                    html += `<p class="text-gray-700 mt-2"><strong>${var1}</strong> 與 <strong>${var2}</strong> 之間<span class="text-gray-600 font-semibold">無顯著關聯</span>。</p>`;
                }

                // Cramér's V 效果量解釋
                let effectSize = '';
                if (cramersV < 0.1) effectSize = '極小';
                else if (cramersV < 0.3) effectSize = '小';
                else if (cramersV < 0.5) effectSize = '中等';
                else effectSize = '大';
                html += `<p class="text-gray-700 mt-2">效果量 (Cramér's V = ${cramersV.toFixed(3)}) 為 <strong>${effectSize}</strong>。</p>`;
                html += '</div>';

                // 列聯表 - 觀察值
                html += '<h4 class="font-semibold mt-4 mb-2">列聯表 - 觀察值 (Observed)</h4>';
                html += '<div class="overflow-x-auto"><table class="min-w-full divide-y divide-gray-200 border"><thead class="bg-gray-100"><tr>';
                html += `<th class="px-4 py-2 border">${var1} \\ ${var2}</th>`;
                var2Values.forEach(v2 => html += `<th class="px-4 py-2 border">${v2}</th>`);
                html += '<th class="px-4 py-2 border bg-gray-200">總計</th></tr></thead><tbody>';

                var1Values.forEach(v1 => {
                    html += '<tr>';
                    html += `<td class="px-4 py-2 border font-medium bg-gray-50">${v1}</td>`;
                    var2Values.forEach(v2 => {
                        html += `<td class="px-4 py-2 border text-center">${contingencyTable[v1][v2]}</td>`;
                    });
                    html += `<td class="px-4 py-2 border text-center font-semibold bg-gray-100">${rowTotals[v1]}</td>`;
                    html += '</tr>';
                });

                // 總計列
                html += '<tr class="bg-gray-200"><td class="px-4 py-2 border font-semibold">總計</td>';
                var2Values.forEach(v2 => {
                    html += `<td class="px-4 py-2 border text-center font-semibold">${colTotals[v2]}</td>`;
                });
                html += `<td class="px-4 py-2 border text-center font-bold">${n}</td></tr>`;
                html += '</tbody></table></div>';

                // 列聯表 - 期望值
                html += '<h4 class="font-semibold mt-6 mb-2">列聯表 - 期望值 (Expected)</h4>';
                html += '<div class="overflow-x-auto"><table class="min-w-full divide-y divide-gray-200 border"><thead class="bg-gray-100"><tr>';
                html += `<th class="px-4 py-2 border">${var1} \\ ${var2}</th>`;
                var2Values.forEach(v2 => html += `<th class="px-4 py-2 border">${v2}</th>`);
                html += '</tr></thead><tbody>';

                var1Values.forEach(v1 => {
                    html += '<tr>';
                    html += `<td class="px-4 py-2 border font-medium bg-gray-50">${v1}</td>`;
                    var2Values.forEach(v2 => {
                        html += `<td class="px-4 py-2 border text-center text-gray-600">${expectedTable[v1][v2].toFixed(2)}</td>`;
                    });
                    html += '</tr>';
                });
                html += '</tbody></table></div>';

                // 視覺化 - 堆疊長條圖
                html += '<div id="chiSquarePlot" class="mt-6"></div>';
                html += '</div>';

                resultsDiv.innerHTML = html;

                // 繪製圖表
                setTimeout(() => {
                    const traces = var2Values.map(v2 => ({
                        x: var1Values,
                        y: var1Values.map(v1 => contingencyTable[v1][v2]),
                        name: v2,
                        type: 'bar'
                    }));

                    Plotly.newPlot('chiSquarePlot', traces, {
                        title: `${var1} vs ${var2} 分布圖`,
                        barmode: 'group',
                        xaxis: { title: var1 },
                        yaxis: { title: '計數' },
                        margin: { t: 40, b: 60, l: 60, r: 40 }
                    }, { responsive: true });
                }, 100);

            } catch (error) {
                resultsDiv.innerHTML = `<p class="text-red-600">計算錯誤: ${error.message}</p>`;
                console.error(error);
            }
        }

        // ==============================================
        // K-Means 集群分析 Functions
        // ==============================================

        // Elbow Method - 找最佳K值
        function runKmeansElbow() {
            const selectedVars = Array.from(document.getElementById('kmeansVariables').selectedOptions).map(opt => opt.value);
            const resultsDiv = document.getElementById('kmeansResults');

            if (selectedVars.length < 2) {
                resultsDiv.innerHTML = '<p class="text-red-600">請至少選擇2個數值變數。</p>';
                return;
            }

            resultsDiv.innerHTML = '<div class="loader"></div><p class="text-center text-gray-600 mt-2">正在執行 Elbow 分析...</p>';

            try {
                // 準備數據
                const data = jsonData.map(row => selectedVars.map(v => row[v])).filter(row => row.every(val => typeof val === 'number' && !isNaN(val)));

                if (data.length < 10) {
                    resultsDiv.innerHTML = '<p class="text-red-600">數據量不足（至少需要10筆完整資料）。</p>';
                    return;
                }

                // 標準化數據
                const standardize = document.getElementById('kmeansStandardize').checked;
                let processedData = data;
                if (standardize) {
                    processedData = standardizeData(data);
                }

                // 計算不同K值的WCSS (Within-Cluster Sum of Squares)
                const maxK = Math.min(10, Math.floor(data.length / 2));
                const wcssValues = [];

                for (let k = 1; k <= maxK; k++) {
                    const result = performKmeans(processedData, k, 100);
                    wcssValues.push({ k: k, wcss: result.wcss });
                }

                // 顯示結果
                let html = '<div class="bg-white rounded-lg shadow-md p-6">';
                html += '<h3 class="text-xl font-bold mb-4 text-blue-700">🔍 Elbow Method - 最佳 K 值分析</h3>';
                html += '<p class="text-gray-600 mb-4">Elbow 法透過觀察 WCSS (Within-Cluster Sum of Squares) 的變化趨勢，找出「手肘點」作為最佳集群數。</p>';
                html += '<div id="elbowPlot"></div>';
                html += '<div class="bg-blue-50 p-4 rounded-lg mt-4">';
                html += '<h4 class="font-semibold mb-2">💡 如何判讀</h4>';
                html += '<ul class="text-sm text-gray-700 space-y-1">';
                html += '<li>• 找出曲線「彎曲」最明顯的點（手肘點）</li>';
                html += '<li>• 該點對應的 K 值通常是最佳集群數</li>';
                html += '<li>• WCSS 下降趨緩後，增加 K 值效益不大</li>';
                html += '</ul></div></div>';

                resultsDiv.innerHTML = html;

                // 繪製 Elbow 圖
                setTimeout(() => {
                    const trace = {
                        x: wcssValues.map(v => v.k),
                        y: wcssValues.map(v => v.wcss),
                        mode: 'lines+markers',
                        marker: { color: '#3b82f6', size: 10 },
                        line: { color: '#3b82f6', width: 3 }
                    };

                    Plotly.newPlot('elbowPlot', [trace], {
                        title: 'Elbow Method - WCSS vs K',
                        xaxis: { title: '集群數 K', dtick: 1 },
                        yaxis: { title: 'WCSS (Within-Cluster Sum of Squares)' },
                        margin: { t: 60, b: 60, l: 80, r: 40 }
                    }, { responsive: true });
                }, 100);

            } catch (error) {
                resultsDiv.innerHTML = `<p class="text-red-600">計算錯誤: ${error.message}</p>`;
                console.error(error);
            }
        }

        // K-Means 集群分析主函數
        function runKmeansClustering() {
            const selectedVars = Array.from(document.getElementById('kmeansVariables').selectedOptions).map(opt => opt.value);
            const k = parseInt(document.getElementById('kmeansK').value);
            const maxIter = parseInt(document.getElementById('kmeansMaxIter').value);
            const resultsDiv = document.getElementById('kmeansResults');

            if (selectedVars.length < 2) {
                resultsDiv.innerHTML = '<p class="text-red-600">請至少選擇2個數值變數。</p>';
                return;
            }

            if (k < 2 || k > 10) {
                resultsDiv.innerHTML = '<p class="text-red-600">K 值需介於 2 到 10 之間。</p>';
                return;
            }

            resultsDiv.innerHTML = '<div class="loader"></div><p class="text-center text-gray-600 mt-2">正在執行 K-Means 集群分析...</p>';

            try {
                // 準備數據（保留原始數據索引）
                const dataWithIndex = jsonData.map((row, idx) => ({
                    index: idx,
                    values: selectedVars.map(v => row[v])
                })).filter(item => item.values.every(val => typeof val === 'number' && !isNaN(val)));

                if (dataWithIndex.length < k) {
                    resultsDiv.innerHTML = '<p class="text-red-600">有效數據量不足（需大於 K 值）。</p>';
                    return;
                }

                const data = dataWithIndex.map(item => item.values);

                // 標準化數據
                const standardize = document.getElementById('kmeansStandardize').checked;
                let processedData = data;
                let means = null, stds = null;

                if (standardize) {
                    const result = standardizeDataWithStats(data);
                    processedData = result.data;
                    means = result.means;
                    stds = result.stds;
                }

                // 執行 K-Means
                const result = performKmeans(processedData, k, maxIter);

                // 計算集群統計
                const clusterStats = calculateClusterStats(data, result.labels, selectedVars, k);

                // 顯示結果
                let html = '<div class="bg-white rounded-lg shadow-md p-6">';
                html += '<h3 class="text-xl font-bold mb-4 text-green-700">🎯 K-Means 集群分析結果</h3>';

                // 摘要統計
                html += '<div class="bg-green-50 p-4 rounded-lg mb-4">';
                html += '<h4 class="font-semibold mb-2">集群摘要</h4>';
                html += '<div class="grid md:grid-cols-4 gap-4">';
                html += `<div><span class="font-medium">集群數 (K):</span> <span class="text-lg font-bold">${k}</span></div>`;
                html += `<div><span class="font-medium">總數據點:</span> ${data.length}</div>`;
                html += `<div><span class="font-medium">迭代次數:</span> ${result.iterations}</div>`;
                html += `<div><span class="font-medium">WCSS:</span> ${result.wcss.toFixed(2)}</div>`;
                html += '</div></div>';

                // 各集群大小
                html += '<h4 class="font-semibold mt-4 mb-2">各集群大小</h4>';
                html += '<div class="grid md:grid-cols-5 gap-2 mb-4">';
                for (let i = 0; i < k; i++) {
                    const count = result.labels.filter(l => l === i).length;
                    const percentage = ((count / data.length) * 100).toFixed(1);
                    html += `<div class="bg-gray-100 p-3 rounded text-center">`;
                    html += `<div class="font-semibold text-gray-700">集群 ${i + 1}</div>`;
                    html += `<div class="text-2xl font-bold text-green-600">${count}</div>`;
                    html += `<div class="text-xs text-gray-500">${percentage}%</div>`;
                    html += `</div>`;
                }
                html += '</div>';

                // 集群中心點
                html += '<h4 class="font-semibold mt-4 mb-2">集群中心點 (Centroids)</h4>';
                html += '<div class="overflow-x-auto"><table class="min-w-full divide-y divide-gray-200 border"><thead class="bg-gray-100"><tr>';
                html += '<th class="px-4 py-2 border">集群</th>';
                selectedVars.forEach(v => html += `<th class="px-4 py-2 border">${v}</th>`);
                html += '</tr></thead><tbody>';

                result.centroids.forEach((centroid, idx) => {
                    html += '<tr>';
                    html += `<td class="px-4 py-2 border font-semibold bg-gray-50">集群 ${idx + 1}</td>`;
                    centroid.forEach((val, vIdx) => {
                        // 如果有標準化,反標準化顯示原始尺度
                        let displayVal = val;
                        if (standardize && means && stds) {
                            displayVal = val * stds[vIdx] + means[vIdx];
                        }
                        html += `<td class="px-4 py-2 border text-center">${displayVal.toFixed(3)}</td>`;
                    });
                    html += '</tr>';
                });
                html += '</tbody></table></div>';

                // 集群特徵分析
                html += '<h4 class="font-semibold mt-6 mb-2">集群特徵分析</h4>';
                html += '<div class="space-y-3">';
                for (let i = 0; i < k; i++) {
                    html += `<div class="bg-gray-50 p-4 rounded-lg">`;
                    html += `<h5 class="font-semibold text-lg mb-2">集群 ${i + 1} 特徵</h5>`;
                    html += '<div class="grid md:grid-cols-3 gap-2 text-sm">';
                    selectedVars.forEach((v, vIdx) => {
                        html += `<div><span class="text-gray-600">${v}:</span> <span class="font-semibold">${clusterStats[i][vIdx].mean.toFixed(3)}</span> ± ${clusterStats[i][vIdx].std.toFixed(3)}</div>`;
                    });
                    html += '</div></div>';
                }
                html += '</div>';

                // 視覺化（如果變數>=2，顯示散點圖）
                if (selectedVars.length >= 2) {
                    html += '<div id="kmeansScatterPlot" class="mt-6"></div>';
                }

                // 輪廓係數（Silhouette Score）
                const silhouetteScore = calculateSilhouetteScore(processedData, result.labels, k);
                html += '<div class="bg-yellow-50 p-4 rounded-lg mt-4">';
                html += '<h4 class="font-semibold mb-2">📏 集群品質指標</h4>';
                html += `<div><span class="font-medium">Silhouette Score:</span> <span class="text-lg font-bold text-yellow-700">${silhouetteScore.toFixed(4)}</span></div>`;
                html += '<p class="text-sm text-gray-600 mt-2">範圍 [-1, 1]，越接近 1 表示集群品質越好。</p>';
                let quality = '';
                if (silhouetteScore > 0.7) quality = '優秀';
                else if (silhouetteScore > 0.5) quality = '良好';
                else if (silhouetteScore > 0.3) quality = '尚可';
                else quality = '不佳';
                html += `<p class="text-sm font-semibold text-gray-700">集群品質: <span class="${silhouetteScore > 0.5 ? 'text-green-600' : 'text-orange-600'}">${quality}</span></p>`;
                html += '</div>';

                html += '</div>';

                resultsDiv.innerHTML = html;

                // 繪製散點圖（使用前兩個變數）
                if (selectedVars.length >= 2) {
                    setTimeout(() => {
                        const traces = [];
                        const colors = ['#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899', '#14b8a6', '#f97316'];

                        for (let i = 0; i < k; i++) {
                            const clusterData = data.filter((_, idx) => result.labels[idx] === i);
                            traces.push({
                                x: clusterData.map(d => d[0]),
                                y: clusterData.map(d => d[1]),
                                mode: 'markers',
                                type: 'scatter',
                                name: `集群 ${i + 1}`,
                                marker: { color: colors[i % colors.length], size: 8, opacity: 0.7 }
                            });
                        }

                        // 加入中心點
                        let centroids = result.centroids;
                        if (standardize && means && stds) {
                            centroids = result.centroids.map(c => c.map((val, idx) => val * stds[idx] + means[idx]));
                        }

                        traces.push({
                            x: centroids.map(c => c[0]),
                            y: centroids.map(c => c[1]),
                            mode: 'markers',
                            type: 'scatter',
                            name: '中心點',
                            marker: { color: 'black', size: 15, symbol: 'x' }
                        });

                        Plotly.newPlot('kmeansScatterPlot', traces, {
                            title: `K-Means 集群視覺化 (前兩個變數)`,
                            xaxis: { title: selectedVars[0] },
                            yaxis: { title: selectedVars[1] },
                            margin: { t: 60, b: 60, l: 80, r: 40 }
                        }, { responsive: true });
                    }, 100);
                }

            } catch (error) {
                resultsDiv.innerHTML = `<p class="text-red-600">計算錯誤: ${error.message}</p>`;
                console.error(error);
            }
        }

        // ===== K-Means 輔助函數 =====

        function standardizeData(data) {
            const n = data.length;
            const m = data[0].length;
            const means = [];
            const stds = [];

            // 計算每個變數的平均值和標準差
            for (let j = 0; j < m; j++) {
                const values = data.map(row => row[j]);
                const mean = ss.mean(values);
                const std = ss.standardDeviation(values);
                means.push(mean);
                stds.push(std);
            }

            // 標準化
            return data.map(row => row.map((val, j) => (val - means[j]) / (stds[j] === 0 ? 1 : stds[j])));
        }

        function standardizeDataWithStats(data) {
            const n = data.length;
            const m = data[0].length;
            const means = [];
            const stds = [];

            for (let j = 0; j < m; j++) {
                const values = data.map(row => row[j]);
                const mean = ss.mean(values);
                const std = ss.standardDeviation(values);
                means.push(mean);
                stds.push(std);
            }

            const standardizedData = data.map(row => row.map((val, j) => (val - means[j]) / (stds[j] === 0 ? 1 : stds[j])));

            return { data: standardizedData, means, stds };
        }

        function performKmeans(data, k, maxIter) {
            const n = data.length;
            const m = data[0].length;

            // 隨機初始化中心點（K-Means++）
            let centroids = initializeCentroidsKMeansPlusPlus(data, k);
            let labels = new Array(n).fill(0);
            let prevLabels = new Array(n).fill(-1);
            let iterations = 0;

            while (iterations < maxIter && !arraysEqual(labels, prevLabels)) {
                prevLabels = [...labels];

                // 分配每個點到最近的中心
                for (let i = 0; i < n; i++) {
                    let minDist = Infinity;
                    let closestCentroid = 0;

                    for (let j = 0; j < k; j++) {
                        const dist = euclideanDistance(data[i], centroids[j]);
                        if (dist < minDist) {
                            minDist = dist;
                            closestCentroid = j;
                        }
                    }

                    labels[i] = closestCentroid;
                }

                // 更新中心點
                for (let j = 0; j < k; j++) {
                    const clusterPoints = data.filter((_, idx) => labels[idx] === j);
                    if (clusterPoints.length > 0) {
                        centroids[j] = clusterPoints[0].map((_, dim) =>
                            ss.mean(clusterPoints.map(p => p[dim]))
                        );
                    }
                }

                iterations++;
            }

            // 計算 WCSS
            let wcss = 0;
            for (let i = 0; i < n; i++) {
                wcss += Math.pow(euclideanDistance(data[i], centroids[labels[i]]), 2);
            }

            return { centroids, labels, iterations, wcss };
        }

        function initializeCentroidsKMeansPlusPlus(data, k) {
            const centroids = [];
            const n = data.length;

            // 隨機選擇第一個中心點
            centroids.push(data[Math.floor(Math.random() * n)]);

            // 選擇剩餘的中心點
            for (let i = 1; i < k; i++) {
                const distances = data.map(point => {
                    const minDist = Math.min(...centroids.map(c => euclideanDistance(point, c)));
                    return minDist * minDist;
                });

                const totalDist = distances.reduce((a, b) => a + b, 0);
                const probs = distances.map(d => d / totalDist);

                // 按概率選擇下一個中心點
                const r = Math.random();
                let cumProb = 0;
                for (let j = 0; j < n; j++) {
                    cumProb += probs[j];
                    if (r < cumProb) {
                        centroids.push(data[j]);
                        break;
                    }
                }
            }

            return centroids;
        }

        function euclideanDistance(p1, p2) {
            return Math.sqrt(p1.reduce((sum, val, idx) => sum + Math.pow(val - p2[idx], 2), 0));
        }

        function arraysEqual(a, b) {
            return a.length === b.length && a.every((val, idx) => val === b[idx]);
        }

        function calculateClusterStats(data, labels, varNames, k) {
            const stats = [];

            for (let i = 0; i < k; i++) {
                const clusterData = data.filter((_, idx) => labels[idx] === i);
                const clusterStats = varNames.map((_, vIdx) => {
                    const values = clusterData.map(row => row[vIdx]);
                    return {
                        mean: ss.mean(values),
                        std: ss.standardDeviation(values),
                        min: ss.min(values),
                        max: ss.max(values)
                    };
                });
                stats.push(clusterStats);
            }

            return stats;
        }

        function calculateSilhouetteScore(data, labels, k) {
            const n = data.length;
            let totalScore = 0;

            for (let i = 0; i < n; i++) {
                const label = labels[i];

                // a(i): 平均群內距離
                const inCluster = data.filter((_, idx) => labels[idx] === label);
                const a = inCluster.length > 1 ?
                    ss.mean(inCluster.map(p => euclideanDistance(data[i], p))) : 0;

                // b(i): 最小平均群間距離
                let b = Infinity;
                for (let j = 0; j < k; j++) {
                    if (j !== label) {
                        const otherCluster = data.filter((_, idx) => labels[idx] === j);
                        if (otherCluster.length > 0) {
                            const avgDist = ss.mean(otherCluster.map(p => euclideanDistance(data[i], p)));
                            b = Math.min(b, avgDist);
                        }
                    }
                }

                // s(i) = (b - a) / max(a, b)
                const s = (b - a) / Math.max(a, b);
                totalScore += s;
            }

            return totalScore / n;
        }


        // ==============================================
        // 關聯規則挖掘 (Apriori Algorithm)
        // ==============================================

        function runAprioriAnalysis() {
            const transactionIdField = document.getElementById('aprioriTransactionId').value;
            const itemNameField = document.getElementById('aprioriItemName').value;
            const minSupport = parseFloat(document.getElementById('aprioriMinSupport').value);
            const minConfidence = parseFloat(document.getElementById('aprioriMinConfidence').value);
            const minLift = parseFloat(document.getElementById('aprioriMinLift').value);
            const resultsDiv = document.getElementById('aprioriResults');

            if (!transactionIdField || !itemNameField) {
                resultsDiv.innerHTML = '<p class="text-red-600">請選擇交易ID和商品名稱欄位。</p>';
                return;
            }

            if (transactionIdField === itemNameField) {
                resultsDiv.innerHTML = '<p class="text-red-600">交易ID和商品名稱不能是同一個欄位。</p>';
                return;
            }

            resultsDiv.innerHTML = '<div class="loader"></div><p class="text-center text-gray-600 mt-2">正在執行 Apriori 演算法...</p>';

            try {
                // 1. 轉換數據為交易格式
                const transactions = {};
                jsonData.forEach(row => {
                    const tid = row[transactionIdField];
                    const item = row[itemNameField];
                    if (tid != null && item != null) {
                        if (!transactions[tid]) {
                            transactions[tid] = [];
                        }
                        if (!transactions[tid].includes(item)) {
                            transactions[tid].push(item);
                        }
                    }
                });

                const transactionList = Object.values(transactions);
                const numTransactions = transactionList.length;

                if (numTransactions < 10) {
                    resultsDiv.innerHTML = '<p class="text-red-600">交易數量不足（至少需要10筆交易）。</p>';
                    return;
                }

                // 2. 找出所有頻繁項目集 (Frequent Itemsets)
                const frequentItemsets = findFrequentItemsets(transactionList, minSupport);

                if (frequentItemsets.length === 0) {
                    resultsDiv.innerHTML = '<p class="text-orange-600">沒有找到符合條件的頻繁項目集，請降低最小支持度。</p>';
                    return;
                }

                // 3. 生成關聯規則
                const rules = generateAssociationRules(frequentItemsets, transactionList, minConfidence, minLift);

                if (rules.length === 0) {
                    resultsDiv.innerHTML = '<p class="text-orange-600">沒有找到符合條件的關聯規則，請降低最小信賴度或提升度。</p>';
                    return;
                }

                // 4. 按Lift排序
                rules.sort((a, b) => (b.lift * b.support) - (a.lift * a.support));

                // 5. 顯示結果
                let html = '<div class="bg-white rounded-lg shadow-md p-6">';
                html += '<h3 class="text-xl font-bold mb-4 text-purple-700">🛒 關聯規則挖掘結果</h3>';

                // 基本統計
                html += '<div class="bg-purple-50 p-4 rounded-lg mb-4">';
                html += '<h4 class="font-semibold mb-2">基本統計</h4>';
                html += '<div class="grid md:grid-cols-4 gap-4 text-sm">';
                html += `<div><span class="text-gray-600">交易總數:</span> <span class="font-bold">${numTransactions}</span></div>`;
                html += `<div><span class="text-gray-600">頻繁項目集:</span> <span class="font-bold">${frequentItemsets.length}</span></div>`;
                html += `<div><span class="text-gray-600">關聯規則:</span> <span class="font-bold">${rules.length}</span></div>`;

                // 計算所有商品
                const allItems = new Set();
                transactionList.forEach(t => t.forEach(item => allItems.add(item)));
                html += `<div><span class="text-gray-600">商品種類:</span> <span class="font-bold">${allItems.size}</span></div>`;
                html += '</div></div>';

                // Top 關聯規則表格
                html += '<h4 class="font-semibold mt-6 mb-3">🏆 關聯規則排行 (依 Lift × Support 排序)</h4>';
                html += '<div class="overflow-x-auto">';
                html += '<table class="min-w-full divide-y divide-gray-200 border text-sm">';
                html += '<thead class="bg-gray-100">';
                html += '<tr>';
                html += '<th class="px-3 py-2 border text-left">#</th>';
                html += '<th class="px-3 py-2 border text-left">前項 (Antecedent)</th>';
                html += '<th class="px-3 py-2 border text-center">→</th>';
                html += '<th class="px-3 py-2 border text-left">後項 (Consequent)</th>';
                html += '<th class="px-3 py-2 border text-center">支持度<br>Support</th>';
                html += '<th class="px-3 py-2 border text-center">信賴度<br>Confidence</th>';
                html += '<th class="px-3 py-2 border text-center">提升度<br>Lift</th>';
                html += '</tr></thead><tbody class="bg-white">';

                // 只顯示前20條規則
                rules.slice(0, 20).forEach((rule, idx) => {
                    const liftColor = rule.lift > 2 ? 'text-red-600 font-bold' :
                        rule.lift > 1.5 ? 'text-orange-600 font-semibold' :
                            'text-green-600';

                    html += '<tr class="hover:bg-gray-50">';
                    html += `<td class="px-3 py-2 border text-center font-semibold">${idx + 1}</td>`;
                    html += `<td class="px-3 py-2 border"><span class="bg-blue-100 px-2 py-1 rounded text-xs">${rule.antecedent.join(' + ')}</span></td>`;
                    html += `<td class="px-3 py-2 border text-center text-xl">→</td>`;
                    html += `<td class="px-3 py-2 border"><span class="bg-green-100 px-2 py-1 rounded text-xs">${rule.consequent.join(' + ')}</span></td>`;
                    html += `<td class="px-3 py-2 border text-center">${(rule.support * 100).toFixed(2)}%</td>`;
                    html += `<td class="px-3 py-2 border text-center font-semibold">${(rule.confidence * 100).toFixed(1)}%</td>`;
                    html += `<td class="px-3 py-2 border text-center ${liftColor}">${rule.lift.toFixed(2)}×</td>`;
                    html += '</tr>';
                });

                html += '</tbody></table></div>';

                if (rules.length > 20) {
                    html += `<p class="text-xs text-gray-500 mt-2">顯示前20條規則 (共${rules.length}條)</p>`;
                }

                // 指標說明
                html += '<div class="bg-blue-50 p-4 rounded-lg mt-6">';
                html += '<h4 class="font-semibold mb-2">📊 指標說明</h4>';
                html += '<div class="text-sm text-gray-700 space-y-2">';
                html += '<p><strong>Support (支持度)</strong>: {A, B} 在所有交易中出現的比例</p>';
                html += '<p><strong>Confidence (信賴度)</strong>: 買了 A 之後買 B 的條件機率 = P(B|A)</p>';
                html += '<p><strong>Lift (提升度)</strong>: 關聯強度指標 = Confidence / P(B)</p>';
                html += '<ul class="list-disc ml-6 mt-2">';
                html += '<li>Lift > 1: 正相關 (買A增加買B的機率)</li>';
                html += '<li>Lift = 1: 獨立 (無關聯)</li>';
                html += '<li>Lift < 1: 負相關 (買A降低買B的機率)</li>';
                html += '</ul></div></div>';

                // 商業應用建議
                html += '<div class="bg-green-50 p-4 rounded-lg mt-4">';
                html += '<h4 class="font-semibold mb-2">💡 商業應用建議</h4>';
                html += '<div class="text-sm text-gray-700 space-y-2">';

                if (rules.length > 0) {
                    // 找出 Lift × Support 最大的規則 (綜合考慮關聯強度和頻率)
                    const topRule = rules.reduce((best, current) => {
                        const bestScore = best.lift * best.support;
                        const currentScore = current.lift * current.support;
                        return currentScore > bestScore ? current : best;
                    }, rules[0]);
                    const topScore = (topRule.lift * topRule.support * 100).toFixed(2);
                    
                    html += `<p><strong>最佳規則 (Lift × Support 最大):</strong></p>`;
                    html += `<p class="ml-4">購買 <span class="font-semibold text-blue-600">${topRule.antecedent.join(', ')}</span> 的客戶，有 <span class="font-bold text-red-600">${(topRule.confidence * 100).toFixed(1)}%</span> 機率也會購買 <span class="font-semibold text-green-600">${topRule.consequent.join(', ')}</span></p>`;
                    html += `<p class="ml-4 text-xs text-gray-500">(Lift: ${topRule.lift.toFixed(2)}×, Support: ${(topRule.support * 100).toFixed(1)}%, Score: ${topScore})</p>`;
                    html += '<p class="mt-3"><strong>建議策略:</strong></p>';
                    html += '<ul class="list-disc ml-8">';
                    html += `<li>商品組合促銷: 購買 ${topRule.antecedent.join('+')} 加購 ${topRule.consequent.join('+')} 享優惠</li>`;
                    html += `<li>貨架擺放: 將 ${topRule.antecedent.join(', ')} 和 ${topRule.consequent.join(', ')} 擺放在鄰近位置</li>`;
                    html += `<li>交叉銷售: 推薦系統「買了這個的人也買了...」</li>`;
                    html += '</ul>';
                }

                html += '</div></div>';

                // Support-Lift 四象限圖
                html += '<h4 class="font-semibold mt-6 mb-3">📊 Support-Lift 四象限圖 (Apriori Decision Map)</h4>';
                html += '<div id="aprioriQuadrantChart" class="w-full" style="height: 450px;"></div>';
                html += '<div class="text-sm text-gray-600 mt-2 grid grid-cols-2 md:grid-cols-4 gap-2">';
                html += '<div class="bg-green-50 p-2 rounded text-center"><strong>右上</strong>: 高支持度+正關聯<br><span class="text-xs">⭐ 最佳規則</span></div>';
                html += '<div class="bg-blue-50 p-2 rounded text-center"><strong>左上</strong>: 低支持度+正關聯<br><span class="text-xs">🔍 利基市場</span></div>';
                html += '<div class="bg-yellow-50 p-2 rounded text-center"><strong>右下</strong>: 高支持度+負關聯<br><span class="text-xs">⚠️ 避免組合</span></div>';
                html += '<div class="bg-gray-50 p-2 rounded text-center"><strong>左下</strong>: 低支持度+負關聯<br><span class="text-xs">❌ 無價值</span></div>';
                html += '</div>';

                // 視覺化提示
                html += '<div class="mt-4 p-3 bg-yellow-50 rounded border border-yellow-200">';
                html += '<p class="text-sm text-yellow-800">💡 <strong>提示:</strong> 四象限圖以 Support 中位數和 Lift=1 為分界線。右上象限為最有價值的規則。</p>';
                html += '</div>';

                html += '</div>';

                resultsDiv.innerHTML = html;

                // 繪製 Support-Lift 四象限圖
                setTimeout(() => {
                    const supports = rules.map(r => r.support);
                    const lifts = rules.map(r => r.lift);
                    const labels = rules.map(r => r.antecedent.join('+') + '→' + r.consequent.join('+'));
                    
                    // 計算分界線位置
                    const supportMedian = ss.median(supports);
                    const liftThreshold = 1.0;
                    
                    // 根據象限位置設定顏色
                    const colors = rules.map(r => {
                        if (r.support >= supportMedian && r.lift >= liftThreshold) return '#10b981'; // 右上 綠色
                        if (r.support < supportMedian && r.lift >= liftThreshold) return '#3b82f6';  // 左上 藍色
                        if (r.support >= supportMedian && r.lift < liftThreshold) return '#f59e0b'; // 右下 黃色
                        return '#6b7280'; // 左下 灰色
                    });

                    const trace = {
                        x: supports,
                        y: lifts,
                        mode: 'markers',
                        type: 'scatter',
                        text: labels,
                        marker: {
                            size: 18,
                            color: colors,
                            line: { width: 2, color: '#ffffff' }
                        },
                        hovertemplate: '<b style="font-size:14px">%{text}</b><br>Support: %{x:.2%}<br>Lift: %{y:.2f}<extra></extra>',
                        hoverlabel: {
                            font: { size: 14 },
                            bgcolor: '#ffffff',
                            bordercolor: '#333333'
                        }
                    };

                    // 垂直線 (Support 中位數)
                    const verticalLine = {
                        x: [supportMedian, supportMedian],
                        y: [Math.min(...lifts) * 0.9, Math.max(...lifts) * 1.1],
                        mode: 'lines',
                        type: 'scatter',
                        line: { color: '#3b82f6', width: 2, dash: 'dash' },
                        showlegend: false,
                        hoverinfo: 'skip'
                    };

                    // 水平線 (Lift = 1)
                    const horizontalLine = {
                        x: [0, Math.max(...supports) * 1.1],
                        y: [liftThreshold, liftThreshold],
                        mode: 'lines',
                        type: 'scatter',
                        line: { color: '#3b82f6', width: 2, dash: 'dash' },
                        showlegend: false,
                        hoverinfo: 'skip'
                    };

                    const layout = {
                        title: {
                            text: 'Support-Lift Quadrant (Apriori Decision Map)',
                            font: { size: 16 }
                        },
                        xaxis: {
                            title: 'Support (支持度)',
                            tickformat: '.0%',
                            zeroline: false,
                            range: [0, Math.max(...supports) * 1.15]
                        },
                        yaxis: {
                            title: 'Lift (提升度)',
                            zeroline: false,
                            range: [Math.min(0, Math.min(...lifts) * 0.9), Math.max(...lifts) * 1.15]
                        },
                        hovermode: 'closest',
                        showlegend: false,
                        margin: { t: 50, b: 60, l: 60, r: 40 },
                        annotations: [
                            {
                                x: supportMedian,
                                y: Math.max(...lifts) * 1.08,
                                text: `Support 中位數: ${(supportMedian * 100).toFixed(1)}%`,
                                showarrow: false,
                                font: { size: 10, color: '#3b82f6' }
                            },
                            {
                                x: Math.max(...supports) * 1.05,
                                y: liftThreshold,
                                text: 'Lift = 1',
                                showarrow: false,
                                font: { size: 10, color: '#3b82f6' }
                            }
                        ]
                    };

                    Plotly.newPlot('aprioriQuadrantChart', [trace, verticalLine, horizontalLine], layout, { responsive: true });
                }, 100);


            } catch (error) {
                resultsDiv.innerHTML = `<p class="text-red-600">計算錯誤: ${error.message}</p>`;
                console.error(error);
            }
        }

        // Apriori 輔助函數
        function findFrequentItemsets(transactions, minSupport) {
            const numTransactions = transactions.length;
            const minSupportCount = Math.ceil(minSupport * numTransactions);

            // 1. 找出所有單一項目的支持度
            const itemCounts = {};
            transactions.forEach(transaction => {
                transaction.forEach(item => {
                    itemCounts[item] = (itemCounts[item] || 0) + 1;
                });
            });

            // 2. 過濾出頻繁單項
            let frequentItemsets = [];
            Object.keys(itemCounts).forEach(item => {
                if (itemCounts[item] >= minSupportCount) {
                    frequentItemsets.push({
                        items: [item],
                        support: itemCounts[item] / numTransactions
                    });
                }
            });

            // 3. 生成更大的項目集 (2-itemsets, 3-itemsets, ...)
            let k = 2;
            let currentItemsets = frequentItemsets.map(f => f.items);

            while (currentItemsets.length > 0 && k <= 3) { // 限制最大為3-itemsets
                const candidates = generateCandidates(currentItemsets, k);
                const candidateCounts = {};

                // 計算候選項目集的支持度
                transactions.forEach(transaction => {
                    candidates.forEach(candidate => {
                        const candidateKey = candidate.join(',');
                        if (candidate.every(item => transaction.includes(item))) {
                            candidateCounts[candidateKey] = (candidateCounts[candidateKey] || 0) + 1;
                        }
                    });
                });

                // 過濾頻繁項目集
                currentItemsets = [];
                Object.keys(candidateCounts).forEach(key => {
                    if (candidateCounts[key] >= minSupportCount) {
                        const items = key.split(',');
                        frequentItemsets.push({
                            items: items,
                            support: candidateCounts[key] / numTransactions
                        });
                        currentItemsets.push(items);
                    }
                });

                k++;
            }

            return frequentItemsets;
        }

        function generateCandidates(frequentItemsets, k) {
            const candidates = [];

            for (let i = 0; i < frequentItemsets.length; i++) {
                for (let j = i + 1; j < frequentItemsets.length; j++) {
                    const set1 = frequentItemsets[i];
                    const set2 = frequentItemsets[j];

                    // 合併兩個k-1項目集
                    const union = [...new Set([...set1, ...set2])];

                    if (union.length === k) {
                        const sortedUnion = union.sort();
                        const candidateKey = sortedUnion.join(',');

                        // 避免重複
                        if (!candidates.some(c => c.join(',') === candidateKey)) {
                            candidates.push(sortedUnion);
                        }
                    }
                }
            }

            return candidates;
        }

        function generateAssociationRules(frequentItemsets, transactions, minConfidence, minLift) {
            const rules = [];
            const numTransactions = transactions.length;

            // 計算每個項目的支持度 (用於計算Lift)
            const itemSupport = {};
            frequentItemsets.forEach(itemset => {
                if (itemset.items.length === 1) {
                    itemSupport[itemset.items[0]] = itemset.support;
                }
            });

            // 從2-itemsets及以上生成規則
            frequentItemsets.filter(itemset => itemset.items.length >= 2).forEach(itemset => {
                const items = itemset.items;
                const itemsetSupport = itemset.support;

                // 生成所有可能的前項/後項組合
                for (let i = 1; i < Math.pow(2, items.length) - 1; i++) {
                    const antecedent = [];
                    const consequent = [];

                    for (let j = 0; j < items.length; j++) {
                        if (i & (1 << j)) {
                            antecedent.push(items[j]);
                        } else {
                            consequent.push(items[j]);
                        }
                    }

                    if (antecedent.length > 0 && consequent.length > 0) {
                        // 計算前項的支持度
                        const antecedentSupport = calculateSupport(antecedent, transactions) / numTransactions;

                        if (antecedentSupport > 0) {
                            const confidence = itemsetSupport / antecedentSupport;

                            // 計算後項的支持度
                            const consequentSupport = calculateSupport(consequent, transactions) / numTransactions;
                            const lift = consequentSupport > 0 ? confidence / consequentSupport : 0;

                            if (confidence >= minConfidence && lift >= minLift) {
                                rules.push({
                                    antecedent: antecedent,
                                    consequent: consequent,
                                    support: itemsetSupport,
                                    confidence: confidence,
                                    lift: lift
                                });
                            }
                        }
                    }
                }
            });

            return rules;
        }

        function calculateSupport(items, transactions) {
            let count = 0;
            transactions.forEach(transaction => {
                if (items.every(item => transaction.includes(item))) {
                    count++;
                }
            });
            return count;
        }

        function interpretRule(rule) {
            if (rule.lift > 3) {
                return '極強關聯';
            } else if (rule.lift > 2) {
                return '強關聯';
            } else if (rule.lift > 1.5) {
                return '中等關聯';
            } else if (rule.lift > 1) {
                return '弱關聯';
            } else {
                return '無關聯';
            }
        }

        // ==============================================
        // 異常偵測 (Outlier Detection)
        // ==============================================

        function runOutlierDetection() {
            const variable = document.getElementById('outlierVariable').value;
            const useIQR = document.getElementById('outlierIQR').checked;
            const useZScore = document.getElementById('outlierZScore').checked;
            const useModifiedZ = document.getElementById('outlierModifiedZ').checked;
            const zThreshold = parseFloat(document.getElementById('outlierZThreshold').value);
            const iqrMultiplier = parseFloat(document.getElementById('outlierIQRMultiplier').value);
            const resultsDiv = document.getElementById('outlierResults');

            if (!variable) {
                resultsDiv.innerHTML = '<p class="text-red-600">請選擇要檢測的數值變數。</p>';
                return;
            }

            if (!useIQR && !useZScore && !useModifiedZ) {
                resultsDiv.innerHTML = '<p class="text-red-600">請至少選擇一種偵測方法。</p>';
                return;
            }

            resultsDiv.innerHTML = '<div class="loader"></div><p class="text-center text-gray-600 mt-2">正在執行異常偵測...</p>';

            try {
                // 提取數值資料
                const values = jsonData.map((row, idx) => ({
                    index: idx + 1,
                    value: row[variable]
                })).filter(item => typeof item.value === 'number' && !isNaN(item.value));

                if (values.length < 10) {
                    resultsDiv.innerHTML = '<p class="text-red-600">有效數據量不足（至少需要10筆）。</p>';
                    return;
                }

                const data = values.map(v => v.value);

                // 基本統計量
                const mean = ss.mean(data);
                const median = ss.median(data);
                const std = ss.standardDeviation(data);
                const q1 = ss.quantile(data, 0.25);
                const q3 = ss.quantile(data, 0.75);
                const iqr = q3 - q1;
                const min = ss.min(data);
                const max = ss.max(data);

                // 執行各種偵測方法
                const results = {
                    iqr: { outliers: [], method: 'IQR' },
                    zscore: { outliers: [], method: 'Z-Score' },
                    modifiedZ: { outliers: [], method: 'Modified Z-Score' }
                };

                // IQR 法
                if (useIQR) {
                    const lowerBound = q1 - iqrMultiplier * iqr;
                    const upperBound = q3 + iqrMultiplier * iqr;

                    values.forEach(item => {
                        if (item.value < lowerBound || item.value > upperBound) {
                            results.iqr.outliers.push(item);
                        }
                    });

                    results.iqr.lowerBound = lowerBound;
                    results.iqr.upperBound = upperBound;
                }

                // Z-Score 法
                if (useZScore) {
                    values.forEach(item => {
                        const z = (item.value - mean) / std;
                        if (Math.abs(z) > zThreshold) {
                            results.zscore.outliers.push({ ...item, zScore: z });
                        }
                    });
                }

                // Modified Z-Score 法
                if (useModifiedZ) {
                    const mad = calculateMAD(data, median);

                    values.forEach(item => {
                        const modifiedZ = 0.6745 * (item.value - median) / mad;
                        if (Math.abs(modifiedZ) > 3.5) {
                            results.modifiedZ.outliers.push({ ...item, modifiedZ: modifiedZ });
                        }
                    });
                }

                // 合併所有異常值 (去重)
                const allOutlierIndices = new Set();
                Object.values(results).forEach(result => {
                    result.outliers.forEach(outlier => allOutlierIndices.add(outlier.index));
                });

                // 顯示結果
                let html = '<div class="bg-white rounded-lg shadow-md p-6">';
                html += '<h3 class="text-xl font-bold mb-4 text-red-700">🎯 異常偵測結果</h3>';

                // 基本統計
                html += '<div class="bg-gray-50 p-4 rounded-lg mb-4">';
                html += '<h4 class="font-semibold mb-2">基本統計量</h4>';
                html += '<div class="grid md:grid-cols-4 gap-3 text-sm">';
                html += `<div><span class="text-gray-600">樣本數:</span> <span class="font-bold">${values.length}</span></div>`;
                html += `<div><span class="text-gray-600">平均值:</span> <span class="font-bold">${mean.toFixed(3)}</span></div>`;
                html += `<div><span class="text-gray-600">中位數:</span> <span class="font-bold">${median.toFixed(3)}</span></div>`;
                html += `<div><span class="text-gray-600">標準差:</span> <span class="font-bold">${std.toFixed(3)}</span></div>`;
                html += `<div><span class="text-gray-600">最小值:</span> <span class="font-bold">${min.toFixed(3)}</span></div>`;
                html += `<div><span class="text-gray-600">Q1:</span> <span class="font-bold">${q1.toFixed(3)}</span></div>`;
                html += `<div><span class="text-gray-600">Q3:</span> <span class="font-bold">${q3.toFixed(3)}</span></div>`;
                html += `<div><span class="text-gray-600">最大值:</span> <span class="font-bold">${max.toFixed(3)}</span></div>`;
                html += '</div></div>';

                // 異常值摘要
                html += '<div class="bg-red-50 p-4 rounded-lg mb-4">';
                html += '<h4 class="font-semibold mb-2">異常值摘要</h4>';
                html += '<div class="grid md:grid-cols-3 gap-4">';

                if (useIQR) {
                    html += '<div class="bg-white p-3 rounded border border-red-200">';
                    html += '<div class="text-sm text-gray-600">IQR 法</div>';
                    html += `<div class="text-2xl font-bold text-red-600">${results.iqr.outliers.length}</div>`;
                    html += `<div class="text-xs text-gray-500">${(results.iqr.outliers.length / values.length * 100).toFixed(1)}% of data</div>`;
                    html += '</div>';
                }

                if (useZScore) {
                    html += '<div class="bg-white p-3 rounded border border-blue-200">';
                    html += '<div class="text-sm text-gray-600">Z-Score 法</div>';
                    html += `<div class="text-2xl font-bold text-blue-600">${results.zscore.outliers.length}</div>`;
                    html += `<div class="text-xs text-gray-500">${(results.zscore.outliers.length / values.length * 100).toFixed(1)}% of data</div>`;
                    html += '</div>';
                }

                if (useModifiedZ) {
                    html += '<div class="bg-white p-3 rounded border border-green-200">';
                    html += '<div class="text-sm text-gray-600">Modified Z 法</div>';
                    html += `<div class="text-2xl font-bold text-green-600">${results.modifiedZ.outliers.length}</div>`;
                    html += `<div class="text-xs text-gray-500">${(results.modifiedZ.outliers.length / values.length * 100).toFixed(1)}% of data</div>`;
                    html += '</div>';
                }

                html += '</div>';
                html += `<div class="mt-3 text-sm"><span class="font-semibold">總異常值:</span> <span class="text-lg font-bold text-red-600">${allOutlierIndices.size}</span> 筆 (${(allOutlierIndices.size / values.length * 100).toFixed(1)}%)</div>`;
                html += '</div>';

                // 偵測方法詳情
                if (useIQR) {
                    html += '<h4 class="font-semibold mt-6 mb-2">🔴 IQR 法偵測結果</h4>';
                    html += '<div class="bg-red-50 p-3 rounded mb-4 text-sm">';
                    html += `<p><strong>偵測範圍:</strong> [${results.iqr.lowerBound.toFixed(3)}, ${results.iqr.upperBound.toFixed(3)}]</p>`;
                    html += `<p class="text-xs text-gray-600 mt-1">Q1 - ${iqrMultiplier}×IQR = ${results.iqr.lowerBound.toFixed(3)}, Q3 + ${iqrMultiplier}×IQR = ${results.iqr.upperBound.toFixed(3)}</p>`;
                    html += '</div>';

                    if (results.iqr.outliers.length > 0) {
                        html += displayOutlierTable(results.iqr.outliers, variable, 'IQR');
                    }
                }

                if (useZScore) {
                    html += '<h4 class="font-semibold mt-6 mb-2">🔵 Z-Score 法偵測結果</h4>';
                    html += '<div class="bg-blue-50 p-3 rounded mb-4 text-sm">';
                    html += `<p><strong>閾值:</strong> |Z-Score| > ${zThreshold}</p>`;
                    html += `<p class="text-xs text-gray-600 mt-1">超出平均值 ±${zThreshold} 個標準差</p>`;
                    html += '</div>';

                    if (results.zscore.outliers.length > 0) {
                        html += displayOutlierTable(results.zscore.outliers, variable, 'Z-Score');
                    }
                }

                if (useModifiedZ) {
                    html += '<h4 class="font-semibold mt-6 mb-2">🟢 Modified Z-Score 法偵測結果</h4>';
                    html += '<div class="bg-green-50 p-3 rounded mb-4 text-sm">';
                    html += `<p><strong>閾值:</strong> |Modified Z| > 3.5</p>`;
                    html += `<p class="text-xs text-gray-600 mt-1">使用中位數(MAD)，對極端值更穩健</p>`;
                    html += '</div>';

                    if (results.modifiedZ.outliers.length > 0) {
                        html += displayOutlierTable(results.modifiedZ.outliers, variable, 'Modified-Z');
                    }
                }

                // 視覺化
                html += '<div id="outlierBoxPlot" class="mt-6"></div>';
                html += '<div id="outlierScatterPlot" class="mt-6"></div>';

                // 處理建議
                html += '<div class="bg-yellow-50 p-4 rounded-lg mt-6">';
                html += '<h4 class="font-semibold mb-2">💡 處理建議</h4>';
                html += '<div class="text-sm text-gray-700 space-y-2">';

                if (allOutlierIndices.size > 0) {
                    const outlierRatio = allOutlierIndices.size / values.length;

                    if (outlierRatio > 0.1) {
                        html += '<p class="text-orange-600 font-semibold">⚠️ 異常值比例較高 (>10%)，建議檢查數據品質或調整閾值。</p>';
                    } else if (outlierRatio > 0.05) {
                        html += '<p class="text-yellow-600 font-semibold">注意: 異常值比例為 5-10%，屬於正常範圍。</p>';
                    } else {
                        html += '<p class="text-green-600 font-semibold">✅ 異常值比例正常 (<5%)。</p>';
                    }

                    html += '<p class="mt-2"><strong>處理選項:</strong></p>';
                    html += '<ul class="list-disc ml-6">';
                    html += '<li><strong>移除</strong>: 如確認為錯誤數據或極端離群值</li>';
                    html += '<li><strong>調整</strong>: 使用溫莎化(Winsorization)將極值限制在閾值範圍內</li>';
                    html += '<li><strong>分析</strong>: 單獨研究異常值，可能包含重要資訊</li>';
                    html += '<li><strong>保留</strong>: 如為真實數據且對分析有意義</li>';
                    html += '</ul>';
                } else {
                    html += '<p class="text-green-600 font-semibold">✅ 未偵測到異常值，數據品質良好。</p>';
                }

                html += '</div></div>';

                html += '</div>';

                resultsDiv.innerHTML = html;

                // 繪製圖表
                setTimeout(() => {
                    // 箱型圖
                    const boxTrace = {
                        y: data,
                        type: 'box',
                        name: variable,
                        marker: { color: '#ef4444' },
                        boxmean: 'sd'
                    };

                    Plotly.newPlot('outlierBoxPlot', [boxTrace], {
                        title: `${variable} 箱型圖 (標記異常值)`,
                        yaxis: { title: variable },
                        margin: { t: 40, b: 40, l: 60, r: 40 }
                    }, { responsive: true });

                    // 散點圖
                    const normalData = values.filter(v => !allOutlierIndices.has(v.index));
                    const outlierData = values.filter(v => allOutlierIndices.has(v.index));

                    const traces = [
                        {
                            x: normalData.map(v => v.index),
                            y: normalData.map(v => v.value),
                            mode: 'markers',
                            type: 'scatter',
                            name: '正常值',
                            marker: { color: '#10b981', size: 6 }
                        },
                        {
                            x: outlierData.map(v => v.index),
                            y: outlierData.map(v => v.value),
                            mode: 'markers',
                            type: 'scatter',
                            name: '異常值',
                            marker: { color: '#ef4444', size: 10, symbol: 'x' }
                        }
                    ];

                    Plotly.newPlot('outlierScatterPlot', traces, {
                        title: `${variable} 散點圖 (標記異常值)`,
                        xaxis: { title: '資料索引' },
                        yaxis: { title: variable },
                        margin: { t: 40, b: 60, l: 60, r: 40 }
                    }, { responsive: true });
                }, 100);

            } catch (error) {
                resultsDiv.innerHTML = `<p class="text-red-600">計算錯誤: ${error.message}</p>`;
                console.error(error);
            }
        }

        // 異常偵測輔助函數
        function calculateMAD(data, median) {
            const deviations = data.map(val => Math.abs(val - median));
            return ss.median(deviations);
        }

        function displayOutlierTable(outliers, variable, method) {
            let html = '<div class="overflow-x-auto mb-4">';
            html += '<table class="min-w-full divide-y divide-gray-200 border text-sm">';
            html += '<thead class="bg-gray-100">';
            html += '<tr>';
            html += '<th class="px-3 py-2 border">索引</th>';
            html += `<th class="px-3 py-2 border">${variable} 值</th>`;
            if (method === 'Z-Score') {
                html += '<th class="px-3 py-2 border">Z-Score</th>';
            } else if (method === 'Modified-Z') {
                html += '<th class="px-3 py-2 border">Modified Z</th>';
            }
            html += '<th class="px-3 py-2 border">偏離程度</th>';
            html += '</tr></thead><tbody>';

            // 只顯示前20筆
            outliers.slice(0, 20).forEach(outlier => {
                html += '<tr class="hover:bg-gray-50">';
                html += `<td class="px-3 py-2 border text-center">${outlier.index}</td>`;
                html += `<td class="px-3 py-2 border text-center font-semibold">${outlier.value.toFixed(3)}</td>`;

                if (method === 'Z-Score' && outlier.zScore !== undefined) {
                    const zColor = Math.abs(outlier.zScore) > 4 ? 'text-red-600' :
                        Math.abs(outlier.zScore) > 3.5 ? 'text-orange-600' : 'text-yellow-600';
                    html += `<td class="px-3 py-2 border text-center ${zColor} font-semibold">${outlier.zScore.toFixed(2)}</td>`;
                } else if (method === 'Modified-Z' && outlier.modifiedZ !== undefined) {
                    const zColor = Math.abs(outlier.modifiedZ) > 5 ? 'text-red-600' :
                        Math.abs(outlier.modifiedZ) > 4 ? 'text-orange-600' : 'text-yellow-600';
                    html += `<td class="px-3 py-2 border text-center ${zColor} font-semibold">${outlier.modifiedZ.toFixed(2)}</td>`;
                }

                const degree = Math.abs(outlier.zScore || outlier.modifiedZ || 0) > 4 ? '極端' :
                    Math.abs(outlier.zScore || outlier.modifiedZ || 0) > 3.5 ? '嚴重' : '中等';
                html += `<td class="px-3 py-2 border text-center text-xs">${degree}</td>`;
                html += '</tr>';
            });

            html += '</tbody></table>';

            if (outliers.length > 20) {
                html += `<p class="text-xs text-gray-500 mt-2">顯示前20筆異常值 (共${outliers.length}筆)</p>`;
            }

            html += '</div>';
            return html;
        }

        // --- Initial Setup ---

        // ═══════════════════════════════════════════════════════════════
        // 隨機森林任務切換函數
        // ═══════════════════════════════════════════════════════════════
        function switchRFTask(task) {
            const regPanel = document.getElementById('rfRegressionPanel');
            const clsPanel = document.getElementById('rfClassificationPanel');
            const regTab = document.getElementById('rfRegressionTab');
            const clsTab = document.getElementById('rfClassificationTab');

            if (task === 'regression') {
                if (regPanel) regPanel.style.display = 'block';
                if (clsPanel) clsPanel.style.display = 'none';
                if (regTab) {
                    regTab.classList.add('border-green-500', 'text-green-600');
                    regTab.classList.remove('text-gray-500');
                }
                if (clsTab) {
                    clsTab.classList.remove('border-green-500', 'text-green-600');
                    clsTab.classList.add('text-gray-500');
                }
            } else {
                if (regPanel) regPanel.style.display = 'none';
                if (clsPanel) clsPanel.style.display = 'block';
                if (clsTab) {
                    clsTab.classList.add('border-green-500', 'text-green-600');
                    clsTab.classList.remove('text-gray-500');
                }
                if (regTab) {
                    regTab.classList.remove('border-green-500', 'text-green-600');
                    regTab.classList.add('text-gray-500');
                }
            }
        }

        // ═══════════════════════════════════════════════════════════════
        // SVM / SVR 功能實現
        // ═══════════════════════════════════════════════════════════════

        function switchSVMTask(task) {
            const clsPanel = document.getElementById('svmClassificationPanel');
            const regPanel = document.getElementById('svrRegressionPanel');
            const clsTab = document.getElementById('svmClassificationTab');
            const regTab = document.getElementById('svrRegressionTab');

            if (task === 'classification') {
                if (clsPanel) clsPanel.style.display = 'block';
                if (regPanel) regPanel.style.display = 'none';
                if (clsTab) {
                    clsTab.classList.add('border-purple-500', 'text-purple-600');
                    clsTab.classList.remove('text-gray-500');
                }
                if (regTab) {
                    regTab.classList.remove('border-purple-500', 'text-purple-600');
                    regTab.classList.add('text-gray-500');
                }
            } else {
                if (clsPanel) clsPanel.style.display = 'none';
                if (regPanel) regPanel.style.display = 'block';
                if (regTab) {
                    regTab.classList.add('border-purple-500', 'text-purple-600');
                    regTab.classList.remove('text-gray-500');
                }
                if (clsTab) {
                    clsTab.classList.remove('border-purple-500', 'text-purple-600');
                    clsTab.classList.add('text-gray-500');
                }
            }
        }

        function updateSVMClsParams() {
            const kernel = document.getElementById('svmClsKernel').value;
            const gammaDiv = document.getElementById('svmClsGammaDiv');
            const degreeDiv = document.getElementById('svmClsDegreeDiv');
            if (kernel === 'rbf') {
                gammaDiv.classList.remove('hidden');
                degreeDiv.classList.add('hidden');
            } else if (kernel === 'polynomial') {
                gammaDiv.classList.add('hidden');
                degreeDiv.classList.remove('hidden');
            } else {
                gammaDiv.classList.add('hidden');
                degreeDiv.classList.add('hidden');
            }
        }

        function updateSVRRegParams() {
            const kernel = document.getElementById('svrRegKernel').value;
            const gammaDiv = document.getElementById('svrRegGammaDiv');
            if (kernel === 'rbf') {
                gammaDiv.classList.remove('hidden');
            } else {
                gammaDiv.classList.add('hidden');
            }
        }

        // Kernel functions
        function linearKernel(x1, x2) {
            let sum = 0;
            for (let i = 0; i < x1.length; i++) {
                sum += x1[i] * x2[i];
            }
            return sum;
        }

        function rbfKernel(x1, x2, gamma) {
            let sum = 0;
            for (let i = 0; i < x1.length; i++) {
                sum += Math.pow(x1[i] - x2[i], 2);
            }
            return Math.exp(-gamma * sum);
        }

        function polynomialKernel(x1, x2, degree, coef0 = 1) {
            return Math.pow(linearKernel(x1, x2) + coef0, degree);
        }

        // Simple SVM classifier using gradient descent on hinge loss
        function trainSVMClassifier(X, y, params) {
            const { kernel = 'rbf', C = 1.0, gamma = 0.1, degree = 3, maxIter = 500 } = params;
            const n = X.length;
            const nFeatures = X[0].length;
            
            // Normalize features
            const means = new Array(nFeatures).fill(0);
            const stds = new Array(nFeatures).fill(0);
            for (let j = 0; j < nFeatures; j++) {
                const col = X.map(row => row[j]);
                means[j] = col.reduce((a, b) => a + b, 0) / n;
                const variance = col.reduce((sum, v) => sum + Math.pow(v - means[j], 2), 0) / n;
                stds[j] = Math.sqrt(variance) || 1;
            }
            const X_norm = X.map(row => row.map((v, j) => (v - means[j]) / stds[j]));

            // Get unique classes
            const classes = [...new Set(y)].sort((a, b) => a - b);
            
            // For binary classification
            if (classes.length === 2) {
                const y_binary = y.map(yi => yi === classes[0] ? -1 : 1);
                
                // Initialize weights
                let w = new Array(nFeatures).fill(0);
                let b = 0;
                const lr = 0.01;

                for (let iter = 0; iter < maxIter; iter++) {
                    for (let i = 0; i < n; i++) {
                        const xi = X_norm[i];
                        const yi = y_binary[i];
                        const margin = yi * (linearKernel(w, xi) + b);
                        
                        if (margin < 1) {
                            // Misclassified or within margin
                            for (let j = 0; j < nFeatures; j++) {
                                w[j] = w[j] - lr * (w[j] / C - yi * xi[j]);
                            }
                            b = b + lr * yi;
                        } else {
                            // Correctly classified
                            for (let j = 0; j < nFeatures; j++) {
                                w[j] = w[j] - lr * (w[j] / C);
                            }
                        }
                    }
                }
                
                return { type: 'binary', w, b, classes, means, stds, kernel, gamma, degree };
            } else {
                // One-vs-Rest for multi-class
                const models = classes.map(cls => {
                    const y_binary = y.map(yi => yi === cls ? 1 : -1);
                    let w = new Array(nFeatures).fill(0);
                    let b = 0;
                    const lr = 0.01;

                    for (let iter = 0; iter < maxIter; iter++) {
                        for (let i = 0; i < n; i++) {
                            const xi = X_norm[i];
                            const yi = y_binary[i];
                            const margin = yi * (linearKernel(w, xi) + b);
                            
                            if (margin < 1) {
                                for (let j = 0; j < nFeatures; j++) {
                                    w[j] = w[j] - lr * (w[j] / C - yi * xi[j]);
                                }
                                b = b + lr * yi;
                            } else {
                                for (let j = 0; j < nFeatures; j++) {
                                    w[j] = w[j] - lr * (w[j] / C);
                                }
                            }
                        }
                    }
                    return { cls, w, b };
                });
                
                return { type: 'multiclass', models, classes, means, stds, kernel, gamma, degree };
            }
        }

        function predictSVMClassifier(model, X) {
            const { means, stds, classes } = model;
            const X_norm = X.map(row => row.map((v, j) => (v - means[j]) / stds[j]));
            
            if (model.type === 'binary') {
                const { w, b } = model;
                return X_norm.map(xi => {
                    const score = linearKernel(w, xi) + b;
                    return score < 0 ? classes[0] : classes[1];
                });
            } else {
                return X_norm.map(xi => {
                    let bestClass = classes[0];
                    let bestScore = -Infinity;
                    model.models.forEach(m => {
                        const score = linearKernel(m.w, xi) + m.b;
                        if (score > bestScore) {
                            bestScore = score;
                            bestClass = m.cls;
                        }
                    });
                    return bestClass;
                });
            }
        }

        // SVR using Ridge Regression (closed-form solution for robust results)
        function trainSVRRegressor(X, y, params) {
            const { C = 1.0, epsilon = 0.1 } = params;
            const n = X.length;
            const nFeatures = X[0].length;
            
            // Normalize features
            const means = new Array(nFeatures).fill(0);
            const stds = new Array(nFeatures).fill(0);
            for (let j = 0; j < nFeatures; j++) {
                const col = X.map(row => row[j]);
                means[j] = col.reduce((a, b) => a + b, 0) / n;
                const variance = col.reduce((sum, v) => sum + Math.pow(v - means[j], 2), 0) / n;
                stds[j] = Math.sqrt(variance) || 1;
            }
            const X_norm = X.map(row => row.map((v, j) => (v - means[j]) / stds[j]));
            
            // Normalize y
            const yMean = y.reduce((a, b) => a + b, 0) / n;
            const yStd = Math.sqrt(y.reduce((sum, v) => sum + Math.pow(v - yMean, 2), 0) / n) || 1;
            const y_norm = y.map(v => (v - yMean) / yStd);
            
            // Add bias term to X_norm (augmented matrix)
            const X_aug = X_norm.map(row => [1, ...row]); // [1, x1, x2, ...]
            const p = nFeatures + 1; // including bias
            
            // Ridge Regression closed-form: w = (X'X + λI)^(-1) X'y
            // λ = 1/C (regularization)
            const lambda = 1 / C;
            
            // Compute X'X
            const XtX = Array(p).fill(0).map(() => Array(p).fill(0));
            for (let i = 0; i < p; i++) {
                for (let j = 0; j < p; j++) {
                    let sum = 0;
                    for (let k = 0; k < n; k++) {
                        sum += X_aug[k][i] * X_aug[k][j];
                    }
                    XtX[i][j] = sum;
                }
            }
            
            // Add λI (regularization), but not on bias term
            for (let i = 1; i < p; i++) {
                XtX[i][i] += lambda;
            }
            
            // Compute X'y
            const Xty = Array(p).fill(0);
            for (let i = 0; i < p; i++) {
                let sum = 0;
                for (let k = 0; k < n; k++) {
                    sum += X_aug[k][i] * y_norm[k];
                }
                Xty[i] = sum;
            }
            
            // Solve using simple Gaussian elimination
            const A = XtX.map(row => [...row]); // Copy
            const b_vec = [...Xty];
            
            // Forward elimination
            for (let i = 0; i < p; i++) {
                // Find pivot
                let maxRow = i;
                for (let k = i + 1; k < p; k++) {
                    if (Math.abs(A[k][i]) > Math.abs(A[maxRow][i])) {
                        maxRow = k;
                    }
                }
                [A[i], A[maxRow]] = [A[maxRow], A[i]];
                [b_vec[i], b_vec[maxRow]] = [b_vec[maxRow], b_vec[i]];
                
                // Eliminate
                for (let k = i + 1; k < p; k++) {
                    if (A[i][i] !== 0) {
                        const c = A[k][i] / A[i][i];
                        for (let j = i; j < p; j++) {
                            A[k][j] -= c * A[i][j];
                        }
                        b_vec[k] -= c * b_vec[i];
                    }
                }
            }
            
            // Back substitution
            const solution = Array(p).fill(0);
            for (let i = p - 1; i >= 0; i--) {
                let sum = b_vec[i];
                for (let j = i + 1; j < p; j++) {
                    sum -= A[i][j] * solution[j];
                }
                solution[i] = A[i][i] !== 0 ? sum / A[i][i] : 0;
            }
            
            // Extract bias and weights
            const b = solution[0];
            const w = solution.slice(1);
            
            return { w, b, means, stds, yMean, yStd, epsilon };
        }


        function predictSVRRegressor(model, X) {
            const { w, b, means, stds, yMean, yStd } = model;
            const X_norm = X.map(row => row.map((v, j) => (v - means[j]) / stds[j]));
            return X_norm.map(xi => {
                const pred_norm = linearKernel(w, xi) + b;
                return pred_norm * yStd + yMean;
            });
        }

        // Global SVM model storage for prediction
        let svmTrainedModel = null;
        let svmModelInfo = null;

        // Permutation Importance for SVM/SVR
        function computeSVMPermutationImportance(model, X, y, xVars, predictFn, scoreFn, nRepeats = 5) {
            const baseScore = scoreFn(y, predictFn(model, X));
            const importance = [];

            for (let j = 0; j < xVars.length; j++) {
                let totalDrop = 0;
                for (let r = 0; r < nRepeats; r++) {
                    // Shuffle column j
                    const X_perm = X.map(row => [...row]);
                    const colVals = X_perm.map(row => row[j]);
                    // Fisher-Yates shuffle
                    for (let i = colVals.length - 1; i > 0; i--) {
                        const k = Math.floor(Math.random() * (i + 1));
                        [colVals[i], colVals[k]] = [colVals[k], colVals[i]];
                    }
                    X_perm.forEach((row, idx) => row[j] = colVals[idx]);

                    const permScore = scoreFn(y, predictFn(model, X_perm));
                    totalDrop += baseScore - permScore;
                }
                importance.push({
                    feature: xVars[j],
                    importance: totalDrop / nRepeats
                });
            }

            // Sort by importance descending
            importance.sort((a, b) => b.importance - a.importance);

            // Normalize to percentage
            const total = importance.reduce((s, d) => s + Math.max(0, d.importance), 0);
            if (total > 0) {
                importance.forEach(d => d.normalized = Math.max(0, d.importance) / total * 100);
            } else {
                importance.forEach(d => d.normalized = 100 / importance.length);
            }

            return importance;
        }

        // Score functions
        function accuracyScore(yTrue, yPred) {
            let correct = 0;
            yTrue.forEach((y, i) => { if (y === yPred[i]) correct++; });
            return correct / yTrue.length;
        }

        function r2Score(yTrue, yPred) {
            const yMean = yTrue.reduce((a, b) => a + b, 0) / yTrue.length;
            let ssRes = 0, ssTot = 0;
            yTrue.forEach((y, i) => {
                ssRes += Math.pow(y - yPred[i], 2);
                ssTot += Math.pow(y - yMean, 2);
            });
            return ssTot > 0 ? 1 - ssRes / ssTot : 0;
        }

        function showSVMPredictionPanel(xVars) {
            const panel = document.getElementById('svmPredictionPanel');
            const inputsDiv = document.getElementById('svmPredictionInputs');
            const resultDiv = document.getElementById('svmPredictionResult');
            
            if (!panel || !inputsDiv) return;

            // Generate input fields for each feature
            inputsDiv.innerHTML = xVars.map((varName, idx) => {
                // Get min/max/mean from data for placeholder
                const values = jsonData.map(row => row[varName]).filter(v => typeof v === 'number' && !isNaN(v));
                const mean = values.length > 0 ? (values.reduce((a, b) => a + b, 0) / values.length).toFixed(2) : '';
                
                return `
                    <div class="flex flex-col">
                        <label class="text-sm font-medium text-gray-700 mb-1">${varName}</label>
                        <input type="number" step="any" id="svmInput_${idx}" 
                            placeholder="${mean}" value="${mean}"
                            class="border border-gray-300 rounded-lg px-3 py-2 text-sm focus:ring-2 focus:ring-purple-500 focus:border-purple-500">
                    </div>
                `;
            }).join('');

            resultDiv.innerHTML = '';
            panel.classList.remove('hidden');
        }

        function runSVMPrediction() {
            const resultDiv = document.getElementById('svmPredictionResult');
            
            if (!svmTrainedModel || !svmModelInfo) {
                resultDiv.innerHTML = '<span class="text-red-600">請先訓練模型</span>';
                return;
            }

            const { type, xVars, yLabels, yMap } = svmModelInfo;

            // Collect input values
            const inputValues = [];
            for (let idx = 0; idx < xVars.length; idx++) {
                const varName = xVars[idx];
                const input = document.getElementById(`svmInput_${idx}`);
                if (!input || input.value === '') {
                    resultDiv.innerHTML = '<span class="text-red-600">請填寫所有特徵值</span>';
                    return;
                }
                const val = parseFloat(input.value);
                if (isNaN(val)) {
                    resultDiv.innerHTML = `<span class="text-red-600">${varName} 必須是數值</span>`;
                    return;
                }
                inputValues.push(val);
            }

            try {
                if (type === 'classification') {
                    const prediction = predictSVMClassifier(svmTrainedModel, [inputValues]);
                    const predictedLabel = yLabels[prediction[0]];
                    resultDiv.innerHTML = `<span class="text-purple-700">📊 預測類別：<strong class="text-2xl">${predictedLabel}</strong></span>`;
                } else {
                    const prediction = predictSVRRegressor(svmTrainedModel, [inputValues]);
                    resultDiv.innerHTML = `<span class="text-purple-700">📊 預測值：<strong class="text-2xl">${prediction[0].toFixed(4)}</strong></span>`;
                }
            } catch (err) {
                resultDiv.innerHTML = `<span class="text-red-600">預測失敗：${err.message}</span>`;
            }
        }

        function runSVMClassification() {
            const yVar = document.getElementById('svmClsY').value;
            let xVars = Array.from(document.getElementById('svmClsX').selectedOptions).map(o => o.value);
            const resultsDiv = document.getElementById('svmResults');
            const progressSpan = document.getElementById('svmClsProgress');
            
            resultsDiv.innerHTML = '';
            
            if (!yVar || xVars.length === 0) {
                resultsDiv.innerHTML = '<p class="text-red-600">請選擇 Y 變數和至少一個 X 變數。</p>';
                return;
            }

            // Check for Y in X and filter it out
            if (xVars.includes(yVar)) {
                xVars = xVars.filter(v => v !== yVar);
                if (xVars.length === 0) {
                    resultsDiv.innerHTML = '<p class="text-red-600">錯誤：目標變數 (Y) 不能同時作為特徵變數 (X)。請選擇其他特徵變數。</p>';
                    return;
                }
                resultsDiv.innerHTML = `<p class="text-orange-600 mb-2">⚠️ 已自動移除 X 中與 Y 重複的變數「${yVar}」</p>`;
            }

            progressSpan.textContent = '訓練中...';

            const kernel = document.getElementById('svmClsKernel').value;
            const C = parseFloat(document.getElementById('svmClsC').value) || 1.0;
            const gamma = parseFloat(document.getElementById('svmClsGamma').value) || 0.1;
            const degree = parseInt(document.getElementById('svmClsDegree').value) || 3;

            // Prepare data
            const validRows = jsonData.filter(row => {
                if (row[yVar] === null || row[yVar] === undefined) return false;
                return xVars.every(x => typeof row[x] === 'number' && !isNaN(row[x]));
            });

            if (validRows.length < 10) {
                resultsDiv.innerHTML = '<p class="text-red-600">有效資料不足（需至少10筆）。</p>';
                progressSpan.textContent = '';
                return;
            }

            const X = validRows.map(row => xVars.map(x => row[x]));
            const yRaw = validRows.map(row => row[yVar]);
            const uniqueY = [...new Set(yRaw)];
            const yMap = Object.fromEntries(uniqueY.map((v, i) => [v, i]));
            const y = yRaw.map(v => yMap[v]);
            const yLabels = uniqueY;

            setTimeout(() => {
                try {
                    const model = trainSVMClassifier(X, y, { kernel, C, gamma, degree });
                    const predictions = predictSVMClassifier(model, X);
                    // Calculate accuracy
                    let correct = 0;
                    predictions.forEach((pred, i) => {
                        if (pred === y[i]) correct++;
                    });
                    const accuracy = correct / predictions.length;

                    // Confusion matrix
                    const cm = {};
                    uniqueY.forEach(a => {
                        cm[a] = {};
                        uniqueY.forEach(b => cm[a][b] = 0);
                    });
                    predictions.forEach((pred, i) => {
                        const actual = yLabels[y[i]];
                        const predicted = yLabels[pred];
                        cm[actual][predicted]++;
                    });

                    // Calculate Precision, Recall, F1 for each class
                    const classMetrics = yLabels.map((cls, idx) => {
                        let tp = 0, fp = 0, fn = 0;
                        predictions.forEach((pred, i) => {
                            if (pred === idx && y[i] === idx) tp++;
                            else if (pred === idx && y[i] !== idx) fp++;
                            else if (pred !== idx && y[i] === idx) fn++;
                        });
                        const precision = tp + fp > 0 ? tp / (tp + fp) : 0;
                        const recall = tp + fn > 0 ? tp / (tp + fn) : 0;
                        const f1 = precision + recall > 0 ? 2 * precision * recall / (precision + recall) : 0;
                        return { cls, precision, recall, f1 };
                    });

                    // Macro average
                    const macroPrecision = classMetrics.reduce((s, m) => s + m.precision, 0) / classMetrics.length;
                    const macroRecall = classMetrics.reduce((s, m) => s + m.recall, 0) / classMetrics.length;
                    const macroF1 = classMetrics.reduce((s, m) => s + m.f1, 0) / classMetrics.length;

                    let html = `
                        <h3 class="text-lg font-semibold mb-3">📊 SVM 分類結果</h3>
                        <div class="grid md:grid-cols-2 gap-4 mb-4">
                            <div class="bg-purple-50 p-4 rounded-lg">
                                <h4 class="font-semibold mb-2">📈 模型效能</h4>
                                <ul class="text-sm space-y-1">
                                    <li>• Accuracy (準確率)：<strong>${(accuracy * 100).toFixed(2)}%</strong> <span class="text-gray-500 text-xs">- 整體預測正確的比例</span></li>
                                    <li>• Precision (精確率)：<strong>${(macroPrecision * 100).toFixed(2)}%</strong> <span class="text-gray-500 text-xs">- 預測為某類別中，真正屬於該類別的比例 (Macro Avg)</span></li>
                                    <li>• Recall (召回率)：<strong>${(macroRecall * 100).toFixed(2)}%</strong> <span class="text-gray-500 text-xs">- 實際為某類別中，被正確預測出來的比例 (Macro Avg)</span></li>
                                    <li>• F1-Score：<strong>${(macroF1 * 100).toFixed(2)}%</strong> <span class="text-gray-500 text-xs">- Precision 與 Recall 的調和平均數，綜合評估指標</span></li>
                                </ul>
                                <div class="mt-2 pt-2 border-t border-purple-200 text-xs text-gray-600">
                                    <p>• 訓練樣本：${X.length} 筆 | 特徵：${xVars.length} 個 | 類別：${uniqueY.length} 類 | 核函數：${kernel.toUpperCase()}</p>
                                </div>
                            </div>
                            <div class="bg-gray-50 p-4 rounded-lg">
                                <h4 class="font-semibold mb-2">📋 混淆矩陣</h4>
                                <table class="text-xs w-full">
                                    <tr><th class="border p-1"></th>${yLabels.map(l => `<th class="border p-1 bg-gray-100">${l}</th>`).join('')}</tr>
                                    ${yLabels.map(actual => `
                                        <tr>
                                            <td class="border p-1 bg-gray-100 font-semibold">${actual}</td>
                                            ${yLabels.map(pred => `<td class="border p-1 text-center ${pred === actual ? 'bg-green-100' : ''}">${cm[actual][pred]}</td>`).join('')}
                                        </tr>
                                    `).join('')}
                                </table>
                            </div>
                        </div>
                        <div id="svmImportancePlot" class="mt-4"></div>
                    `;
                    resultsDiv.innerHTML = html;

                    // Save model for prediction
                    svmTrainedModel = model;
                    svmModelInfo = { type: 'classification', xVars, yLabels, yMap };
                    showSVMPredictionPanel(xVars);

                    // Calculate and plot permutation importance
                    progressSpan.textContent = '計算特徵重要性...';
                    setTimeout(() => {
                        try {
                            const importance = computeSVMPermutationImportance(
                                model, X, y, xVars, predictSVMClassifier, accuracyScore
                            );
                            
                            Plotly.newPlot('svmImportancePlot', [{
                                x: importance.map(d => d.normalized),
                                y: importance.map(d => d.feature),
                                type: 'bar',
                                orientation: 'h',
                                marker: { color: 'rgb(147, 51, 234)' }
                            }], {
                                title: '特徵重要性 (Permutation Importance)',
                                xaxis: { title: '重要性 (%)' },
                                yaxis: { automargin: true },
                                margin: { l: 120 }
                            }, { responsive: true });

                            progressSpan.textContent = '✅ 完成';
                        } catch (e) {
                            console.error('Importance calculation error:', e);
                            progressSpan.textContent = '✅ 完成 (重要性計算跳過)';
                        }
                    }, 100);
                } catch (err) {
                    resultsDiv.innerHTML = `<p class="text-red-600">訓練失敗：${err.message}</p>`;
                    progressSpan.textContent = '';
                }
            }, 50);
        }

        function runSVRRegression() {
            const yVar = document.getElementById('svrRegY').value;
            let xVars = Array.from(document.getElementById('svrRegX').selectedOptions).map(o => o.value);
            const resultsDiv = document.getElementById('svmResults');
            const progressSpan = document.getElementById('svrRegProgress');
            
            resultsDiv.innerHTML = '';
            
            if (!yVar || xVars.length === 0) {
                resultsDiv.innerHTML = '<p class="text-red-600">請選擇 Y 變數和至少一個 X 變數。</p>';
                return;
            }

            // Check for Y in X and filter it out
            if (xVars.includes(yVar)) {
                xVars = xVars.filter(v => v !== yVar);
                if (xVars.length === 0) {
                    resultsDiv.innerHTML = '<p class="text-red-600">錯誤：目標變數 (Y) 不能同時作為特徵變數 (X)。請選擇其他特徵變數。</p>';
                    return;
                }
                resultsDiv.innerHTML = `<p class="text-orange-600 mb-2">⚠️ 已自動移除 X 中與 Y 重複的變數「${yVar}」</p>`;
            }

            progressSpan.textContent = '訓練中...';

            const C = parseFloat(document.getElementById('svrRegC').value) || 1.0;
            const epsilon = parseFloat(document.getElementById('svrRegEpsilon').value) || 0.1;
            const gamma = parseFloat(document.getElementById('svrRegGamma').value) || 0.1;

            // Prepare data
            const validRows = jsonData.filter(row => {
                if (typeof row[yVar] !== 'number' || isNaN(row[yVar])) return false;
                return xVars.every(x => typeof row[x] === 'number' && !isNaN(row[x]));
            });

            if (validRows.length < 10) {
                resultsDiv.innerHTML = '<p class="text-red-600">有效資料不足（需至少10筆）。</p>';
                progressSpan.textContent = '';
                return;
            }

            const X = validRows.map(row => xVars.map(x => row[x]));
            const y = validRows.map(row => row[yVar]);

            setTimeout(() => {
                try {
                    const model = trainSVRRegressor(X, y, { C, epsilon, gamma });
                    const predictions = predictSVRRegressor(model, X);
                    
                    // Calculate metrics
                    const yMean = y.reduce((a, b) => a + b, 0) / y.length;
                    let ssRes = 0, ssTot = 0, sumAbsError = 0;
                    predictions.forEach((pred, i) => {
                        ssRes += Math.pow(y[i] - pred, 2);
                        ssTot += Math.pow(y[i] - yMean, 2);
                        sumAbsError += Math.abs(y[i] - pred);
                    });
                    const r2 = 1 - ssRes / ssTot;
                    const rmse = Math.sqrt(ssRes / y.length);
                    const mae = sumAbsError / y.length;

                    let html = `
                        <h3 class="text-lg font-semibold mb-3">📊 SVR 迴歸結果</h3>
                        <div class="grid md:grid-cols-2 gap-4 mb-4">
                            <div class="bg-purple-50 p-4 rounded-lg">
                                <h4 class="font-semibold mb-2">📈 模型效能</h4>
                                <ul class="text-sm space-y-1">
                                    <li>• R² 決定係數：<strong>${r2.toFixed(4)}</strong> ${r2 > 0.8 ? '✅' : r2 > 0.5 ? '⚠️' : '❌'}</li>
                                    <li>• RMSE：<strong>${rmse.toFixed(4)}</strong></li>
                                    <li>• MAE：<strong>${mae.toFixed(4)}</strong></li>
                                    <li>• 訓練樣本：${X.length} 筆</li>
                                    <li>• 特徵數量：${xVars.length} 個</li>
                                </ul>
                            </div>
                            <div class="bg-gray-50 p-4 rounded-lg">
                                <h4 class="font-semibold mb-2">⚙️ 參數設定</h4>
                                <ul class="text-sm space-y-1">
                                    <li>• C (正則化)：${C}</li>
                                    <li>• ε (容忍帶)：${epsilon}</li>
                                </ul>
                            </div>
                        </div>
                        <div id="svrPredPlot" class="mt-4"></div>
                        <div id="svrImportancePlot" class="mt-4"></div>
                    `;
                    resultsDiv.innerHTML = html;

                    // Save model for prediction
                    svmTrainedModel = model;
                    svmModelInfo = { type: 'regression', xVars, yVar };
                    showSVMPredictionPanel(xVars);

                    // Plot actual vs predicted
                    Plotly.newPlot('svrPredPlot', [{
                        x: y,
                        y: predictions,
                        mode: 'markers',
                        type: 'scatter',
                        name: '預測值',
                        marker: { color: 'purple', size: 6 }
                    }, {
                        x: [Math.min(...y), Math.max(...y)],
                        y: [Math.min(...y), Math.max(...y)],
                        mode: 'lines',
                        name: '理想線',
                        line: { color: 'gray', dash: 'dash' }
                    }], {
                        title: '實際值 vs 預測值',
                        xaxis: { title: '實際值' },
                        yaxis: { title: '預測值' }
                    }, { responsive: true });

                    // Calculate and plot permutation importance
                    progressSpan.textContent = '計算特徵重要性...';
                    setTimeout(() => {
                        try {
                            const importance = computeSVMPermutationImportance(
                                model, X, y, xVars, predictSVRRegressor, r2Score
                            );
                            
                            Plotly.newPlot('svrImportancePlot', [{
                                x: importance.map(d => d.normalized),
                                y: importance.map(d => d.feature),
                                type: 'bar',
                                orientation: 'h',
                                marker: { color: 'rgb(147, 51, 234)' }
                            }], {
                                title: '特徵重要性 (Permutation Importance)',
                                xaxis: { title: '重要性 (%)' },
                                yaxis: { automargin: true },
                                margin: { l: 120 }
                            }, { responsive: true });

                            progressSpan.textContent = '✅ 完成';
                        } catch (e) {
                            console.error('Importance calculation error:', e);
                            progressSpan.textContent = '✅ 完成 (重要性計算跳過)';
                        }
                    }, 100);
                } catch (err) {
                    resultsDiv.innerHTML = `<p class="text-red-600">訓練失敗：${err.message}</p>`;
                    progressSpan.textContent = '';
                }
            }, 50);
        }

        document.addEventListener('DOMContentLoaded', setupEventListeners);
        /******************** 階層式集群 – 主流程 ********************/

        function runHierarchical() {
            const varSelect = document.getElementById('hierVariables');
            const selectedVars = Array.from(varSelect.selectedOptions).map(o => o.value);
            const msgEl = document.getElementById('hierMessage');
            const dendroDiv = document.getElementById('hierDendrogram');
            const heatmapDiv = document.getElementById('hierHeatmap');
            const silDiv = document.getElementById('hierSilhouette');
            const clusterSection = document.getElementById('hierClusterSection');

            msgEl.textContent = '';
            dendroDiv.innerHTML = '';
            heatmapDiv.innerHTML = '';
            silDiv.innerHTML = '';
            clusterSection.classList.add('hidden');
            hierarchicalState = null;

            if (!jsonData || jsonData.length === 0) {
                msgEl.textContent = '請先上傳並載入資料。';
                msgEl.classList.remove('text-gray-500');
                msgEl.classList.add('text-red-600');
                return;
            }
            if (selectedVars.length === 0) {
                msgEl.textContent = '請至少選擇一個用於分群的變數。';
                msgEl.classList.remove('text-gray-500');
                msgEl.classList.add('text-red-600');
                return;
            }

            // 樣本篩選與上限控制（<1000 筆）
            let dataRows = jsonData.map((row, idx) => ({ row, idx }));
            const maxSamples = 1000;
            if (dataRows.length > maxSamples) {
                dataRows = dataRows.slice(0, maxSamples);
                msgEl.textContent = `樣本數 ${jsonData.length} 筆，為避免瀏覽器凍結，僅取前 ${maxSamples} 筆進行階層式集群分析。`;
                msgEl.classList.remove('text-red-600');
                msgEl.classList.add('text-gray-500');
            }

            const n = dataRows.length;
            if (n < 2) {
                msgEl.textContent = '有效樣本數不足，無法進行集群分析。';
                msgEl.classList.remove('text-gray-500');
                msgEl.classList.add('text-red-600');
                return;
            }

            // 判斷每個變數的型態（沿用 numericHeaders / categoricalHeaders）
            const variableTypes = {};
            selectedVars.forEach(v => {
                variableTypes[v] = numericHeaders.includes(v) ? 'numeric' : 'categorical';
            });
            const typeSet = new Set(Object.values(variableTypes));
            let dataType = 'mixed';
            if (typeSet.size === 1 && typeSet.has('numeric')) dataType = 'numeric';
            else if (typeSet.size === 1 && typeSet.has('categorical')) dataType = 'categorical';

            // 距離方法選擇
            const chosenMetric = document.getElementById('hierDistanceMetric').value;
            const p = parseFloat(document.getElementById('hierMinkowskiP').value) || 3;
            let metric = chosenMetric;
            let metricNote = '';

            if (chosenMetric === 'auto') {
                if (dataType === 'numeric') metric = 'euclidean';
                else if (dataType === 'categorical') metric = 'hamming';
                else metric = 'gower';
            } else {
                if (dataType === 'mixed' && chosenMetric !== 'gower') {
                    metricNote = '資料為混合型，距離已自動改用 Gower。';
                    metric = 'gower';
                }
                if (dataType === 'categorical' && !['hamming', 'jaccard', 'gower'].includes(chosenMetric)) {
                    metricNote = '資料為類別型，距離已自動改用 Hamming。';
                    metric = 'hamming';
                }
            }

            // 計算距離矩陣
            const distMatrix = computeHierarchicalDistanceMatrix(dataRows, selectedVars, variableTypes, {
                metric,
                minkowskiP: p
            });

            // Linkage 方法
            let linkage = document.getElementById('hierLinkage').value;
            const numericOnlyWithEuclidean = (dataType === 'numeric' && metric === 'euclidean');

            if ((linkage === 'ward' || linkage === 'centroid') && !numericOnlyWithEuclidean) {
                alert('Ward 與重心法 (Centroid) 目前僅支援「全部為數值變數且距離為 Euclidean」的情境，系統已自動改用 Average Linkage。');
                linkage = 'average';
            }

            // 特徵矩陣（僅在 numeric + Euclidean + Ward/Centroid 時會用到）
            let featureMatrix = null;
            if (numericOnlyWithEuclidean) {
                featureMatrix = dataRows.map(({ row }) => selectedVars.map(v => row[v]));
            }

            // 執行凝聚式階層集群
            const clusterResult = agglomerativeClusteringFromDistance(distMatrix, linkage, {
                featureMatrix: (linkage === 'ward' || linkage === 'centroid') ? featureMatrix : null
            });

            hierarchicalState = {
                dataRows,
                selectedVars,
                variableTypes,
                dataType,
                metric,
                linkage,
                distMatrix,
                ...clusterResult
            };

            // 設定預設群集數（啟動 Slider）
            const defaultK = Math.min(5, Math.max(2, Math.floor(Math.sqrt(n))));
            const slider = document.getElementById('hierClusterCount');
            slider.max = Math.min(10, n);
            slider.min = 2;
            slider.value = defaultK;
            document.getElementById('hierClusterCountLabel').textContent = defaultK.toString();
            clusterSection.classList.remove('hidden');

            if (metricNote) {
                msgEl.textContent = metricNote;
                msgEl.classList.remove('text-red-600');
                msgEl.classList.add('text-gray-500');
            } else {
                msgEl.textContent = `距離: ${metric}, Linkage: ${linkage}, 樣本數: ${n}`;
                msgEl.classList.remove('text-red-600');
                msgEl.classList.add('text-gray-500');
            }

            updateHierarchicalClusterViews(defaultK);
        }

        /******************** 距離矩陣計算（含 Gower） ********************/

        function computeHierarchicalDistanceMatrix(dataRows, vars, varTypes, options) {
            const n = dataRows.length;
            const metric = options.metric || 'euclidean';
            const p = options.minkowskiP || 3;

            // Gower: 預先計算各數值變數的 range
            const numericRanges = {};
            if (metric === 'gower') {
                vars.forEach(v => {
                    if (varTypes[v] === 'numeric') {
                        const vals = dataRows
                            .map(({ row }) => row[v])
                            .filter(val => typeof val === 'number' && !isNaN(val));
                        if (vals.length > 0) {
                            const min = Math.min(...vals);
                            const max = Math.max(...vals);
                            numericRanges[v] = { min, max, range: (max - min) };
                        } else {
                            numericRanges[v] = { min: 0, max: 0, range: 0 };
                        }
                    }
                });
            }

            const distMatrix = Array.from({ length: n }, () => Array(n).fill(0));

            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    const rowI = dataRows[i].row;
                    const rowJ = dataRows[j].row;
                    let d = 0;

                    if (metric === 'euclidean' || metric === 'manhattan' || metric === 'minkowski') {
                        const diffs = [];
                        vars.forEach(v => {
                            const vi = rowI[v];
                            const vj = rowJ[v];
                            if (typeof vi === 'number' && typeof vj === 'number' && !isNaN(vi) && !isNaN(vj)) {
                                diffs.push({ vi, vj });
                            }
                        });
                        if (diffs.length === 0) {
                            d = 0;
                        } else {
                            if (metric === 'euclidean') {
                                let sumSq = 0;
                                diffs.forEach(({ vi, vj }) => {
                                    const diff = vi - vj;
                                    sumSq += diff * diff;
                                });
                                d = Math.sqrt(sumSq);
                            } else if (metric === 'manhattan') {
                                let sum = 0;
                                diffs.forEach(({ vi, vj }) => {
                                    sum += Math.abs(vi - vj);
                                });
                                d = sum;
                            } else { // minkowski
                                let sumP = 0;
                                diffs.forEach(({ vi, vj }) => {
                                    sumP += Math.pow(Math.abs(vi - vj), p);
                                });
                                d = Math.pow(sumP, 1 / p);
                            }
                        }
                    } else if (metric === 'hamming' || metric === 'jaccard') {
                        let matches = 0, total = 0;
                        vars.forEach(v => {
                            const vi = rowI[v];
                            const vj = rowJ[v];
                            if (vi == null || vj == null || vi === '' || vj === '') return;
                            total++;
                            if (vi === vj) matches++;
                        });
                        if (total === 0) d = 0;
                        else {
                            const dissim = (total - matches) / total;
                            d = dissim; // 此處 Hamming / Jaccard 對於單一類別欄位集合下等價
                        }
                    } else if (metric === 'gower') {
                        let sumSim = 0, count = 0;
                        vars.forEach(v => {
                            const vi = rowI[v];
                            const vj = rowJ[v];
                            if ((vi == null || vi === '') && (vj == null || vj === '')) return;

                            if (varTypes[v] === 'numeric') {
                                const rangeObj = numericRanges[v];
                                if (!rangeObj || rangeObj.range === 0 ||
                                    typeof vi !== 'number' || typeof vj !== 'number' ||
                                    isNaN(vi) || isNaN(vj)) return;
                                const diff = Math.abs(vi - vj);
                                const sij = 1 - diff / rangeObj.range;
                                sumSim += sij;
                                count++;
                            } else { // categorical
                                if (vi == null || vj == null || vi === '' || vj === '') return;
                                sumSim += (vi === vj ? 1 : 0);
                                count++;
                            }
                        });
                        if (count === 0) d = 0;
                        else {
                            const s = sumSim / count;
                            d = 1 - s;
                        }
                    } else {
                        d = 0;
                    }

                    distMatrix[i][j] = d;
                    distMatrix[j][i] = d;
                }
            }

            return distMatrix;
        }

        /******************** 凝聚式階層集群 (Agglomerative) ********************/

        function agglomerativeClusteringFromDistance(distMatrix, linkage, options) {
            const n = distMatrix.length;
            const clusters = [];
            const nodesById = {};
            const merges = [];

            for (let i = 0; i < n; i++) {
                clusters.push({ id: i, indices: [i], size: 1 });
                nodesById[i] = { id: i, left: null, right: null, height: 0 };
            }

            let currentClusterId = n;

            // 若使用 Ward / Centroid，預先計算 centroid & SSE
            const featureMatrix = options && options.featureMatrix ? options.featureMatrix : null;
            if ((linkage === 'ward' || linkage === 'centroid') && !featureMatrix) {
                // 理論上前面已經避免這種情況，這裡再防呆一下
                linkage = 'average';
            }

            if ((linkage === 'ward' || linkage === 'centroid') && featureMatrix) {
                clusters.forEach(c => {
                    c.centroid = computeClusterCentroid(c.indices, featureMatrix);
                    c.sse = computeClusterSSE(c.indices, c.centroid, featureMatrix);
                });
            }

            while (clusters.length > 1) {
                let bestI = 0, bestJ = 1, bestD = Infinity;

                for (let i = 0; i < clusters.length; i++) {
                    for (let j = i + 1; j < clusters.length; j++) {
                        const cA = clusters[i];
                        const cB = clusters[j];
                        let d;

                        if (linkage === 'single' || linkage === 'complete' || linkage === 'average') {
                            d = clusterDistanceByLinkage(cA.indices, cB.indices, distMatrix, linkage);
                        } else if (linkage === 'centroid') {
                            d = centroidDistance(cA, cB);
                        } else if (linkage === 'ward') {
                            d = wardDistance(cA, cB);
                        } else {
                            d = clusterDistanceByLinkage(cA.indices, cB.indices, distMatrix, 'average');
                        }

                        if (d < bestD) {
                            bestD = d;
                            bestI = i;
                            bestJ = j;
                        }
                    }
                }

                const clusterA = clusters[bestI];
                const clusterB = clusters[bestJ];
                const newIndices = clusterA.indices.concat(clusterB.indices);
                const newCluster = { id: currentClusterId, indices: newIndices, size: newIndices.length };

                if ((linkage === 'ward' || linkage === 'centroid') && featureMatrix) {
                    newCluster.centroid = computeClusterCentroid(newIndices, featureMatrix);
                    newCluster.sse = computeClusterSSE(newIndices, newCluster.centroid, featureMatrix);
                }

                merges.push({ id: currentClusterId, left: clusterA.id, right: clusterB.id, height: bestD });
                nodesById[currentClusterId] = { id: currentClusterId, left: clusterA.id, right: clusterB.id, height: bestD };

                // 移除舊 cluster, 加入新 cluster
                if (bestI > bestJ) { const tmp = bestI; bestI = bestJ; bestJ = tmp; }
                clusters.splice(bestJ, 1);
                clusters.splice(bestI, 1);
                clusters.push(newCluster);

                currentClusterId++;
            }

            const rootId = clusters[0].id;
            return { merges, nodesById, rootId, nSamples: n };
        }

        function clusterDistanceByLinkage(indicesA, indicesB, distMatrix, linkage) {
            let minD = Infinity, maxD = 0, sumD = 0, count = 0;
            indicesA.forEach(i => {
                indicesB.forEach(j => {
                    const d = distMatrix[i][j];
                    if (linkage === 'single') {
                        if (d < minD) minD = d;
                    } else if (linkage === 'complete') {
                        if (d > maxD) maxD = d;
                    } else {
                        sumD += d;
                        count++;
                    }
                });
            });
            if (linkage === 'single') return minD;
            if (linkage === 'complete') return maxD;
            return count > 0 ? (sumD / count) : 0;
        }

        // Centroid / Ward 相關工具（僅 numeric + Euclidean）

        function computeClusterCentroid(indices, featureMatrix) {
            const d = featureMatrix[0].length;
            const centroid = new Array(d).fill(0);
            indices.forEach(i => {
                const row = featureMatrix[i];
                for (let k = 0; k < d; k++) {
                    centroid[k] += row[k];
                }
            });
            for (let k = 0; k < d; k++) {
                centroid[k] /= indices.length;
            }
            return centroid;
        }

        function computeClusterSSE(indices, centroid, featureMatrix) {
            let sse = 0;
            indices.forEach(i => {
                const row = featureMatrix[i];
                let sumSq = 0;
                for (let k = 0; k < centroid.length; k++) {
                    const diff = row[k] - centroid[k];
                    sumSq += diff * diff;
                }
                sse += sumSq;
            });
            return sse;
        }

        function centroidDistance(clusterA, clusterB) {
            if (!clusterA.centroid || !clusterB.centroid) return 0;
            let sumSq = 0;
            for (let k = 0; k < clusterA.centroid.length; k++) {
                const diff = clusterA.centroid[k] - clusterB.centroid[k];
                sumSq += diff * diff;
            }
            return Math.sqrt(sumSq);
        }

        function wardDistance(clusterA, clusterB) {
            // Ward: 使用 centroid 差異估計 SSE 增量
            if (!clusterA.centroid || !clusterB.centroid) return 0;
            const nA = clusterA.size;
            const nB = clusterB.size;
            const total = nA + nB;
            let sumSq = 0;
            for (let k = 0; k < clusterA.centroid.length; k++) {
                const diff = clusterA.centroid[k] - clusterB.centroid[k];
                sumSq += diff * diff;
            }
            // 這個量與合併後 SSE 增量成正比
            return (nA * nB / total) * sumSq;
        }

        /******************** 根據 K 產生群集標籤 ********************/

        function getClusterLabelsForK(hState, k) {
            const { nSamples, nodesById, rootId } = hState;
            if (k <= 1) {
                return new Array(nSamples).fill(1);
            }

            const clusters = [rootId];

            function getHeight(nodeId) {
                const node = nodesById[nodeId];
                if (!node) return 0;
                return node.height || 0;
            }

            while (clusters.length < k) {
                let idxToSplit = -1;
                let maxHeight = -1;
                for (let i = 0; i < clusters.length; i++) {
                    const cid = clusters[i];
                    const node = nodesById[cid];
                    if (!node || node.left === null || node.right === null) continue;
                    if (node.height > maxHeight) {
                        maxHeight = node.height;
                        idxToSplit = i;
                    }
                }
                if (idxToSplit === -1) break;
                const nodeId = clusters[idxToSplit];
                const node = nodesById[nodeId];
                clusters.splice(idxToSplit, 1);
                clusters.push(node.left, node.right);
            }

            const labels = new Array(nSamples).fill(-1);

            function assignLeaves(nodeId, label) {
                const node = nodesById[nodeId];
                if (!node || node.left === null || node.right === null) {
                    const sampleIdx = nodeId;
                    if (sampleIdx < nSamples) labels[sampleIdx] = label;
                    return;
                }
                assignLeaves(node.left, label);
                assignLeaves(node.right, label);
            }

            clusters.forEach((cid, idx) => {
                assignLeaves(cid, idx + 1);
            });

            return labels;
        }

        /******************** Silhouette 係數計算 ********************/

        function computeSilhouette(distMatrix, labels) {
            const n = distMatrix.length;
            const clusters = {};
            for (let i = 0; i < n; i++) {
                const lab = labels[i];
                if (!clusters[lab]) clusters[lab] = [];
                clusters[lab].push(i);
            }

            const sValues = new Array(n).fill(0);

            for (let i = 0; i < n; i++) {
                const lab = labels[i];
                const sameCluster = clusters[lab];
                if (sameCluster.length <= 1) {
                    sValues[i] = 0;
                    continue;
                }

                // a(i): 同群內平均距離
                let aSum = 0, aCount = 0;
                sameCluster.forEach(j => {
                    if (j === i) return;
                    aSum += distMatrix[i][j];
                    aCount++;
                });
                const a = aCount > 0 ? (aSum / aCount) : 0;

                // b(i): 與其他群集中最小平均距離
                let b = Infinity;
                for (const otherLab in clusters) {
                    if (parseInt(otherLab, 10) === lab) continue;
                    const group = clusters[otherLab];
                    let sum = 0, count = 0;
                    group.forEach(j => {
                        sum += distMatrix[i][j];
                        count++;
                    });
                    if (count === 0) continue;
                    const avg = sum / count;
                    if (avg < b) b = avg;
                }
                if (!isFinite(b)) {
                    sValues[i] = 0;
                } else {
                    sValues[i] = (b - a) / Math.max(a, b);
                }
            }

            const clusterSilhouette = {};
            for (const lab in clusters) {
                const idxs = clusters[lab];
                const vals = idxs.map(i => sValues[i]);
                const mean = vals.reduce((a, b) => a + b, 0) / vals.length;
                clusterSilhouette[lab] = mean;
            }
            const overall = sValues.reduce((a, b) => a + b, 0) / n;

            return { sValues, clusterSilhouette, overall };
        }

        /******************** 視覺化：樹狀圖 + 熱圖 + Silhouette ********************/

        function updateHierarchicalClusterViews(k) {
            if (!hierarchicalState) return;
            const labels = getClusterLabelsForK(hierarchicalState, k);
            buildDendrogramPlot(hierarchicalState, labels, k);
            buildHierarchicalHeatmap(hierarchicalState, labels);
            buildHierarchicalSilhouette(hierarchicalState, labels);
        }

        function buildDendrogramPlot(hState, labels, k) {
            const { nodesById, rootId, nSamples, merges } = hState;
            const leafOrder = Array.from({ length: nSamples }, (_, i) => i);
            const xLeafPos = {};
            leafOrder.forEach((idx, pos) => { xLeafPos[idx] = pos; });

            const x = [];
            const y = [];

            function traverse(nodeId) {
                const node = nodesById[nodeId];
                if (!node) return { x: 0, y: 0 };
                if (node.left === null || node.right === null) {
                    const leafX = xLeafPos[nodeId];
                    return { x: leafX, y: 0 };
                }
                const leftPos = traverse(node.left);
                const rightPos = traverse(node.right);
                const nodeY = node.height;
                const nodeX = (leftPos.x + rightPos.x) / 2;

                // left vertical
                x.push(leftPos.x, leftPos.x, null);
                y.push(leftPos.y, nodeY, null);
                // right vertical
                x.push(rightPos.x, rightPos.x, null);
                y.push(rightPos.y, nodeY, null);
                // horizontal
                x.push(leftPos.x, rightPos.x, null);
                y.push(nodeY, nodeY, null);

                return { x: nodeX, y: nodeY };
            }

            traverse(rootId);

            const dendroTrace = {
                x,
                y,
                mode: 'lines',
                type: 'scatter',
                hoverinfo: 'none',
                line: { color: 'rgb(55, 96, 146)', width: 1.5 },
                name: 'dendrogram'
            };

            // 葉節點點點，用群集顏色表示
            const leafX = leafOrder.map(i => xLeafPos[i]);
            const leafY = new Array(nSamples).fill(0);
            // 1-based indexing for display
            const leafText = leafOrder.map(i => `樣本 ${i + 1}`);
            const markerTrace = {
                x: leafX,
                y: leafY,
                text: leafText,
                mode: 'markers',
                type: 'scatter',
                marker: {
                    size: 7,
                    color: labels,
                    colorscale: 'Viridis',
                    colorbar: { title: 'Cluster' }
                },
                hovertemplate: '%{text}<extra></extra>',
                name: 'leaves'
            };

            // 計算切割線高度：第 (n-K) 次合併的高度
            const shapes = [];
            if (merges && merges.length > 0) {
                const mergeIndex = hState.nSamples - k - 1;
                if (mergeIndex >= 0 && mergeIndex < merges.length) {
                    const threshold = merges[mergeIndex].height;
                    shapes.push({
                        type: 'line',
                        x0: -1,
                        x1: nSamples + 1,
                        y0: threshold,
                        y1: threshold,
                        line: {
                            dash: 'dot',
                            width: 1.5,
                            color: 'rgba(220,38,38,0.8)'
                        }
                    });
                }
            }

            const layout = {
                title: `階層式集群樹狀圖 (K = ${k})`,
                xaxis: {
                    title: '樣本索引 (依原始順序)',
                    showticklabels: false
                },
                yaxis: { title: '距離 / 高度' },
                margin: { t: 40, l: 40, r: 10, b: 40 },
                shapes: shapes
            };

            Plotly.newPlot('hierDendrogram', [dendroTrace, markerTrace], layout, { responsive: true });
        }

        function buildHierarchicalHeatmap(hState, labels) {
            const { dataRows, selectedVars, variableTypes } = hState;
            const n = dataRows.length;
            const m = selectedVars.length;
            if (m === 0) {
                document.getElementById('hierHeatmap').innerHTML = '';
                return;
            }

            // ✅ 新增：建立依集群排序的索引映射
            const sortedIndices = [...Array(n).keys()].sort((a, b) => {
                // 先依集群標籤排序
                if (labels[a] !== labels[b]) {
                    return labels[a] - labels[b];
                }
                // 同集群內維持原順序
                return a - b;
            });

            // ✅ 修改：重新排列數據
            const z = [];
            const yLabels = [];
            const xLabels = sortedIndices.map(originalIdx =>
                `S${originalIdx + 1} (C${labels[originalIdx]})`  // 加上集群標籤
            );

            selectedVars.forEach(v => {
                yLabels.push(v);
                const rowVals = [];

                if (variableTypes[v] === 'numeric') {
                    const vals = dataRows
                        .map(({ row }) => row[v])
                        .filter(val => typeof val === 'number' && !isNaN(val));
                    const min = Math.min(...vals);
                    const max = Math.max(...vals);
                    const range = (max - min) || 1;

                    // ✅ 修改：按排序後的索引取值
                    for (let sortedIdx = 0; sortedIdx < n; sortedIdx++) {
                        const originalIdx = sortedIndices[sortedIdx];
                        const value = dataRows[originalIdx].row[v];
                        if (typeof value === 'number' && !isNaN(value)) {
                            rowVals.push((value - min) / range);
                        } else {
                            rowVals.push(null);
                        }
                    }
                } else {
                    // 類別變數處理
                    const distinct = Array.from(new Set(
                        dataRows.map(({ row }) => row[v]).filter(val => val != null && val !== '')
                    ));

                    // ✅ 修改：按排序後的索引取值
                    for (let sortedIdx = 0; sortedIdx < n; sortedIdx++) {
                        const originalIdx = sortedIndices[sortedIdx];
                        const value = dataRows[originalIdx].row[v];
                        if (value == null || value === '') {
                            rowVals.push(null);
                        } else {
                            rowVals.push(distinct.indexOf(value));
                        }
                    }
                }
                z.push(rowVals);
            });

            const heatData = [{
                z,
                x: xLabels,
                y: yLabels,
                type: 'heatmap',
                colorscale: 'Viridis',
                hovertemplate: '變數 %{y}<br>%{x}<br>標準化值: %{z}<extra></extra>'
            }];

            const layout = {
                title: '集群著色熱圖（依集群分組排列）',
                xaxis: {
                    title: '樣本 (已依集群排序)',
                    tickmode: 'linear',
                    tickangle: -45,
                    tickfont: { size: 10 }
                },
                yaxis: { title: '' },
                margin: { t: 40, l: 100, r: 10, b: 80 }
            };

            Plotly.newPlot('hierHeatmap', heatData, layout, { responsive: true });
        }


        function buildHierarchicalSilhouette(hState, labels) {
            const { distMatrix } = hState;
            const { clusterSilhouette, overall } = computeSilhouette(distMatrix, labels);

            const clusterIds = Object.keys(clusterSilhouette)
                .map(k => parseInt(k, 10))
                .sort((a, b) => a - b);
            const scores = clusterIds.map(id => clusterSilhouette[id]);

            const trace = {
                x: clusterIds,
                y: scores,
                type: 'bar',
                text: scores.map(v => v.toFixed(3)),
                textposition: 'auto',
                hovertemplate: '群集 %{x}<br>平均輪廓係數: %{y:.3f}<extra></extra>'
            };

            const layout = {
                title: `輪廓係數評估圖（整體平均 = ${overall.toFixed(3)}）`,
                xaxis: { title: '群集編號' },
                yaxis: { title: '平均輪廓係數', range: [-1, 1] },
                margin: { t: 40, l: 40, r: 10, b: 40 }
            };

            Plotly.newPlot('hierSilhouette', [trace], layout, { responsive: true });
        }

    </script>

    <!-- ===== v2.5 革命性修復: Modal 彈窗 HTML 結構 ===== -->
    <div id="predictionModal" class="prediction-modal">
        <div class="modal-content">
            <div class="modal-header">
                🎯 邏輯斯迴歸預測結果
            </div>
            <div id="modalResultContent" class="modal-result">
                <!-- 結果內容將由 JavaScript 動態插入 -->
            </div>
            <button class="modal-close-btn" onclick="closeModal()">✅ 關閉視窗</button>
        </div>
    </div>


    <!-- Neural Network (TensorFlow.js) + Permutation Importance -->
    <script>
        (function () {
            let nnModel = null;

            function buildTaskType(yVar) {
                const yValues = jsonData
                    .map(r => r[yVar])
                    .filter(v => v != null && v !== '');
                if (yValues.length === 0) return { type: null, uniqueY: [] };

                const uniqueY = Array.from(new Set(yValues));
                let taskType = 'regression';

                const allNumeric = uniqueY.every(v => typeof v === 'number' && !isNaN(v));
                if (!allNumeric) {
                    if (uniqueY.length === 2) {
                        taskType = 'binary-classification';
                    } else {
                        taskType = 'multi-class-classification';
                    }
                } else {
                    if (uniqueY.length === 2) {
                        taskType = 'binary-classification';
                    } else if (uniqueY.length > 2 && uniqueY.length <= 12) {
                        taskType = 'multi-class-classification';
                    } else {
                        taskType = 'regression';
                    }
                }
                return { type: taskType, uniqueY };
            }

            function prepareXY(yVar, xVars, taskInfo) {
                // 1. Identify variable types and build vocabularies
                const featureMetadata = xVars.map(x => {
                    // Check if numeric: all non-empty values must be numbers
                    const isNumeric = jsonData.every(r => {
                        const v = r[x];
                        return v == null || v === '' || (typeof v === 'number' && !isNaN(v));
                    });

                    if (isNumeric) {
                        // Calculate original mean for default value
                        const validValues = jsonData
                            .map(r => r[x])
                            .filter(v => v != null && v !== '' && typeof v === 'number' && !isNaN(v));
                        const originalMean = validValues.length > 0 
                            ? validValues.reduce((a, b) => a + b, 0) / validValues.length 
                            : 0;
                        return { name: x, type: 'numeric', indices: [], originalMean };
                    } else {
                        // Build vocabulary
                        const unique = new Set();
                        jsonData.forEach(r => {
                            const v = r[x];
                            if (v != null && v !== '') unique.add(String(v));
                        });
                        return { name: x, type: 'categorical', categories: Array.from(unique).sort(), indices: [] };
                    }
                });

                // 2. Filter rows and Transform
                const rows = [];
                jsonData.forEach(row => {
                    const y = row[yVar];
                    if (y == null || y === '') return;

                    const flatRow = [];
                    let valid = true;

                    for (let i = 0; i < xVars.length; i++) {
                        const x = xVars[i];
                        const meta = featureMetadata[i];
                        const v = row[x];

                        if (v == null || v === '') {
                            valid = false; break;
                        }

                        if (meta.type === 'numeric') {
                            if (typeof v !== 'number' || isNaN(v)) {
                                valid = false; break;
                            }
                            flatRow.push(v);
                        } else {
                            // One-Hot Encoding
                            const catIdx = meta.categories.indexOf(String(v));
                            if (catIdx === -1) {
                                valid = false; break;
                            }
                            // Push 0s and 1
                            for (let k = 0; k < meta.categories.length; k++) {
                                flatRow.push(k === catIdx ? 1 : 0);
                            }
                        }
                    }

                    if (valid) {
                        rows.push({ x: flatRow, y });
                    }
                });

                if (rows.length === 0) return null;

                const maxSamples = 1000;
                const sampled = rows.length > maxSamples
                    ? rows.sort(() => Math.random() - 0.5).slice(0, maxSamples)
                    : rows;

                const xsArr = sampled.map(r => r.x);
                let ysArr;

                if (taskInfo.type === 'regression') {
                    ysArr = sampled.map(r => r.y);
                } else if (taskInfo.type === 'binary-classification') {
                    const unique = taskInfo.uniqueY;
                    ysArr = sampled.map(r => (r.y === unique[0] ? 0 : 1));
                } else {
                    const unique = taskInfo.uniqueY;
                    ysArr = sampled.map(r => unique.indexOf(r.y));
                }

                // 3. Assign Indices and Normalize Numeric Columns
                let currentIndex = 0;
                featureMetadata.forEach(meta => {
                    if (meta.type === 'numeric') {
                        meta.indices = [currentIndex++];
                    } else {
                        const len = meta.categories.length;
                        meta.indices = Array.from({ length: len }, (_, i) => currentIndex + i);
                        currentIndex += len;
                    }
                });

                const numericIndices = featureMetadata.filter(m => m.type === 'numeric').flatMap(m => m.indices);

                const numericMeans = {};
                const numericStds = {};

                if (numericIndices.length > 0) {
                    numericIndices.forEach(idx => {
                        let sum = 0;
                        xsArr.forEach(row => sum += row[idx]);
                        numericMeans[idx] = sum / xsArr.length;
                    });

                    numericIndices.forEach(idx => {
                        let sumSq = 0;
                        const m = numericMeans[idx];
                        xsArr.forEach(row => sumSq += Math.pow(row[idx] - m, 2));
                        numericStds[idx] = Math.sqrt(sumSq / xsArr.length) || 1;
                    });

                    // Apply normalization
                    xsArr.forEach(row => {
                        numericIndices.forEach(idx => {
                            row[idx] = (row[idx] - numericMeans[idx]) / numericStds[idx];
                        });
                    });
                }

                return { xsArr, ysArr, featureMetadata, numericMeans, numericStds };
            }

            function buildModel(inputDim, taskInfo, hiddenUnits) {
                if (nnModel) {
                    nnModel.dispose();
                    nnModel = null;
                }
                const model = tf.sequential();
                model.add(tf.layers.dense({
                    units: hiddenUnits,
                    activation: 'relu',
                    inputShape: [inputDim]
                }));

                if (taskInfo.type === 'regression') {
                    model.add(tf.layers.dense({ units: 1, activation: 'linear' }));
                    model.compile({
                        optimizer: tf.train.adam(),
                        loss: 'meanSquaredError',
                        metrics: ['mse', 'mae']
                    });
                } else if (taskInfo.type === 'binary-classification') {
                    model.add(tf.layers.dense({ units: 1, activation: 'sigmoid' }));
                    model.compile({
                        optimizer: tf.train.adam(),
                        loss: 'binaryCrossentropy',
                        metrics: ['accuracy']
                    });
                } else {
                    model.add(tf.layers.dense({
                        units: taskInfo.uniqueY.length,
                        activation: 'softmax'
                    }));
                    model.compile({
                        optimizer: tf.train.adam(),
                        loss: 'sparseCategoricalCrossentropy',
                        metrics: ['accuracy']
                    });
                }
                nnModel = model;
                return model;
            }

            async function evaluateModel(model, xsArr, ysArr, taskType) {
                // Check if model is still valid
                if (!model || !model.layers || model.layers.length === 0) {
                    throw new Error('Model is not available or has been disposed');
                }
                
                let xs, ys;
                try {
                    xs = tf.tensor2d(xsArr);
                    if (taskType === 'regression') {
                        ys = tf.tensor2d(ysArr, [ysArr.length, 1]);
                    } else {
                        // Use float32 for compatibility with sparseCategoricalCrossentropy
                        ys = tf.tensor1d(ysArr.map(v => Number(v)), 'float32');
                    }

                    const evalRes = model.evaluate(xs, ys);
                    let loss = 0, metric = 0;

                    if (Array.isArray(evalRes)) {
                        const lossTensor = evalRes[0];
                        const metricTensor = evalRes.length > 1 ? evalRes[1] : null;

                        const lossData = await lossTensor.data();
                        loss = lossData[0];

                        if (metricTensor) {
                            const metricData = await metricTensor.data();
                            metric = metricData[0];
                        }

                        // Dispose evaluation tensors
                        evalRes.forEach(t => t.dispose());
                    } else {
                        const lossData = await evalRes.data();
                        loss = lossData[0];
                        evalRes.dispose();
                    }
                    return { loss, metric };
                } finally {
                    if (xs) xs.dispose();
                    if (ys) ys.dispose();
                }
            }

            async function computePermutationImportance(model, xsArr, ysArr, xVars, taskInfo, featureMetadata) {
                const baseline = await evaluateModel(model, xsArr, ysArr, taskInfo.type);
                const importance = [];
                const nRepeats = 5; // Repeat 5 times to stabilize results

                for (let j = 0; j < featureMetadata.length; j++) {
                    const meta = featureMetadata[j];
                    const indices = meta.indices;
                    let totalImp = 0;

                    for (let r = 0; r < nRepeats; r++) {
                        // Copy xsArr
                        const permXs = xsArr.map(row => row.slice());

                        // Extract the block of columns for this feature
                        const colBlock = permXs.map(r => indices.map(idx => r[idx]));

                        // Shuffle the block (Fisher-Yates)
                        for (let i = colBlock.length - 1; i > 0; i--) {
                            const k = Math.floor(Math.random() * (i + 1));
                            [colBlock[i], colBlock[k]] = [colBlock[k], colBlock[i]];
                        }

                        // Put back shuffled values
                        for (let i = 0; i < permXs.length; i++) {
                            indices.forEach((idx, localIdx) => {
                                permXs[i][idx] = colBlock[i][localIdx];
                            });
                        }

                        const perm = await evaluateModel(model, permXs, ysArr, taskInfo.type);
                        let imp;
                        if (taskInfo.type === 'regression') {
                            imp = perm.loss - baseline.loss;
                        } else {
                            imp = baseline.metric - perm.metric;
                        }
                        totalImp += imp;
                    }

                    importance.push({ name: meta.name, value: totalImp / nRepeats });
                }
                return { baseline, importance };
            }

            async function runNeuralNetworkTraining() {
                const resultsDiv = document.getElementById('nnResults');
                const summaryDiv = document.getElementById('nnImportanceSummary');
                const plotDivId = 'nnImportancePlot';
                const plotDivEl = document.getElementById(plotDivId);
                const lcDivId = 'nnLearningCurve';
                const cmDivId = 'nnConfusionMatrix';

                if (summaryDiv) summaryDiv.innerHTML = '';

                // Clear plots
                [plotDivId, lcDivId, cmDivId].forEach(id => {
                    const el = document.getElementById(id);
                    if (el) {
                        el.innerHTML = '';
                        if (window.Plotly) Plotly.purge(id);
                    }
                });

                if (!resultsDiv) return;

                if (!jsonData || !Array.isArray(jsonData) || jsonData.length === 0 || !headers) {
                    resultsDiv.innerHTML = '<p class="text-red-600">請先在「上傳資料」區塊匯入資料，並確認已看到資料預覽。</p>';
                    return;
                }

                const ySelect = document.getElementById('nnY');
                const xSelect = document.getElementById('nnX');
                const hiddenInput = document.getElementById('nnHiddenUnits');
                const epochsInput = document.getElementById('nnEpochs');

                const yVar = ySelect ? ySelect.value : '';
                const xVars = xSelect ? Array.from(xSelect.selectedOptions).map(o => o.value) : [];

                // Check for overlap
                if (xVars.includes(yVar)) {
                    alert(`錯誤：目標變數 (Y) "${yVar}" 不能同時作為特徵變數 (X)。請從特徵變數中移除它。`);
                    resultsDiv.innerHTML = ''; // Clear loading state if any
                    return;
                }
                const hiddenUnits = parseInt(hiddenInput ? hiddenInput.value : '8', 10) || 8;
                const epochs = parseInt(epochsInput ? epochsInput.value : '200', 10) || 200;

                if (!yVar || xVars.length === 0) {
                    resultsDiv.innerHTML = '<p class="text-red-600">請至少選擇 1 個應變數 (Y) 與 1 個以上自變數 (X)。</p>';
                    return;
                }

                const taskInfo = buildTaskType(yVar);
                if (!taskInfo.type) {
                    resultsDiv.innerHTML = '<p class="text-red-600">無法判斷任務類型，請確認應變數資料是否有效。</p>';
                    return;
                }

                const prep = prepareXY(yVar, xVars, taskInfo);
                if (!prep) {
                    resultsDiv.innerHTML = '<p class="text-red-600">選擇的欄位缺少足夠的有效數值資料，請重新選擇。</p>';
                    return;
                }

                const { xsArr, ysArr, featureMetadata, numericMeans, numericStds } = prep;
                const inputDim = xsArr[0].length;

                // --- Normalize Y for Regression to improve convergence ---
                let yMean = 0, yStd = 1;
                if (taskInfo.type === 'regression') {
                    const n = ysArr.length;
                    yMean = ysArr.reduce((a, b) => a + b, 0) / n;
                    const sumSq = ysArr.reduce((a, b) => a + Math.pow(b - yMean, 2), 0);
                    yStd = Math.sqrt(sumSq / n) || 1;
                    // Apply normalization to ysArr in place
                    for (let i = 0; i < n; i++) {
                        ysArr[i] = (ysArr[i] - yMean) / yStd;
                    }
                }

                // --- Shuffle & Split (80% Train, 20% Val) ---
                const indices = Array.from({ length: xsArr.length }, (_, i) => i);
                // Fisher-Yates Shuffle
                for (let i = indices.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [indices[i], indices[j]] = [indices[j], indices[i]];
                }

                const shuffledXs = indices.map(i => xsArr[i]);
                const shuffledYs = indices.map(i => ysArr[i]);

                const splitIdx = Math.floor(shuffledXs.length * 0.8);
                const xTrain = shuffledXs.slice(0, splitIdx);
                const yTrain = shuffledYs.slice(0, splitIdx);
                const xVal = shuffledXs.slice(splitIdx);
                const yVal = shuffledYs.slice(splitIdx);

                if (xTrain.length === 0 || xVal.length === 0) {
                    resultsDiv.innerHTML = '<p class="text-red-600">資料筆數過少，無法進行訓練/驗證分割。</p>';
                    return;
                }

                // Create Tensors
                const xTrainTensor = tf.tensor2d(xTrain);
                const xValTensor = tf.tensor2d(xVal);

                let yTrainTensor, yValTensor;
                if (taskInfo.type === 'regression') {
                    yTrainTensor = tf.tensor2d(yTrain, [yTrain.length, 1]);
                    yValTensor = tf.tensor2d(yVal, [yVal.length, 1]);
                } else {
                    // Use float32 for compatibility with sparseCategoricalCrossentropy
                    yTrainTensor = tf.tensor1d(yTrain.map(v => Number(v)), 'float32');
                    yValTensor = tf.tensor1d(yVal.map(v => Number(v)), 'float32');
                }

                const model = buildModel(inputDim, taskInfo, hiddenUnits);

                resultsDiv.innerHTML = `
                <h3 class="text-lg font-semibold mb-2">📌 神經網絡訓練中...</h3>
                <p class="mb-2">總樣本數：<strong>${xsArr.length}</strong> (訓練：${xTrain.length}, 驗證：${xVal.length})</p>
                <p class="mb-2">特徵數：<strong>${xVars.length}</strong> (擴展後輸入維度：${inputDim})，任務類型：<strong>${taskInfo.type}</strong></p>
                <p class="mb-2">Epochs：<strong>${epochs}</strong>，隱藏層神經元：<strong>${hiddenUnits}</strong></p>
                <div id="nnProgress" class="mt-2 text-sm text-gray-700"></div>
            `;

                const progressDiv = document.getElementById('nnProgress');
                const history = { epoch: [], loss: [], val_loss: [], metric: [], val_metric: [] };

                await model.fit(xTrainTensor, yTrainTensor, {
                    epochs,
                    batchSize: 32,
                    validationData: [xValTensor, yValTensor],
                    shuffle: true,
                    callbacks: {
                        onEpochEnd: async (epoch, logs) => {
                            history.epoch.push(epoch + 1);
                            history.loss.push(logs.loss);
                            history.val_loss.push(logs.val_loss);

                            const metricKey = taskInfo.type === 'regression' ? (logs.mae !== undefined ? 'mae' : 'mse') : 'acc';
                            const valMetricKey = 'val_' + metricKey;

                            history.metric.push(logs[metricKey] || 0);
                            history.val_metric.push(logs[valMetricKey] || 0);

                            if (progressDiv) {
                                progressDiv.innerHTML = `
                                <p>Epoch ${epoch + 1} / ${epochs}</p>
                                <p>Train Loss：${logs.loss.toFixed(4)} | Val Loss：${logs.val_loss.toFixed(4)}</p>
                                <p>Train ${metricKey}：${(logs[metricKey] || 0).toFixed(4)} | Val ${metricKey}：${(logs[valMetricKey] || 0).toFixed(4)}</p>
                            `;
                            }
                            await tf.nextFrame();
                        }
                    }
                });

                // --- Visualization: Learning Curve ---
                if (window.Plotly) {
                    const metricName = taskInfo.type === 'regression' ? 'MAE/MSE' : 'Accuracy';

                    const traceLossTrain = { x: history.epoch, y: history.loss, type: 'scatter', mode: 'lines', name: 'Train Loss' };
                    const traceLossVal = { x: history.epoch, y: history.val_loss, type: 'scatter', mode: 'lines', name: 'Val Loss' };

                    const traceMetricTrain = { x: history.epoch, y: history.metric, type: 'scatter', mode: 'lines', name: `Train ${metricName}` };
                    const traceMetricVal = { x: history.epoch, y: history.val_metric, type: 'scatter', mode: 'lines', name: `Val ${metricName}` };

                    const layoutLC = {
                        title: 'Learning Curve (Train vs Validation)',
                        grid: { rows: 1, columns: 2, pattern: 'independent' },
                        xaxis: { title: 'Epoch' },
                        yaxis: { title: 'Loss' },
                        xaxis2: { title: 'Epoch' },
                        yaxis2: { title: metricName },
                        showlegend: true,
                        legend: { orientation: 'h', y: -0.2 }
                    };

                    // Subplots using domain
                    traceLossTrain.xaxis = 'x'; traceLossTrain.yaxis = 'y';
                    traceLossVal.xaxis = 'x'; traceLossVal.yaxis = 'y';
                    traceMetricTrain.xaxis = 'x2'; traceMetricTrain.yaxis = 'y2';
                    traceMetricVal.xaxis = 'x2'; traceMetricVal.yaxis = 'y2';

                    layoutLC.xaxis.domain = [0, 0.45];
                    layoutLC.yaxis.domain = [0, 1];
                    layoutLC.xaxis2.domain = [0.55, 1];
                    layoutLC.yaxis2.domain = [0, 1];

                    Plotly.newPlot(lcDivId, [traceLossTrain, traceLossVal, traceMetricTrain, traceMetricVal], layoutLC, { responsive: true });
                }

                // --- Visualization: Confusion Matrix (Classification Only) ---
                if (taskInfo.type !== 'regression' && window.Plotly) {
                    const valPredsTensor = model.predict(xValTensor);
                    let valPreds;
                    if (taskInfo.type === 'binary-classification') {
                        valPreds = valPredsTensor.greater(0.5).cast('int32').dataSync();
                    } else {
                        valPreds = valPredsTensor.argMax(-1).dataSync();
                    }
                    const valTrue = yValTensor.dataSync();
                    valPredsTensor.dispose();

                    // Compute Confusion Matrix
                    const uniqueLabels = [...new Set([...valTrue, ...valPreds])].sort((a, b) => a - b);
                    const matrix = Array.from({ length: uniqueLabels.length }, () => Array(uniqueLabels.length).fill(0));
                    const labelMap = {};
                    uniqueLabels.forEach((l, i) => labelMap[l] = i);

                    for (let i = 0; i < valTrue.length; i++) {
                        const r = labelMap[valTrue[i]];
                        const c = labelMap[valPreds[i]];
                        if (r !== undefined && c !== undefined) {
                            matrix[r][c]++;
                        }
                    }

                    const traceCM = {
                        z: matrix,
                        x: uniqueLabels.map(l => `Pred ${l}`),
                        y: uniqueLabels.map(l => `True ${l}`),
                        type: 'heatmap',
                        colorscale: 'Blues',
                        showscale: true,
                        text: matrix.map(row => row.map(String)),
                        texttemplate: "%{text}",
                        hoverinfo: 'z'
                    };

                    const layoutCM = {
                        title: 'Confusion Matrix (Validation Set)',
                        xaxis: { title: 'Predicted Label' },
                        yaxis: { title: 'True Label' },
                        margin: { t: 40, l: 60, r: 10, b: 60 }
                    };

                    Plotly.newPlot(cmDivId, [traceCM], layoutCM, { responsive: true });

                    // --- Calculate Classification Metrics ---
                    let correct = 0;
                    let macroPrecision = 0;
                    let macroRecall = 0;
                    let macroF1 = 0;
                    const totalSamples = valTrue.length;

                    for (let i = 0; i < uniqueLabels.length; i++) {
                        const tp = matrix[i][i];
                        correct += tp;

                        // FP: Sum of column i (excluding diagonal)
                        let fp = 0;
                        for (let r = 0; r < uniqueLabels.length; r++) {
                            if (r !== i) fp += matrix[r][i];
                        }

                        // FN: Sum of row i (excluding diagonal)
                        let fn = 0;
                        for (let c = 0; c < uniqueLabels.length; c++) {
                            if (c !== i) fn += matrix[i][c];
                        }

                        const p = (tp + fp) > 0 ? tp / (tp + fp) : 0;
                        const r = (tp + fn) > 0 ? tp / (tp + fn) : 0;
                        const f1 = (p + r) > 0 ? 2 * (p * r) / (p + r) : 0;

                        macroPrecision += p;
                        macroRecall += r;
                        macroF1 += f1;
                    }

                    const accuracy = correct / totalSamples;
                    macroPrecision /= uniqueLabels.length;
                    macroRecall /= uniqueLabels.length;
                    macroF1 /= uniqueLabels.length;

                    const metricsHtml = `
                        <div class="mt-4 p-4 bg-green-50 rounded text-sm" id="nnClassificationMetrics">
                            <h4 class="font-semibold mb-2">📊 分類模型效能指標 (Validation Set)</h4>
                            <ul class="list-disc list-inside text-gray-700 space-y-1">
                                <li><strong>Accuracy (準確率)</strong>: ${(accuracy * 100).toFixed(2)}% - 整體預測正確的比例。</li>
                                <li><strong>Precision (精確率)</strong>: ${(macroPrecision * 100).toFixed(2)}% - 預測為某類別中，真正屬於該類別的比例 (Macro Avg)。</li>
                                <li><strong>Recall (召回率)</strong>: ${(macroRecall * 100).toFixed(2)}% - 實際為某類別中，被正確預測出來的比例 (Macro Avg)。</li>
                                <li><strong>F1-Score</strong>: ${(macroF1 * 100).toFixed(2)}% - Precision 與 Recall 的調和平均數，綜合評估指標。</li>
                            </ul>
                        </div>
                    `;

                    // Insert after cmDivId
                    const cmDiv = document.getElementById(cmDivId);
                    if (cmDiv) {
                        const oldMetrics = document.getElementById('nnClassificationMetrics');
                        if (oldMetrics) oldMetrics.remove();
                        cmDiv.insertAdjacentHTML('afterend', metricsHtml);
                    }
                }

                // --- Calculate Additional Metrics (R2, MAPE) for Regression ---
                let regressionMetricsHtml = '';
                if (taskInfo.type === 'regression') {
                    // Helper to calc R2 and MAPE
                    const calcMetrics = (xTensor, yTensor) => {
                        return tf.tidy(() => {
                            const predsScaled = model.predict(xTensor);
                            // Denormalize for correct metrics
                            const preds = predsScaled.mul(yStd).add(yMean);
                            const yTrue = yTensor.mul(yStd).add(yMean);

                            // R2
                            const meanY = yTrue.mean();
                            const ssTot = yTrue.sub(meanY).square().sum();
                            const ssRes = yTrue.sub(preds).square().sum();
                            const r2 = tf.sub(1, ssRes.div(ssTot)).dataSync()[0];

                            // MAPE
                            const epsilon = 1e-7;
                            const absDiff = yTrue.sub(preds).abs();
                            const absTrue = yTrue.abs().add(epsilon);
                            const mape = absDiff.div(absTrue).mean().mul(100).dataSync()[0];

                            return { r2, mape };
                        });
                    };

                    const trainMetrics = calcMetrics(xTrainTensor, yTrainTensor);
                    const valMetrics = calcMetrics(xValTensor, yValTensor);

                    regressionMetricsHtml = `
                        <div class="mt-4 mb-4 p-4 bg-blue-50 rounded text-sm">
                            <h4 class="font-semibold mb-2">📊 模型效能指標 (Regression Metrics)</h4>
                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <p class="font-medium text-gray-700">訓練集 (Train)</p>
                                    <ul class="list-disc list-inside text-gray-600">
                                        <li>R² (R-Squared): <strong>${(trainMetrics.r2 * 100).toFixed(2)}%</strong></li>
                                        <li>MAPE: <strong>${trainMetrics.mape.toFixed(2)}%</strong></li>
                                    </ul>
                                </div>
                                <div>
                                    <p class="font-medium text-gray-700">驗證集 (Validation)</p>
                                    <ul class="list-disc list-inside text-gray-600">
                                        <li>R² (R-Squared): <strong>${(valMetrics.r2 * 100).toFixed(2)}%</strong></li>
                                        <li>MAPE: <strong>${valMetrics.mape.toFixed(2)}%</strong></li>
                                    </ul>
                                </div>
                            </div>
                            <p class="mt-2 text-xs text-gray-500">註：R² 越接近 100% 越好；MAPE 越低越好。</p>
                        </div>
                    `;
                }

                xTrainTensor.dispose();
                yTrainTensor.dispose();
                xValTensor.dispose();
                yValTensor.dispose();

                const lastLoss = history.loss[history.loss.length - 1];
                // If regression, scale loss back to original units for display
                const displayLoss = taskInfo.type === 'regression' ? lastLoss * (yStd * yStd) : lastLoss;

                const lastMetric = history.metric[history.metric.length - 1] || 0;
                const displayMetric = taskInfo.type === 'regression' ? lastMetric * yStd : lastMetric; // MAE scales linearly

                let metricLabel = '';
                if (taskInfo.type === 'regression') {
                    metricLabel = 'MAE/MSE (視設定而定)';
                } else {
                    metricLabel = 'Accuracy';
                }

                resultsDiv.innerHTML = `
                <h3 class="text-lg font-semibold mb-2">✅ 神經網絡訓練完成</h3>
                <p class="mb-2">樣本數：<strong>${xsArr.length}</strong>，特徵數：<strong>${xVars.length}</strong> (擴展維度：${inputDim})，任務類型：<strong>${taskInfo.type}</strong></p>
                <p class="mb-2">最終 Train Loss (Original Scale)：<strong>${displayLoss.toFixed(4)}</strong></p>
                <p class="mb-2">最終 Train ${metricLabel} (Original Scale)：<strong>${displayMetric.toFixed(4)}</strong></p>
                ${regressionMetricsHtml}
            `;


                try {
                    const importanceInfo = await computePermutationImportance(model, xsArr, ysArr, xVars, taskInfo, featureMetadata);
                    const { baseline, importance } = importanceInfo;

                    // Scale importance back if regression
                    if (taskInfo.type === 'regression') {
                        baseline.loss = baseline.loss * (yStd * yStd);
                        importance.forEach(d => d.value = d.value * (yStd * yStd));
                    }

                    const sorted = importance.slice().sort((a, b) => b.value - a.value);
                    const featureNames = sorted.map(d => d.name);
                    const values = sorted.map(d => d.value);

                    if (summaryDiv && sorted.length > 0) {
                        const top = sorted.slice(0, 3);
                        const li = top.map(d => `<li>${d.name}：${d.value.toFixed(4)}</li>`).join('');
                        const baselineText = taskInfo.type === 'regression'
                            ? `Baseline Loss (MSE)：${baseline.loss.toFixed(4)}`
                            : `Baseline Accuracy：${baseline.metric.toFixed(4)}`;
                        summaryDiv.innerHTML = `
                        <h4 class="font-semibold mb-1">📊 Permutation Importance 摘要（Top 3）</h4>
                        <p class="text-xs text-gray-500 mb-1">數值越大代表「打亂此特徵」對模型表現破壞越大，重要性越高。</p>
                        <p class="mb-1 text-sm">${baselineText}</p>
                        <ul class="list-disc list-inside text-sm space-y-1">
                            ${li}
                        </ul>
                    `;
                    }

                    if (plotDivEl && window.Plotly && featureNames.length > 0) {
                        const yLabel = taskInfo.type === 'regression'
                            ? 'Loss 增加量 (ΔLoss)'
                            : 'Accuracy 下降量 (ΔAcc)';

                        const trace = {
                            type: 'bar',
                            x: featureNames,
                            y: values,
                        };
                        const layout = {
                            title: '神經網絡 Permutation Importance',
                            xaxis: { title: '特徵變數' },
                            yaxis: { title: yLabel },
                            margin: { t: 40, l: 60, r: 10, b: 80 }
                        };
                        Plotly.newPlot(plotDivId, [trace], layout, { responsive: true });
                    }
                } catch (e) {
                    console.error('Permutation importance error:', e);
                    if (summaryDiv) {
                        summaryDiv.innerHTML = `<p class="text-amber-600">Permutation Importance 計算時發生錯誤 (${e.message})，但模型訓練結果已完成，可先用於教學說明。</p>`;
                    }
                }

                // === Store model and metadata for prediction (global) ===
                window.nnPredictionData = {
                    model,
                    featureMetadata,
                    yMean,
                    yStd,
                    numericMeans,
                    numericStds,
                    taskInfo,
                    yVar
                };

                // === Append Prediction Section at the VERY BOTTOM ===
                // First, remove any existing prediction section to avoid duplicates
                const existingPredSection = document.getElementById('nnPredictionSection');
                if (existingPredSection) {
                    existingPredSection.remove();
                }

                const nnConfusionMatrixDiv = document.getElementById('nnConfusionMatrix');
                if (nnConfusionMatrixDiv) {
                    const predictionHtml = `
                    <div id="nnPredictionSection" class="mt-8 border-t pt-6">
                        <h4 class="text-lg font-bold mb-4 flex items-center gap-2">
                            <svg class="w-5 h-5 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
                            神經網絡模型預測 (Prediction)
                        </h4>
                        <div class="bg-gray-50 p-4 rounded-lg border border-gray-200">
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4" id="nnPredictionInputs">
                                ${featureMetadata.map((meta, i) => {
                        if (meta.type === 'numeric') {
                            // Use originalMean as default value
                            const defaultVal = meta.originalMean !== undefined ? meta.originalMean.toFixed(2) : '';
                            return `
                                            <div>
                                                <label class="block text-sm font-medium text-gray-700 mb-1">${meta.name}</label>
                                                <input type="number" step="any" id="pred_input_${i}" value="${defaultVal}" class="w-full rounded-md border-gray-300 shadow-sm focus:border-purple-500 focus:ring-purple-500" placeholder="輸入數值">
                                                <span class="text-xs text-gray-400">平均值: ${defaultVal}</span>
                                            </div>
                                        `;
                        } else {
                            const options = meta.categories.map(c => `<option value="${c}">${c}</option>`).join('');
                            return `
                                            <div>
                                                <label class="block text-sm font-medium text-gray-700 mb-1">${meta.name}</label>
                                                <select id="pred_input_${i}" class="w-full rounded-md border-gray-300 shadow-sm focus:border-purple-500 focus:ring-purple-500">
                                                    ${options}
                                                </select>
                                            </div>
                                        `;
                        }
                    }).join('')}
                            </div>
                            <button id="btnPredictNN" class="bg-purple-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-purple-700 shadow-md transition-colors flex items-center gap-2">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 7h6m0 10v-3m-3 3h.01M9 17h.01M9 14h.01M12 14h.01M15 11h.01M12 11h.01M9 11h.01M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z"></path></svg>
                                進行預測
                            </button>
                            <div id="nnPredictionResult" class="mt-4 hidden"></div>
                        </div>
                    </div>
                `;
                    nnConfusionMatrixDiv.insertAdjacentHTML('afterend', predictionHtml);

                    // Bind Prediction Event
                    const btnPredict = document.getElementById('btnPredictNN');
                    if (btnPredict) {
                        btnPredict.addEventListener('click', async () => {
                            const data = window.nnPredictionData;
                            if (!data) {
                                alert('請先訓練模型');
                                return;
                            }

                            const { model, featureMetadata, yMean, yStd, numericMeans, numericStds, taskInfo, yVar } = data;
                            const resultDiv = document.getElementById('nnPredictionResult');
                            resultDiv.classList.remove('hidden');
                            resultDiv.innerHTML = '<span class="text-gray-500">預測中...</span>';

                            try {
                                const inputVector = [];

                                // 1. Collect and Encode Inputs
                                for (let i = 0; i < featureMetadata.length; i++) {
                                    const meta = featureMetadata[i];
                                    const el = document.getElementById(`pred_input_${i}`);
                                    const val = el.value;

                                    if (meta.type === 'numeric') {
                                        const numVal = parseFloat(val);
                                        if (isNaN(numVal)) throw new Error(`請輸入有效的數值：${meta.name}`);

                                        // Normalize
                                        const idx = meta.indices[0];
                                        const mean = numericMeans[idx] || 0;
                                        const std = numericStds[idx] || 1;
                                        inputVector.push((numVal - mean) / std);
                                    } else {
                                        // One-Hot Encode
                                        const catIdx = meta.categories.indexOf(val);
                                        if (catIdx === -1) throw new Error(`無效的類別值：${meta.name}`);

                                        for (let k = 0; k < meta.categories.length; k++) {
                                            inputVector.push(k === catIdx ? 1 : 0);
                                        }
                                    }
                                }

                                // 2. Predict
                                const inputTensor = tf.tensor2d([inputVector]);
                                const predTensor = model.predict(inputTensor);
                                const predData = await predTensor.data();

                                inputTensor.dispose();
                                predTensor.dispose();

                                // 3. Display Result
                                let resHtml = '';
                                if (taskInfo.type === 'regression') {
                                    const rawPred = predData[0] * yStd + yMean;
                                    resHtml = `
                                        <div class="p-4 bg-white border border-purple-200 rounded-lg shadow-sm">
                                            <div class="flex items-center justify-between">
                                                <div>
                                                    <p class="text-gray-600 text-sm">神經網絡模型預測</p>
                                                    <p class="text-lg font-bold text-gray-800 mt-1">預測 ${yVar}</p>
                                                </div>
                                                <div class="text-2xl font-bold text-purple-600">
                                                    ${rawPred.toFixed(4)}
                                                </div>
                                            </div>
                                        </div>
                                    `;
                                } else {
                                    // Classification
                                    const uniqueY = taskInfo.uniqueY;
                                    let probs = [];
                                    if (taskInfo.type === 'binary-classification') {
                                        const p1 = predData[0];
                                        probs = [1 - p1, p1];
                                    } else {
                                        probs = Array.from(predData);
                                    }

                                    const probList = probs.map((p, i) => {
                                        const label = uniqueY[i];
                                        const pct = (p * 100).toFixed(2);
                                        const barColor = i === probs.indexOf(Math.max(...probs)) ? 'bg-indigo-600' : 'bg-gray-300';
                                        return `
                                            <div class="mb-2">
                                                <div class="flex justify-between text-sm mb-1">
                                                    <span>${label}</span>
                                                    <span>${pct}%</span>
                                                </div>
                                                <div class="w-full bg-gray-200 rounded-full h-2.5">
                                                    <div class="${barColor} h-2.5 rounded-full" style="width: ${pct}%"></div>
                                                </div>
                                            </div>
                                        `;
                                    }).join('');

                                    resHtml = `<div class="p-3 bg-white border rounded"><h5 class="text-sm font-semibold mb-2">預測機率分佈：</h5>${probList}</div>`;
                                }

                                resultDiv.innerHTML = resHtml;
                            } catch (err) {
                                resultDiv.innerHTML = `<p class="text-red-500">預測錯誤: ${err.message}</p>`;
                            }
                        });
                    }
                }
            } // Close runNeuralNetworkTraining
            
        // ==========================================
        // Double Exponential Smoothing (Holt's Linear) Implementation
        // ==========================================

        function toggleDoubleExpAutoParams() {
            const isChecked = document.getElementById('doubleExpAutoParams').checked;
            const manualContainer = document.getElementById('doubleExpManualParamsContainer');
            const autoResult = document.getElementById('doubleExpAutoResult');

            if (isChecked) {
                manualContainer.classList.add('hidden');
                if (autoResult.innerText.trim() !== "") {
                    autoResult.classList.remove('hidden');
                }
            } else {
                manualContainer.classList.remove('hidden');
                autoResult.classList.add('hidden');
            }
        }

        // Holt's Linear Trend Method Algorithm
        function doubleExponential(series, alpha, beta, m) {
            if (series.length < 2) throw new Error("需要至少兩筆數據來初始化模型。");

            let level, trend;
            
            // Standard Holt's initialization: L0 = Y0, T0 = Y1 - Y0
            let l_prev = series[0];
            let t_prev = series[1] - series[0];
            
            const smoothedResult = new Array(series.length).fill(0);
            const fitted = new Array(series.length).fill(null);
            
            smoothedResult[0] = series[0]; 
            // no fitted[0], as we need existing L, T. We can imagine fitted[0] if we had history.

            // Fit model starting from second point
            for (let i = 1; i < series.length; i++) {
                // One-Step-Ahead Forecast for i (made at i-1)
                fitted[i] = l_prev + t_prev;
                
                const y = series[i];
                const l_curr = alpha * y + (1 - alpha) * (l_prev + t_prev);
                const t_curr = beta * (l_curr - l_prev) + (1 - beta) * t_prev;
                
                smoothedResult[i] = l_curr;
                
                l_prev = l_curr;
                t_prev = t_curr;
            }
            
            // Forecast
            const forecasts = [];
            for (let h = 1; h <= m; h++) {
                const f = l_prev + h * t_prev;
                forecasts.push(f);
            }
            
            return { smoothed: smoothedResult, forecasts, fitted };
        }

        function autoOptimizeDoubleExponential(series) {
            const trainSize = Math.floor(series.length * 0.8);
            if (trainSize < 2) {
                 return { bestParams: { alpha: 0.5, beta: 0.5 }, bestMAE: NaN, message: '數據不足' };
            }
            
            const trainData = series.slice(0, trainSize);
            const valData = series.slice(trainSize);
            
            let bestMAE = Infinity;
            let bestParams = { alpha: 0.5, beta: 0.5 };
            
            // Grid search simple
            for (let a = 0.1; a <= 0.9; a += 0.1) {
                for (let b = 0.1; b <= 0.9; b += 0.1) {
                    try {
                        const { forecasts } = doubleExponential(trainData, a, b, valData.length);
                        const mae = computeMAE(valData, forecasts);
                        
                        if (mae < bestMAE) {
                            bestMAE = mae;
                            bestParams = { alpha: parseFloat(a.toFixed(1)), beta: parseFloat(b.toFixed(1)) };
                        }
                    } catch (e) {}
                }
            }
            return { bestParams, bestMAE };
        }

        function runDoubleExponential() {
            const timeVar = document.getElementById('doubleExpTimeVar').value;
            const valueVar = document.getElementById('doubleExpValueVar').value;
            const steps = parseInt(document.getElementById('doubleExpSteps').value);
            const resultsDiv = document.getElementById('doubleExpResults');
            const autoResult = document.getElementById('doubleExpAutoResult');
            
            resultsDiv.innerHTML = '';
            
            if (!timeVar || !valueVar || !steps) {
                resultsDiv.innerHTML = `<p class="text-red-600">請選擇欄位並填寫預測期數。</p>`;
                return;
            }
            
            const seriesData = jsonData.map(row => ({ time: row[timeVar], value: row[valueVar] }))
                                       .filter(d => d.time != null && typeof d.value === 'number');
            seriesData.sort((a, b) => a.time < b.time ? -1 : 1);
            const yValues = seriesData.map(d => d.value);
            
            if (yValues.length < 2) {
                resultsDiv.innerHTML = `<p class="text-red-600">數據不足 (至少需 2 筆)。</p>`;
                return;
            }
            
            const autoEnabled = document.getElementById('doubleExpAutoParams').checked;
            
            if (autoEnabled) {
                resultsDiv.innerHTML = `<p class="text-blue-600">🔍 正在優化參數 (Grid Search)...</p>`;
                setTimeout(() => {
                    const { bestParams, bestMAE } = autoOptimizeDoubleExponential(yValues);
                    const alpha = bestParams.alpha;
                    const beta = bestParams.beta;
                    
                    document.getElementById('doubleExpAlpha').value = alpha;
                    document.getElementById('doubleExpBeta').value = beta;
                    
                    autoResult.innerHTML = `✅ 最佳參數 (驗證集 MAE=${!isNaN(bestMAE) ? bestMAE.toFixed(2) : 'N/A'}): α=${alpha}, β=${beta}`;
                    autoResult.className = 'text-sm text-green-600 mb-3';
                    autoResult.classList.remove('hidden');
                    
                    runDoubleExponentialWithParams(yValues, seriesData, alpha, beta, steps, timeVar, valueVar, resultsDiv);
                }, 50);
            } else {
                const alpha = parseFloat(document.getElementById('doubleExpAlpha').value);
                const beta = parseFloat(document.getElementById('doubleExpBeta').value);
                autoResult.classList.add('hidden');
                runDoubleExponentialWithParams(yValues, seriesData, alpha, beta, steps, timeVar, valueVar, resultsDiv);
            }
        }

        function runDoubleExponentialWithParams(yValues, seriesData, alpha, beta, steps, timeVar, valueVar, resultsDiv) {
            try {
                const { smoothed, forecasts, fitted } = doubleExponential(yValues, alpha, beta, steps);
                
                let absPercentErrors = [];
                for (let i = 1; i < yValues.length; i++) {
                    // Use fitted[i] (one-step prediction)
                    const pred = fitted[i];
                    if (Math.abs(yValues[i]) > 0.0001 && pred !== null) {
                         absPercentErrors.push(Math.abs((yValues[i] - pred) / yValues[i]));
                    }
                }
                const mape = absPercentErrors.length > 0 ? ss.mean(absPercentErrors) * 100 : 0;
                
                const plotDiv = document.createElement('div');
                plotDiv.id = 'doubleExpPlot';
                resultsDiv.innerHTML = ''; 
                resultsDiv.appendChild(plotDiv);
                
                const originalX = seriesData.map(d => d.time instanceof Date ? d.time.toLocaleDateString() : d.time);
                const futureX = [];
                const lastTime = seriesData[seriesData.length - 1].time;
                 if (lastTime instanceof Date) {
                    for (let i = 1; i <= steps; i++) {
                        const nextDate = new Date(lastTime);
                        nextDate.setMonth(nextDate.getMonth() + i);
                        futureX.push(nextDate.toLocaleDateString());
                    }
                } else if (!isNaN(lastTime)) {
                     for (let i = 1; i <= steps; i++) futureX.push(Number(lastTime) + i);
                } else {
                    for (let i = 1; i <= steps; i++) futureX.push(`預測 ${i}`);
                }
                
                const trace1 = { x: originalX, y: yValues, mode: 'lines+markers', name: '原始數據' };
                // Plot Fitted Values (One-Step Forecast)
                const trace2 = { x: originalX, y: fitted, mode: 'lines', name: '一步預測 (Lagged)', line: { dash: 'dot', color: 'orange' } };
                
                // Connect forecast to last data point
                const forecastX = [originalX[originalX.length-1], ...futureX];
                const forecastY = [fitted[fitted.length-1] || yValues[yValues.length-1], ...forecasts];
                
                const trace3 = { x: forecastX, y: forecastY, mode: 'lines+markers', name: '預測值', line: { color: 'red' } };
                
                const layout = { title: `${valueVar} 雙指數平滑預測 (α=${alpha}, β=${beta})`, xaxis: { title: timeVar }, yaxis: { title: valueVar }, paper_bgcolor: '#f9f9f9' };
                Plotly.newPlot('doubleExpPlot', [trace1, trace2, trace3], layout, {responsive:true});
                
                let tableHtml = `<div class="mt-4 p-4 bg-blue-50 border-l-4 border-blue-500 rounded-r-lg">
                    <h4 class="font-bold">模型準確度</h4>
                    <p class="text-gray-700 mt-1">MAPE: <strong>${mape.toFixed(2)}%</strong></p>
                </div>
                <h3 class="text-lg font-semibold mt-6 mb-2">預測結果</h3>
                <div class="overflow-x-auto"><table class="min-w-full divide-y divide-gray-200">
                <thead class="bg-gray-50"><tr><th class="p-2 text-left text-xs font-medium text-gray-500">未來期數</th><th class="p-2 text-left text-xs font-medium text-gray-500">預測值</th></tr></thead>
                <tbody class="bg-white divide-y divide-gray-200">`;
                
                forecasts.forEach((val, i) => {
                    tableHtml += `<tr><td class="p-2 text-sm text-gray-900">${futureX[i]}</td><td class="p-2 text-sm text-gray-500">${val.toFixed(2)}</td></tr>`;
                });
                tableHtml += `</tbody></table></div>`;
                resultsDiv.innerHTML += tableHtml;
                
            } catch(e) {
                resultsDiv.innerHTML = `<p class="text-red-600">Error: ${e.message}</p>`;
            }
        }

        // ==========================================
        // Moving Average Implementation
        // ==========================================

        function toggleMovingAverageAutoParams() {
            const isChecked = document.getElementById('movingAverageAutoParams').checked;
            const manualContainer = document.getElementById('movingAverageManualParamsContainer');
            const autoResult = document.getElementById('movingAverageAutoResult');

            if (isChecked) {
                manualContainer.classList.add('hidden');
                if (autoResult.innerText.trim() !== "") {
                    autoResult.classList.remove('hidden');
                }
            } else {
                manualContainer.classList.remove('hidden');
                autoResult.classList.add('hidden');
            }
        }

        function simpleMovingAverage(series, k, m) {
            if (series.length < k) throw new Error(`數據長度 (${series.length}) 小於 Window Size (${k})`);
            
            const smoothedResult = new Array(series.length).fill(null);
            
            // Calculate Moving Average
            for (let i = k - 1; i < series.length; i++) {
                let sum = 0;
                for (let j = 0; j < k; j++) {
                    sum += series[i - j];
                }
                smoothedResult[i] = sum / k;
            }
            
            // Forecast (Naive: Last MA value projected forward)
            // Or typically for SMA: Forecast_{t+1} = MA_t
            // For multiple steps, we just project the last calculated MA (flat forecast)
            const lastMA = smoothedResult[series.length - 1];
            const forecasts = new Array(m).fill(lastMA);
            
            return { smoothed: smoothedResult, forecasts };
        }

        function autoOptimizeMovingAverage(series) {
            const trainSize = Math.floor(series.length * 0.8);
            if (trainSize < 2) return { bestK: 3, bestMAE: NaN };
            
            const trainData = series.slice(0, trainSize);
            const valData = series.slice(trainSize);
            
            let bestMAE = Infinity;
            let bestK = 3;
            
            // Grid search for window size k
            // Range: 2 to length/2 or max 24
            const maxK = Math.min(Math.floor(trainData.length / 2), 24);
            
            for (let k = 2; k <= maxK; k++) {
                try {
                     // Forecast for validation period using rolling MA
                     // Note: To evaluate k properly on validation set, we act as if we are at end of train set
                     // forecast value = simpleMovingAverage(trainData, k, 1).smoothed.last
                     // But strictly, SMA error is usually calculated on 1-step ahead in-sample errors or out-of-sample
                     
                     // Let's use simple approach: Minimize MAE on the *last part which is valData*
                     // Wait, for SMA forecast is flat. So we check error of Flat Forecast vs ValData?
                     // Yes, Test error = ValData - LastTrainMA
                     
                     const { smoothed } = simpleMovingAverage(trainData, k, 0);
                     const lastTrainMA = smoothed[smoothed.length-1];
                     
                     let currentMAE = 0;
                     for(let v of valData) {
                         currentMAE += Math.abs(v - lastTrainMA);
                     }
                     currentMAE /= valData.length;
                     
                     if (currentMAE < bestMAE) {
                         bestMAE = currentMAE;
                         bestK = k;
                     }
                } catch(e) {}
            }
            
            return { bestK, bestMAE };
        }

        function runMovingAverage() {
            const timeVar = document.getElementById('movingAverageTimeVar').value;
            const valueVar = document.getElementById('movingAverageValueVar').value;
            const steps = parseInt(document.getElementById('movingAverageSteps').value);
            const resultsDiv = document.getElementById('movingAverageResults');
            const autoResult = document.getElementById('movingAverageAutoResult');
            
            resultsDiv.innerHTML = '';
            
            if (!timeVar || !valueVar || !steps) {
                resultsDiv.innerHTML = `<p class="text-red-600">請選擇欄位並填寫預測期數。</p>`;
                return;
            }
            
            const seriesData = jsonData.map(row => ({ time: row[timeVar], value: row[valueVar] }))
                                       .filter(d => d.time != null && typeof d.value === 'number');
            seriesData.sort((a, b) => a.time < b.time ? -1 : 1);
            const yValues = seriesData.map(d => d.value);
            
            if (yValues.length < 4) {
                resultsDiv.innerHTML = `<p class="text-red-600">數據不足 (至少需 4 筆)。</p>`;
                return;
            }
            
            const autoEnabled = document.getElementById('movingAverageAutoParams').checked;
            
            if (autoEnabled) {
                resultsDiv.innerHTML = `<p class="text-blue-600">🔍 正在優化參數 (尋找最佳 Window Size)...</p>`;
                setTimeout(() => {
                    const { bestK, bestMAE } = autoOptimizeMovingAverage(yValues);
                    
                    document.getElementById('movingAverageWindow').value = bestK;
                    
                    autoResult.innerHTML = `✅ 最佳參數 (驗證集 MAE=${!isNaN(bestMAE) ? bestMAE.toFixed(2) : 'N/A'}): Window Size k=${bestK}`;
                    autoResult.className = 'text-sm text-green-600 mb-3';
                    autoResult.classList.remove('hidden');
                    
                    runMovingAverageWithParams(yValues, seriesData, bestK, steps, timeVar, valueVar, resultsDiv);
                }, 50);
            } else {
                const k = parseInt(document.getElementById('movingAverageWindow').value);
                autoResult.classList.add('hidden');
                runMovingAverageWithParams(yValues, seriesData, k, steps, timeVar, valueVar, resultsDiv);
            }
        }

        function runMovingAverageWithParams(yValues, seriesData, k, steps, timeVar, valueVar, resultsDiv) {
            try {
                const { smoothed, forecasts } = simpleMovingAverage(yValues, k, steps);
                
                // Calculate MAPE (Using One-Step-Ahead Forecast: compare y[i] with smoothed[i-1])
                let absPercentErrors = [];
                // Comparison starts at i = k because we need smoothed[k-1] to predict y[k]
                for (let i = k; i < yValues.length; i++) {
                    const predicted = smoothed[i - 1];
                    if (Math.abs(yValues[i]) > 0.0001) {
                        absPercentErrors.push(Math.abs((yValues[i] - predicted) / yValues[i]));
                    }
                }
                const mape = absPercentErrors.length > 0 ? ss.mean(absPercentErrors) * 100 : 0;
                
                const plotDiv = document.createElement('div');
                plotDiv.id = 'movingAveragePlot';
                resultsDiv.innerHTML = ''; 
                resultsDiv.appendChild(plotDiv);
                
                const originalX = seriesData.map(d => d.time instanceof Date ? d.time.toLocaleDateString() : d.time);
                const futureX = [];
                const lastTime = seriesData[seriesData.length - 1].time;
                 if (lastTime instanceof Date) {
                    for (let i = 1; i <= steps; i++) {
                        const nextDate = new Date(lastTime);
                        nextDate.setMonth(nextDate.getMonth() + i);
                        futureX.push(nextDate.toLocaleDateString());
                    }
                } else if (!isNaN(lastTime)) {
                     for (let i = 1; i <= steps; i++) futureX.push(Number(lastTime) + i);
                } else {
                    for (let i = 1; i <= steps; i++) futureX.push(`預測 ${i}`);
                }
                
                // Generate Fitted Values (One-Step-Ahead Forecast) for Plotting
                // fitted[i] = smoothed[i-1]
                const fittedValues = new Array(yValues.length).fill(null);
                for (let i = k; i < yValues.length; i++) {
                    fittedValues[i] = smoothed[i - 1];
                }

                const trace1 = { x: originalX, y: yValues, mode: 'lines+markers', name: '原始數據' };
                // Plot Fitted Values (Shifted MA)
                const trace2 = { x: originalX, y: fittedValues, mode: 'lines', name: `一步預測 (Lagged MA, k=${k})`, line: { dash: 'dot', color: 'orange' } };
                const trace3 = { x: futureX, y: forecasts, mode: 'lines+markers', name: '預測值 (Flat)', line: { color: 'red' } };
                
                const layout = { title: `${valueVar} 移動平均預測 (最佳間隔=${k})`, xaxis: { title: timeVar }, yaxis: { title: valueVar }, paper_bgcolor: '#f9f9f9' };
                Plotly.newPlot('movingAveragePlot', [trace1, trace2, trace3], layout, {responsive:true});
                
                let tableHtml = `<div class="mt-4 p-4 bg-blue-50 border-l-4 border-blue-500 rounded-r-lg">
                    <h4 class="font-bold">模型準確度 (In-Sample Fitting)</h4>
                    <p class="text-gray-700 mt-1">MAPE: <strong>${mape.toFixed(2)}%</strong></p>
                    <p class="text-xs text-gray-500 mt-1">注意：簡單移動平均之預測值為水平直線 (Flat Forecast)，適合無明顯趨勢的數據。</p>
                </div>
                <h3 class="text-lg font-semibold mt-6 mb-2">預測結果</h3>
                <div class="overflow-x-auto"><table class="min-w-full divide-y divide-gray-200">
                <thead class="bg-gray-50"><tr><th class="p-2 text-left text-xs font-medium text-gray-500">未來期數</th><th class="p-2 text-left text-xs font-medium text-gray-500">預測值</th></tr></thead>
                <tbody class="bg-white divide-y divide-gray-200">`;
                
                forecasts.forEach((val, i) => {
                    tableHtml += `<tr><td class="p-2 text-sm text-gray-900">${futureX[i]}</td><td class="p-2 text-sm text-gray-500">${val.toFixed(2)}</td></tr>`;
                });
                tableHtml += `</tbody></table></div>`;
                resultsDiv.innerHTML += tableHtml;
                
            } catch(e) {
                resultsDiv.innerHTML = `<p class="text-red-600">Error: ${e.message}</p>`;
            }
        }

        // ==========================================
        // Single Exponential Smoothing (Simple Exponential)
        // ==========================================

        function toggleSingleExpAutoParams() {
            const isChecked = document.getElementById('singleExpAutoParams').checked;
            const manualContainer = document.getElementById('singleExpManualParamsContainer');
            const autoResult = document.getElementById('singleExpAutoResult');

            if (isChecked) {
                manualContainer.classList.add('hidden');
                if (autoResult.innerText.trim() !== "") {
                    autoResult.classList.remove('hidden');
                }
            } else {
                manualContainer.classList.remove('hidden');
                autoResult.classList.add('hidden');
            }
        }

        function singleExponential(series, alpha, m) {
            if (series.length < 1) throw new Error("數據不足");
            
            const smoothedResult = new Array(series.length).fill(0);
            
            // Initialization: L_0 = Y_0
            smoothedResult[0] = series[0];
            let level = series[0];
            
            for (let i = 1; i < series.length; i++) {
                const y = series[i];
                // L_t = alpha * Y_t + (1-alpha) * L_{t-1}
                level = alpha * y + (1 - alpha) * level;
                smoothedResult[i] = level;
            }
            
            // Forecast: Flat forecast L_T
            const forecasts = new Array(m).fill(level);
            
            return { smoothed: smoothedResult, forecasts };
        }

        function autoOptimizeSingleExponential(series) {
            const trainSize = Math.floor(series.length * 0.8);
            if (trainSize < 2) return { bestParams: { alpha: 0.5 }, bestMAE: NaN };
            
            const trainData = series.slice(0, trainSize);
            const valData = series.slice(trainSize);
            
            let bestMAE = Infinity;
            let bestParams = { alpha: 0.5 };
            
            for (let a = 0.1; a <= 0.9; a += 0.1) {
                try {
                     // For correct SES optimization on validation data:
                     // We fit model on train -> get last Level L_T
                     // Then forecast flat for Val data and compare
                     const { forecasts } = singleExponential(trainData, a, valData.length);
                     const flatForecast = forecasts[0];
                     
                     let mae = 0;
                     for(let v of valData) mae += Math.abs(v - flatForecast);
                     mae /= valData.length;
                     
                     if (mae < bestMAE) {
                         bestMAE = mae;
                         bestParams = { alpha: parseFloat(a.toFixed(1)) };
                     }
                } catch(e) {}
            }
            return { bestParams, bestMAE };
        }

        function runSingleExponential() {
            const timeVar = document.getElementById('singleExpTimeVar').value;
            const valueVar = document.getElementById('singleExpValueVar').value;
            const steps = parseInt(document.getElementById('singleExpSteps').value);
            const resultsDiv = document.getElementById('singleExpResults');
            const autoResult = document.getElementById('singleExpAutoResult');
            
            resultsDiv.innerHTML = '';
            
            if (!timeVar || !valueVar || !steps) {
                resultsDiv.innerHTML = `<p class="text-red-600">請選擇欄位並填寫預測期數。</p>`;
                return;
            }
            
            const seriesData = jsonData.map(row => ({ time: row[timeVar], value: row[valueVar] }))
                                       .filter(d => d.time != null && typeof d.value === 'number');
            seriesData.sort((a, b) => a.time < b.time ? -1 : 1);
            const yValues = seriesData.map(d => d.value);
            
            if (yValues.length < 2) {
                resultsDiv.innerHTML = `<p class="text-red-600">數據不足。</p>`;
                return;
            }
            
            const autoEnabled = document.getElementById('singleExpAutoParams').checked;
            
            if (autoEnabled) {
                resultsDiv.innerHTML = `<p class="text-blue-600">🔍 正在優化參數 (Alpha)...</p>`;
                setTimeout(() => {
                    const { bestParams, bestMAE } = autoOptimizeSingleExponential(yValues);
                    const alpha = bestParams.alpha;
                    
                    document.getElementById('singleExpAlpha').value = alpha;
                    
                    autoResult.innerHTML = `✅ 最佳參數 (驗證集 MAE=${!isNaN(bestMAE) ? bestMAE.toFixed(2) : 'N/A'}): α=${alpha}`;
                    autoResult.className = 'text-sm text-green-600 mb-3';
                    autoResult.classList.remove('hidden');
                    
                    runSingleExponentialWithParams(yValues, seriesData, alpha, steps, timeVar, valueVar, resultsDiv);
                }, 50);
            } else {
                const alpha = parseFloat(document.getElementById('singleExpAlpha').value);
                autoResult.classList.add('hidden');
                runSingleExponentialWithParams(yValues, seriesData, alpha, steps, timeVar, valueVar, resultsDiv);
            }
        }

        function runSingleExponentialWithParams(yValues, seriesData, alpha, steps, timeVar, valueVar, resultsDiv) {
             try {
                const { smoothed, forecasts } = singleExponential(yValues, alpha, steps);
                
                // Calculate MAPE (One-Step-Ahead Forecast)
                let absPercentErrors = [];
                // Prediction for y[i] is smoothed[i-1] (Level at t-1)
                for (let i = 1; i < yValues.length; i++) {
                    const pred = smoothed[i-1];
                    if (Math.abs(yValues[i]) > 0.0001) {
                        absPercentErrors.push(Math.abs((yValues[i] - pred) / yValues[i]));
                    }
                }
                const mape = absPercentErrors.length > 0 ? ss.mean(absPercentErrors) * 100 : 0;
                
                const plotDiv = document.createElement('div');
                plotDiv.id = 'singleExpPlot';
                resultsDiv.innerHTML = ''; 
                resultsDiv.appendChild(plotDiv);
                
                const originalX = seriesData.map(d => d.time instanceof Date ? d.time.toLocaleDateString() : d.time);
                const futureX = [];
                const lastTime = seriesData[seriesData.length - 1].time;
                 if (lastTime instanceof Date) {
                    for (let i = 1; i <= steps; i++) {
                        const nextDate = new Date(lastTime);
                        nextDate.setMonth(nextDate.getMonth() + i);
                        futureX.push(nextDate.toLocaleDateString());
                    }
                } else if (!isNaN(lastTime)) {
                     for (let i = 1; i <= steps; i++) futureX.push(Number(lastTime) + i);
                } else {
                    for (let i = 1; i <= steps; i++) futureX.push(`預測 ${i}`);
                }
                
                const trace1 = { x: originalX, y: yValues, mode: 'lines+markers', name: '原始數據' };
                
                // Generate Fitted Values (One-Step Forecast)
                const fittedValues = new Array(yValues.length).fill(null);
                for(let i=1; i<yValues.length; i++) {
                    fittedValues[i] = smoothed[i-1];
                }
                
                const trace2 = { x: originalX, y: fittedValues, mode: 'lines', name: '一步預測 (Lagged)', line: { dash: 'dot', color: 'orange' } };
                const trace3 = { x: futureX, y: forecasts, mode: 'lines+markers', name: '預測值 (Flat)', line: { color: 'red' } };
                
                const layout = { title: `${valueVar} 單指數平滑預測 (α=${alpha})`, xaxis: { title: timeVar }, yaxis: { title: valueVar }, paper_bgcolor: '#f9f9f9' };
                Plotly.newPlot('singleExpPlot', [trace1, trace2, trace3], layout, {responsive:true});
                
                let tableHtml = `<div class="mt-4 p-4 bg-blue-50 border-l-4 border-blue-500 rounded-r-lg">
                    <h4 class="font-bold">模型準確度</h4>
                    <p class="text-gray-700 mt-1">MAPE: <strong>${mape.toFixed(2)}%</strong></p>
                    <p class="text-xs text-gray-500 mt-1">注意：單指數平滑之預測值為水平直線 (Flat Forecast)，適合無趨勢無季節性數據。</p>
                </div>
                <h3 class="text-lg font-semibold mt-6 mb-2">預測結果</h3>
                <div class="overflow-x-auto"><table class="min-w-full divide-y divide-gray-200">
                <thead class="bg-gray-50"><tr><th class="p-2 text-left text-xs font-medium text-gray-500">未來期數</th><th class="p-2 text-left text-xs font-medium text-gray-500">預測值</th></tr></thead>
                <tbody class="bg-white divide-y divide-gray-200">`;
                
                forecasts.forEach((val, i) => {
                    tableHtml += `<tr><td class="p-2 text-sm text-gray-900">${futureX[i]}</td><td class="p-2 text-sm text-gray-500">${val.toFixed(2)}</td></tr>`;
                });
                tableHtml += `</tbody></table></div>`;
                resultsDiv.innerHTML += tableHtml;
                
            } catch(e) {
                resultsDiv.innerHTML = `<p class="text-red-600">Error: ${e.message}</p>`;
            }
        }

        // ==========================================
        // LSTM (Long Short-Term Memory) Forecasting
        // ==========================================

        async function runLstmForecast() {
            const timeVar = document.getElementById('lstmTimeVar').value;
            const valueVar = document.getElementById('lstmValueVar').value;
            const lookback = parseInt(document.getElementById('lstmLookback').value);
            const epochs = parseInt(document.getElementById('lstmEpochs').value);
            const steps = parseInt(document.getElementById('lstmSteps').value);
            
            const resultsDiv = document.getElementById('lstmResults');
            const progressDiv = document.getElementById('lstmProgress');
            const progressBar = document.getElementById('lstmProgressBar');
            const progressText = document.getElementById('lstmProgressText');
            
            resultsDiv.innerHTML = '';
            
            if (!timeVar || !valueVar) {
                resultsDiv.innerHTML = `<p class="text-red-600">請選擇時間和數值欄位。</p>`;
                return;
            }
            
            // Prepare data
            const seriesData = jsonData.map(row => ({ time: row[timeVar], value: row[valueVar] }))
                                       .filter(d => d.time != null && typeof d.value === 'number');
            seriesData.sort((a, b) => a.time < b.time ? -1 : 1);
            const yValues = seriesData.map(d => d.value);
            
            if (yValues.length < lookback + 5) {
                resultsDiv.innerHTML = `<p class="text-red-600">數據不足。需要至少 ${lookback + 5} 筆數據 (Lookback + 5)。</p>`;
                return;
            }
            
            // Show progress
            progressDiv.classList.remove('hidden');
            progressBar.style.width = '0%';
            progressText.textContent = '正在準備數據...';
            
            try {
                // Normalize data (Min-Max scaling)
                const min = Math.min(...yValues);
                const max = Math.max(...yValues);
                const range = max - min || 1;
                const normalizedData = yValues.map(v => (v - min) / range);
                
                // Create sequences for LSTM
                const X = [];
                const Y = [];
                for (let i = 0; i < normalizedData.length - lookback; i++) {
                    X.push(normalizedData.slice(i, i + lookback));
                    Y.push(normalizedData[i + lookback]);
                }
                
                // Convert to tensors (shape: [samples, lookback, 1] for LSTM)
                // Build explicit 3D array: [samples][timesteps][features]
                const xData = [];
                for (let i = 0; i < X.length; i++) {
                    const seq = [];
                    for (let j = 0; j < X[i].length; j++) {
                        seq.push([X[i][j]]); // Each timestep has 1 feature
                    }
                    xData.push(seq);
                }
                const xTensor = tf.tensor3d(xData);
                const yTensor = tf.tensor2d(Y.map(v => [v]));
                
                progressText.textContent = '正在建立 LSTM 模型...';
                progressBar.style.width = '10%';
                
                // Build LSTM model
                const model = tf.sequential();
                model.add(tf.layers.lstm({
                    units: 32,
                    inputShape: [lookback, 1],
                    returnSequences: false
                }));
                model.add(tf.layers.dense({ units: 1 }));
                
                model.compile({
                    optimizer: tf.train.adam(0.01),
                    loss: 'meanSquaredError'
                });
                
                progressText.textContent = '正在訓練模型 (0%)...';
                progressBar.style.width = '15%';
                
                // Train model with progress updates
                await model.fit(xTensor, yTensor, {
                    epochs: epochs,
                    batchSize: 16,
                    shuffle: true,
                    callbacks: {
                        onEpochEnd: (epoch, logs) => {
                            const pct = 15 + Math.floor((epoch / epochs) * 70);
                            progressBar.style.width = `${pct}%`;
                            progressText.textContent = `正在訓練模型 (${epoch + 1}/${epochs}) - Loss: ${logs.loss.toFixed(6)}`;
                        }
                    }
                });
                
                progressText.textContent = '正在生成預測...';
                progressBar.style.width = '90%';
                
                // Generate fitted values (in-sample predictions)
                const fittedNorm = [];
                for (let i = 0; i < X.length; i++) {
                    // Build single sample 3D array: [1][lookback][1]
                    const singleSeq = [];
                    for (let j = 0; j < X[i].length; j++) {
                        singleSeq.push([X[i][j]]);
                    }
                    const inputSeq = tf.tensor3d([singleSeq]);
                    const pred = model.predict(inputSeq);
                    const predVal = pred.dataSync()[0];
                    fittedNorm.push(predVal);
                    inputSeq.dispose();
                    pred.dispose();
                }
                
                // Generate future forecasts (multi-step)
                const forecastsNorm = [];
                let lastSequence = normalizedData.slice(-lookback);
                
                for (let h = 0; h < steps; h++) {
                    // Build single sample 3D array: [1][lookback][1]
                    const singleSeq = [];
                    for (let j = 0; j < lastSequence.length; j++) {
                        singleSeq.push([lastSequence[j]]);
                    }
                    const inputSeq = tf.tensor3d([singleSeq]);
                    const pred = model.predict(inputSeq);
                    const predVal = pred.dataSync()[0];
                    forecastsNorm.push(predVal);
                    
                    // Shift sequence and append prediction
                    lastSequence = [...lastSequence.slice(1), predVal];
                    
                    inputSeq.dispose();
                    pred.dispose();
                }
                
                // Denormalize
                const fitted = fittedNorm.map(v => v * range + min);
                const forecasts = forecastsNorm.map(v => v * range + min);
                
                // Calculate MAPE (on fitted part, aligned with Y)
                const yActual = yValues.slice(lookback);
                let absPercentErrors = [];
                for (let i = 0; i < yActual.length; i++) {
                    if (Math.abs(yActual[i]) > 0.0001) {
                        absPercentErrors.push(Math.abs((yActual[i] - fitted[i]) / yActual[i]));
                    }
                }
                const mape = absPercentErrors.length > 0 ? ss.mean(absPercentErrors) * 100 : 0;
                
                progressText.textContent = '完成!';
                progressBar.style.width = '100%';
                
                // Cleanup
                xTensor.dispose();
                yTensor.dispose();
                model.dispose();
                
                // Visualization
                setTimeout(() => {
                    progressDiv.classList.add('hidden');
                    
                    const plotDiv = document.createElement('div');
                    plotDiv.id = 'lstmPlot';
                    resultsDiv.appendChild(plotDiv);
                    
                    // X-axis labels
                    const originalX = seriesData.map(d => d.time instanceof Date ? d.time.toLocaleDateString() : d.time);
                    const fittedX = originalX.slice(lookback);
                    
                    const futureX = [];
                    const lastTime = seriesData[seriesData.length - 1].time;
                    if (lastTime instanceof Date) {
                        for (let i = 1; i <= steps; i++) {
                            const nextDate = new Date(lastTime);
                            nextDate.setMonth(nextDate.getMonth() + i);
                            futureX.push(nextDate.toLocaleDateString());
                        }
                    } else if (!isNaN(lastTime)) {
                        for (let i = 1; i <= steps; i++) futureX.push(Number(lastTime) + i);
                    } else {
                        for (let i = 1; i <= steps; i++) futureX.push(`預測 ${i}`);
                    }
                    
                    const trace1 = { x: originalX, y: yValues, mode: 'lines+markers', name: '原始數據', line: { color: '#3B82F6' } };
                    const trace2 = { x: fittedX, y: fitted, mode: 'lines', name: 'LSTM 擬合', line: { dash: 'dot', color: 'orange' } };
                    const trace3 = { x: futureX, y: forecasts, mode: 'lines+markers', name: '預測值', line: { color: 'red' } };
                    
                    const layout = {
                        title: `${valueVar} LSTM 預測 (Lookback=${lookback}, Epochs=${epochs})`,
                        xaxis: { title: timeVar },
                        yaxis: { title: valueVar },
                        paper_bgcolor: '#f9f9f9'
                    };
                    Plotly.newPlot('lstmPlot', [trace1, trace2, trace3], layout, { responsive: true });
                    
                    // Results table
                    let tableHtml = `
                    <div class="mt-4 grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div class="p-4 bg-indigo-50 border-l-4 border-indigo-500 rounded-r-lg">
                            <h4 class="font-bold text-indigo-800">模型準確度</h4>
                            <p class="text-gray-700 mt-1">MAPE: <strong>${mape.toFixed(2)}%</strong></p>
                        </div>
                        <div class="p-4 bg-gray-50 border-l-4 border-gray-400 rounded-r-lg">
                            <h4 class="font-bold text-gray-700">模型參數</h4>
                            <p class="text-sm text-gray-600 mt-1">Lookback: ${lookback}, Epochs: ${epochs}, LSTM Units: 32</p>
                        </div>
                    </div>
                    <h3 class="text-lg font-semibold mt-6 mb-2">預測結果</h3>
                    <div class="overflow-x-auto"><table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50"><tr><th class="p-2 text-left text-xs font-medium text-gray-500">未來期數</th><th class="p-2 text-left text-xs font-medium text-gray-500">預測值</th></tr></thead>
                    <tbody class="bg-white divide-y divide-gray-200">`;
                    
                    forecasts.forEach((val, i) => {
                        tableHtml += `<tr><td class="p-2 text-sm text-gray-900">${futureX[i]}</td><td class="p-2 text-sm text-gray-500">${val.toFixed(2)}</td></tr>`;
                    });
                    tableHtml += `</tbody></table></div>`;
                    resultsDiv.innerHTML += tableHtml;
                    
                }, 500);
                
            } catch (e) {
                progressDiv.classList.add('hidden');
                resultsDiv.innerHTML = `<p class="text-red-600">LSTM 錯誤: ${e.message}</p>`;
                console.error('LSTM Error:', e);
            }
        }

        // ==========================================
        // Bass Diffusion Model
        // ==========================================

        function runBassDiffusion() {
            const p = parseFloat(document.getElementById('bassPValue').value);
            const q = parseFloat(document.getElementById('bassQValue').value);
            const m = parseFloat(document.getElementById('bassMValue').value);
            const periods = parseInt(document.getElementById('bassPeriods').value);
            
            const resultsDiv = document.getElementById('bassResults');
            resultsDiv.innerHTML = '';
            
            if (isNaN(p) || isNaN(q) || isNaN(m) || isNaN(periods) || p <= 0 || q <= 0 || m <= 0 || periods < 1) {
                resultsDiv.innerHTML = `<p class="text-red-600">請輸入有效的參數值 (p, q, m > 0)。</p>`;
                return;
            }
            
            // Bass Model calculation
            // F(t) = [1 - e^(-(p+q)t)] / [1 + (q/p)e^(-(p+q)t)]  (Cumulative adoption fraction)
            // N(t) = m * F(t)  (Cumulative adopters)
            // n(t) = N(t) - N(t-1)  (New adopters at time t)
            
            const timePoints = [];
            const cumulativeAdoption = []; // F(t)
            const cumulativeAdopters = []; // N(t) = m * F(t)
            const newAdopters = []; // n(t)
            
            for (let t = 0; t <= periods; t++) {
                timePoints.push(t);
                
                // F(t) = [1 - e^(-(p+q)t)] / [1 + (q/p)e^(-(p+q)t)]
                const expTerm = Math.exp(-(p + q) * t);
                const Ft = (1 - expTerm) / (1 + (q / p) * expTerm);
                const Nt = m * Ft;
                
                cumulativeAdoption.push(Ft);
                cumulativeAdopters.push(Nt);
                
                if (t === 0) {
                    newAdopters.push(Nt);
                } else {
                    newAdopters.push(Nt - cumulativeAdopters[t - 1]);
                }
            }
            
            // Find peak time (T*)
            // T* = ln(q/p) / (p + q)
            const peakTime = (q > p) ? Math.log(q / p) / (p + q) : 0;
            const peakAdopters = (q > p) ? m * (p + q) * (p + q) / (4 * q) : newAdopters[0];
            
            // Create charts
            const plotDiv = document.createElement('div');
            plotDiv.id = 'bassPlot';
            resultsDiv.appendChild(plotDiv);
            
            // Trace 1: New Adopters (n(t)) - Bell curve
            const trace1 = {
                x: timePoints,
                y: newAdopters,
                mode: 'lines+markers',
                name: '新採用者 n(t)',
                line: { color: '#10B981', width: 2 },
                fill: 'tozeroy',
                fillcolor: 'rgba(16, 185, 129, 0.2)'
            };
            
            // Trace 2: Cumulative Adopters (N(t)) - S-curve
            const trace2 = {
                x: timePoints,
                y: cumulativeAdopters,
                mode: 'lines+markers',
                name: '累積採用者 N(t)',
                yaxis: 'y2',
                line: { color: '#3B82F6', width: 2, dash: 'dot' }
            };
            
            const layout = {
                title: `Bass 擴散模型 (p=${p}, q=${q}, m=${m.toLocaleString()})`,
                xaxis: { title: '時間期數 (t)' },
                yaxis: { title: '新採用者 n(t)', side: 'left', showgrid: false },
                yaxis2: { title: '累積採用者 N(t)', side: 'right', overlaying: 'y', showgrid: false },
                legend: { x: 0.5, y: 1.1, orientation: 'h', xanchor: 'center' },
                paper_bgcolor: '#f9f9f9'
            };
            
            Plotly.newPlot('bassPlot', [trace1, trace2], layout, { responsive: true });
            
            // Key metrics
            let metricsHtml = `
            <div class="mt-4 grid grid-cols-1 md:grid-cols-3 gap-4">
                <div class="p-4 bg-teal-50 border-l-4 border-teal-500 rounded-r-lg">
                    <h4 class="font-bold text-teal-800">高峰時間 (T*)</h4>
                    <p class="text-2xl font-semibold text-teal-700">${peakTime.toFixed(2)}</p>
                    <p class="text-xs text-gray-500 mt-1">T* = ln(q/p) / (p+q)</p>
                </div>
                <div class="p-4 bg-blue-50 border-l-4 border-blue-500 rounded-r-lg">
                    <h4 class="font-bold text-blue-800">高峰採用量</h4>
                    <p class="text-2xl font-semibold text-blue-700">${peakAdopters.toLocaleString(undefined, {maximumFractionDigits: 0})}</p>
                    <p class="text-xs text-gray-500 mt-1">n(T*) = m(p+q)²/4q</p>
                </div>
                <div class="p-4 bg-purple-50 border-l-4 border-purple-500 rounded-r-lg">
                    <h4 class="font-bold text-purple-800">q/p 比率</h4>
                    <p class="text-2xl font-semibold text-purple-700">${(q/p).toFixed(2)}</p>
                    <p class="text-xs text-gray-500 mt-1">${q/p > 1 ? '模仿效應主導 (S曲線)' : '創新效應主導'}</p>
                </div>
            </div>`;
            
            // Forecast table
            metricsHtml += `
            <h3 class="text-lg font-semibold mt-6 mb-2">預測結果</h3>
            <div class="overflow-x-auto"><table class="min-w-full divide-y divide-gray-200">
            <thead class="bg-gray-50"><tr>
                <th class="p-2 text-left text-xs font-medium text-gray-500">期數 (t)</th>
                <th class="p-2 text-left text-xs font-medium text-gray-500">新採用者 n(t)</th>
                <th class="p-2 text-left text-xs font-medium text-gray-500">累積採用者 N(t)</th>
                <th class="p-2 text-left text-xs font-medium text-gray-500">採用率 F(t)</th>
            </tr></thead>
            <tbody class="bg-white divide-y divide-gray-200">`;
            
            for (let t = 0; t <= periods; t++) {
                metricsHtml += `<tr>
                    <td class="p-2 text-sm text-gray-900">${t}</td>
                    <td class="p-2 text-sm text-gray-500">${newAdopters[t].toLocaleString(undefined, {maximumFractionDigits: 0})}</td>
                    <td class="p-2 text-sm text-gray-500">${cumulativeAdopters[t].toLocaleString(undefined, {maximumFractionDigits: 0})}</td>
                    <td class="p-2 text-sm text-gray-500">${(cumulativeAdoption[t] * 100).toFixed(2)}%</td>
                </tr>`;
            }
            metricsHtml += `</tbody></table></div>`;
            
            resultsDiv.innerHTML += metricsHtml;
        }

            document.addEventListener('DOMContentLoaded', function () {
                const btn = document.getElementById('runNNBtn');
                if (btn) {
                    btn.addEventListener('click', function () {
                        runNeuralNetworkTraining();
                    });
                }
                const btnDoubleExp = document.getElementById('runDoubleExponentialBtn');
                if (btnDoubleExp) {
                    btnDoubleExp.addEventListener('click', runDoubleExponential);
                }
                const btnMA = document.getElementById('runMovingAverageBtn');
                if (btnMA) {
                    btnMA.addEventListener('click', runMovingAverage);
                }
                const btnSingleExp = document.getElementById('runSingleExponentialBtn');
                if (btnSingleExp) {
                    btnSingleExp.addEventListener('click', runSingleExponential);
                }
                const btnLstm = document.getElementById('runLstmBtn');
                if (btnLstm) {
                    btnLstm.addEventListener('click', runLstmForecast);
                }
                const btnBass = document.getElementById('runBassBtn');
                if (btnBass) {
                    btnBass.addEventListener('click', runBassDiffusion);
                }
            });
        })();
    </script>

</body>

</html>